<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.9" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.32" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://javaguide.cn/interview/spring.html"><meta property="og:site_name" content="JavaGuide"><meta property="og:title" content="spring"><meta property="og:description" content="1. Spring是什么？特性？ Spring是一个轻量级、非入侵式的控制反转(IoC)和面向切面(AOP)的框架。 IoC和DI的支持:管理对象生命周期和依赖关系 AOP编程的支持：面向切面编程可以实现对程序进行权限拦截、运行监控等切面功能。 声明式事务的支持：支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式。 快捷测试的支持：支持Juni..."><meta property="og:type" content="article"><meta property="og:image" content="https://290ff162.telegraph-image-eg9.pages.dev/file/9d7d1e010e6a298683def.jpg"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-12-07T01:56:33.000Z"><meta property="article:author" content="HeChuangJun"><meta property="article:published_time" content="2023-01-01T00:00:00.000Z"><meta property="article:modified_time" content="2024-12-07T01:56:33.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"spring","image":["https://290ff162.telegraph-image-eg9.pages.dev/file/9d7d1e010e6a298683def.jpg"],"datePublished":"2023-01-01T00:00:00.000Z","dateModified":"2024-12-07T01:56:33.000Z","author":[{"@type":"Person","name":"HeChuangJun","url":"https://javaguide.cn/article/"}]}</script><meta name="robots" content="all"><meta name="author" content="Guide"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><meta name="keywords" content="Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"><meta name="description" content="「Java学习 + 面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"><meta name="apple-mobile-web-app-capable" content="yes"><script>var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?5dd2e8c97962d57b7b8fea1737c01743";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();</script><link rel="alternate" type="application/atom+xml" href="https://javaguide.cn/atom.xml" title="JavaGuide Atom Feed"><link rel="alternate" type="application/json" href="https://javaguide.cn/feed.json" title="JavaGuide JSON Feed"><link rel="alternate" type="application/rss+xml" href="https://javaguide.cn/rss.xml" title="JavaGuide RSS Feed"><link rel="icon" href="/favicon.ico"><title>spring | JavaGuide</title>
    <link rel="preload" href="/assets/style-B7LVZfe6.css" as="style"><link rel="stylesheet" href="/assets/style-B7LVZfe6.css">
    <link rel="modulepreload" href="/assets/app-7KT7HDzT.js"><link rel="modulepreload" href="/assets/spring.html-C6yx7OA2.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="/logo.png" alt><!----><span class="vp-site-name hide-in-pad">JavaGuide</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/interview/java/javabasics.html" aria-label="面试指南"><span class="font-icon icon iconfont icon-java" style=""></span>面试指南<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/backend/java/java.html" aria-label="后端"><span class="font-icon icon iconfont icon-java" style=""></span>后端<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/frontend/html.html" aria-label="前端"><span class="font-icon icon iconfont icon-book" style=""></span>前端<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/open-source-project/" aria-label="开源项目"><span class="font-icon icon iconfont icon-github" style=""></span>开源项目<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/books/" aria-label="技术书籍"><span class="font-icon icon iconfont icon-book" style=""></span>技术书籍<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/high-quality-technical-articles/" aria-label="程序人生"><span class="font-icon icon iconfont icon-article" style=""></span>程序人生<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="知识星球"><span class="title"><span class="font-icon icon iconfont icon-planet" style=""></span>知识星球</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/about-the-author/zhishixingqiu-two-years.html" aria-label="星球介绍"><span class="font-icon icon iconfont icon-about" style=""></span>星球介绍<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/zhuanlan/" aria-label="星球专属优质专栏"><span class="font-icon icon iconfont icon-about" style=""></span>星球专属优质专栏<!----></a></li><li class="dropdown-item"><a href="https://www.yuque.com/snailclimb/rpkqw1/ncxpnfmlng08wlf1" rel="noopener noreferrer" target="_blank" aria-label="星球优质主题汇总" class="nav-link"><span class="font-icon icon iconfont icon-star" style=""></span>星球优质主题汇总<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="网站相关"><span class="title"><span class="font-icon icon iconfont icon-about" style=""></span>网站相关</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/about-the-author/" aria-label="关于作者"><span class="font-icon icon iconfont icon-zuozhe" style=""></span>关于作者<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/timeline/" aria-label="更新历史"><span class="font-icon icon iconfont icon-history" style=""></span>更新历史<!----></a></li></ul></button></div></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/HeChuangJun/notes" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-interview" style=""></span><span class="vp-sidebar-title">概述</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-java" style=""></span><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-component" style=""></span><span class="vp-sidebar-title">常用框架</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-computer" style=""></span><span class="vp-sidebar-title">计算机基础</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-database" style=""></span><span class="vp-sidebar-title">数据库</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-distributed-network" style=""></span><span class="vp-sidebar-title">分布式</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-design" style=""></span><span class="vp-sidebar-title">场景设计</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-fuzaijunheng" style=""></span><span class="vp-sidebar-title">问题排查</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-MQ" style=""></span><span class="vp-sidebar-title">消息队列</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-computer" style=""></span><span class="vp-sidebar-title">数据结构</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-computer" style=""></span><span class="vp-sidebar-title">算法</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->spring</h1><div class="page-info"><span class="page-author-info" aria-label="作者"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://javaguide.cn/article/" target="_blank" rel="noopener noreferrer">HeChuangJun</a></span><span property="author" content="HeChuangJun"></span></span><!----><!----><!----><span class="page-word-info" aria-label="字数"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 6741 字</span><meta property="wordCount" content="6741"></span><span class="page-reading-time-info" aria-label="阅读时间"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 22 分钟</span><meta property="timeRequired" content="PT22M"></span></div><hr></div><!----><!--[--><!----><!--]--><div class="theme-hope-content"><h1 id="_1-spring是什么-特性" tabindex="-1"><a class="header-anchor" href="#_1-spring是什么-特性"><span>1. Spring是什么？特性？</span></a></h1><ul><li>Spring是一个轻量级、非入侵式的控制反转(IoC)和面向切面(AOP)的框架。</li><li>IoC和DI的支持:管理对象生命周期和依赖关系</li><li>AOP编程的支持：面向切面编程可以实现对程序进行权限拦截、运行监控等切面功能。</li><li>声明式事务的支持：支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式。</li><li>快捷测试的支持：支持Junit注解测试Spring程序。</li><li>快速集成功能：方便集成各种优秀框架</li><li>复杂API模板封装：对JDBC、JavaMail等提供了模板化的封装，降低应用难度</li></ul><h1 id="_2-spring有哪些模块" tabindex="-1"><a class="header-anchor" href="#_2-spring有哪些模块"><span>2. Spring有哪些模块？</span></a></h1><ul><li>Spring Core：Spring 核心，它是框架最基础的部分，提供 IoC 和依赖注入 DI 特性。</li><li>Spring Context：Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。</li><li>Spring Web：它提供 Web 应用开发的支持。</li><li>Spring MVC：它针对 Web 应用中 MVC 思想的实现。</li><li>Spring DAO：提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。</li><li>Spring ORM：它支持用于流行的 ORM 框架的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等</li><li>Spring AOP：即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。</li></ul><h1 id="_3-spring常用注解" tabindex="-1"><a class="header-anchor" href="#_3-spring常用注解"><span>3. Spring常用注解？</span></a></h1><ul><li>Web: <ul><li>@Controller：组合注解（组合了@Component注解），应用在MVC层（控制层）。</li><li>@RestController：@Controller和@ResponseBody的组合注解，注解在类上则该Controller的所有方法都默认加上了@ResponseBody。</li><li>@RequestMapping：用于映射Web请求，包括访问路径和参数。Restful接口根据请求类型使用不同的注解：@GetMapping、@PostMapping、@PutMapping、@DeleteMapping</li><li>@ResponseBody：将返回值放在response内，通常返回json数据。</li><li>@RequestBody：将request的参数放在request体中</li><li>@PathVariable：用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</li></ul></li><li>容器: <ul><li>@Component：将类变为Spring管理的Bean。</li><li>@Service：组合注解（组合了@Component注解），应用在service层（业务逻辑层）。</li><li>@Repository：组合注解（组合了@Component注解），应用在dao层（数据访问层）。</li><li>@Autowired：Spring提供的工具（由Spring的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。</li><li>@Qualifier：用于区分两个以上相同类型的Bean</li><li>@Configuration：声明当前类是一个配置类（相当于一个Spring配置的xml文件）</li><li>@Value：可用在字段，构造器参数跟方法参数指定默认值，支持#{}跟${}方式。一般将SpringbBoot中的application.properties配置的属性值赋值给变量。</li><li>@Bean：注解在方法上，声明当前方法的返回值为一个Bean。返回的Bean对应的类中可以定义init()方法和destroy()方法，然后在@Bean(initMethod=”init”,destroyMethod=”destroy”)定义，在构造之后执行init，在销毁之前执行destroy。</li><li>@Scope:定义采用什么模式创建Bean（方法上，得有@Bean）包括：Singleton、Prototype、Request、Session、GlobalSession。</li></ul></li><li>AOP: <ul><li>@Aspect:声明一个切面（类上）使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。 <ul><li>@After：在方法执行之后执行（方法上）。</li><li>@Before：在方法执行之前执行（方法上）。</li><li>@Around：在方法执行之前与之后执行（方法上）。</li><li>@PointCut：声明切点在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）。</li></ul></li></ul></li><li>事务：@Transactional：在要开启事务的方法上使用，即可声明式开启事务。</li></ul><h1 id="_5-spring中都用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_5-spring中都用到了哪些设计模式"><span>5. Spring中都用到了哪些设计模式？</span></a></h1><ul><li>工厂模式—使用工厂模式通过BeanFactory、ApplicationContext创建bean对象。</li><li>代理模式—SpringAOP功能功能就是通过代理模式来实现的，分为动态代理和静态代理。</li><li>单例模式—Spring中定义的Bean默认为单例模式。</li><li>模板方法—解决代码重复的问题。比如RestTemplate、JmsTemplate、JdbcTemplate。</li><li>观察者模式:Spring事件驱动模型就是观察者模式很经典的一个应用。</li><li>适配器模式:SpringAOP的增强或通知(Advice)使用到了适配器模式、SpringMVC中也是用到了适配器模式适配Controller。</li><li>策略模式：Spring中有一个Resource接口，它的不同实现类，会根据不同的策略去访问资源。</li><li>前端控制器—Spring提供了DispatcherServlet来对请求进行分发。</li><li>视图帮助(ViewHelper)—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li><li>依赖注入—贯穿于BeanFactory/ApplicationContext接口的核心理念。</li></ul><h1 id="_12-什么是ioc控制反转-好处" tabindex="-1"><a class="header-anchor" href="#_12-什么是ioc控制反转-好处"><span>12. 什么是ioc控制反转?好处？</span></a></h1><ul><li>Inverse Of Control反转控制：将对象的生命周期交给spring容器管理</li><li>它将最小化应用程序中的代码量</li><li>它以最小的影响和最少的侵入机制促进松耦合</li><li>支持即时的实例化和延迟加载Bean对象</li><li>易于测试，因为不需要单元测试用例中的任何单例或JNDI查找机制。</li></ul><h1 id="_16-spring的di" tabindex="-1"><a class="header-anchor" href="#_16-spring的di"><span>16. spring的di</span></a></h1><ul><li>dependency Injection依赖注入,是ioc的实现方式 <ul><li>注入方式：set/属性方法注入、构造方法注入、字段注入</li><li>注入类型：值类型注入（8大基本数据类型）、引用类型注入 将依赖对象注入</li></ul></li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>set方法注入
&lt;bean  name=&quot;user&quot; class=&quot;cn.itcast.bean.User&quot; &gt;
	&lt;!--值类型注入: 为User对象中名为name的属性注入tom作为值 --&gt;
	&lt;property name=&quot;name&quot; value=&quot;tom&quot; &gt;&lt;/property&gt;
	&lt;!-- 引用类型注入: 为car属性注入下方配置的car对象 --&gt;
	&lt;property name=&quot;car&quot;  ref=&quot;car&quot; &gt;&lt;/property&gt;
	&lt;!--数组类型注入: 如果数组中只准备类一个值（对象），直接使用value|ref--&gt;
	&lt;property name=&quot;arr&quot; value=&quot;tom&quot;&gt;&lt;/property&gt;
	&lt;property name=&quot;arr&quot;&gt;
		&lt;array&gt;
			&lt;value&gt;tom&lt;/value&gt;
			&lt;ref bean=&quot;user&quot;/&gt;
		&lt;array&gt;
	&lt;/property&gt;
	&lt;!-- List类型注入：如果list中只准备类一个值（对象），直接使用value|ref--&gt;
	&lt;property name=&quot;list&quot; value=&quot;jack&quot;&gt;&lt;/property&gt;
	&lt;property name=&quot;list&quot;&gt;
		&lt;list&gt;
			&lt;value&gt;jack&lt;/value&gt;
			&lt;ref bean=&quot;user&quot;/&gt;
		&lt;list&gt;
	&lt;/property&gt;
	&lt;!-- Properties类型注入 --&gt;
	&lt;property name=&quot;prop&quot;&gt;
		&lt;props&gt;
			&lt;prop key=&quot;driverClass&quot;&gt;com.jdbc.mysql.Driver&lt;/prop&gt;
		&lt;props&gt;
	&lt;/property&gt;
	&lt;!-- Map类型注入 --&gt;
	&lt;property name=&quot;map&quot;&gt;
		&lt;map&gt;
			&lt;entry key=&quot;url&quot; value=&quot;jdbc:mysql:///crm&quot;&gt;&lt;/entry&gt;
		&lt;map&gt;
	&lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 将car对象配置到容器中 --&gt;
&lt;bean name=&quot;car&quot; class=&quot;cn.itcast.bean.Car&quot; &gt;
	&lt;property name=&quot;name&quot; value=&quot;兰博基尼&quot; &gt;&lt;/property&gt;
&lt;/bean&gt;


构造函数注入
&lt;bean name=&quot;user2&quot; class=&quot;cn.itcast.bean.User&quot; &gt;
	&lt;!-- name属性: 构造函数的参数名  index属性: 
	构造函数的参数索引 type属性: 构造函数的参数类型--&gt;
	&lt;constructor-arg name=&quot;name&quot; index=&quot;0&quot; type=&quot;java.lang.Integer&quot; value=&quot;999&quot;&gt;&lt;/constructor-arg&gt;
	&lt;constructor-arg name=&quot;car&quot; index=&quot;1&quot; ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_14-简述spring-ioc的实现机制" tabindex="-1"><a class="header-anchor" href="#_14-简述spring-ioc的实现机制"><span>14. 简述Spring IoC的实现机制？</span></a></h1><ul><li>原理：工厂模式加反射机制</li><li>a. 加载配置文件，解析成BeanDefinition放在Map里</li><li>b. BeanFactory调用getBean的时候，从BeanDefinition所属的Map里，拿出Class对象进行实例化，如果有依赖关系，将递归调用getBean方法 —— 完成依赖注入。</li></ul><h1 id="_13-说说applicationcontext-beanfactory" tabindex="-1"><a class="header-anchor" href="#_13-说说applicationcontext-beanfactory"><span>13. 说说applicationContext&amp;BeanFactory</span></a></h1><ul><li>BeanFactory接口：创建并管理各种类的对象。每次在获得对象时才会创建对象.最常用的是XmlBeanFactory，根据XML文件中内容创建相应Bean</li><li>ApplicationContext建立在BeanFactoty基础上。每次容器启动时就会创建容器中配置的所有对象.并提供更多功能 <ul><li>1、ClassPathXmlApplicationContext ：从 ClassPath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</li><li>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文</li><li>3、XmlWebApplicationContext ：由Web应用的XML文件读取上下文。在 Spring MVC 使用</li><li>4、Spring Boot 的ConfigServletWebServerApplicationContext</li></ul></li></ul><h1 id="_17-spring容器启动阶段会干什么" tabindex="-1"><a class="header-anchor" href="#_17-spring容器启动阶段会干什么"><span>17. Spring容器启动阶段会干什么？</span></a></h1><ul><li>IoC容器工作的过程可以划分两个阶段</li><li>容器启动阶段：加载配置，分析配置信息，装配到BeanDefinition，其他后处理</li><li>Bean实例化阶段：实例化对象，装配依赖， 生命周期回调， 对象其他处理， 注册回调接口</li></ul><h1 id="_18-spring-bean在容器的生命周期是什么样的" tabindex="-1"><a class="header-anchor" href="#_18-spring-bean在容器的生命周期是什么样的"><span>18. Spring Bean在容器的生命周期是什么样的？</span></a></h1><ul><li>实例化Bean对象: <ul><li>根据配置中Bean Definition中实例化Bean对象（通过XML，Java注解或Java Config代码提供）</li></ul></li><li>属性赋值：Aware相关的属性，注入到Bean对象 <ul><li>如果Bean实现BeanNameAware接口，则工厂通过传递Bean的beanName调用setBeanName(String name)方法</li><li>如果Bean实现BeanFactoryAware接口，工厂通过传递自身的实例来调用setBeanFactory(BeanFactory beanFactory)方法</li></ul></li><li>初始化 <ul><li>@PostConstruct</li><li>如果存在与Bean关联的任何BeanPostProcessor，则调用#preProcessBeforeInitialization(Object bean, String beanName) 方法。</li><li>如果Bean实现InitializingBean接口，则会调用#afterPropertiesSet() 方法。</li><li>如果Bean指定init方法（例如 <!----> 的 init-method 属性），那么将调用该方法。</li><li>如果存在与Bean关联的任何 BeanPostProcessor，则调用#postProcessAfterInitialization(Object bean, String beanName) 方法。</li></ul></li><li>销毁： <ul><li>@PreDestroy</li><li>如果Bean实现DisposableBean接口，当 spring 容器关闭时，会调用 #destroy() 方法。</li><li>如果bean指定destroy方法（例如 <!----> 的 destroy-method 属性），那么将调用该方法。<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/9d7d1e010e6a298683def.jpg" alt="beanlife.png"></li></ul></li></ul><h1 id="_15-spring有哪些自动装配的方式" tabindex="-1"><a class="header-anchor" href="#_15-spring有哪些自动装配的方式"><span>15. Spring有哪些自动装配的方式?</span></a></h1><ul><li>byName根据名称进行自动匹配</li><li>byType根据类型进行自动匹配</li><li>constructor spring根据bean构造函数入参类型自动装配</li><li>autodetect 如果Bean提供了默认的构造函数，则采用byType，否则采用constructor。</li></ul><h1 id="_4-spring中的bean作用域scope类型√" tabindex="-1"><a class="header-anchor" href="#_4-spring中的bean作用域scope类型√"><span>4. spring中的bean作用域scope类型√</span></a></h1><ul><li>singleton(默认):被标识为单例的对象，在spring容器中只存在一个实例</li><li>prototype:被标识为多例的对象,每次获取都会创建新对象</li><li>request:web环境下.对象与request生命周期一致.</li><li>session:web环境下,对象与session生命周期一致.</li><li>Application:对象与Web Application生命周期一致，只能在同一个webapplication中获取</li></ul><h1 id="_8-spring框架中的单例bean是线程安全的吗-√" tabindex="-1"><a class="header-anchor" href="#_8-spring框架中的单例bean是线程安全的吗-√"><span>8. spring框架中的单例bean是线程安全的吗？√</span></a></h1><ul><li>如果单例Bean是无状态的，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。</li><li>如果bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。解决办法就是将多态bean的作用域由“singleton”变更为“prototype”或者将变量放入ThreadLocal中</li></ul><h1 id="_6-如何解决spring-bean中的循环依赖-√为何使用三级缓存解决循环依赖而不是二级缓存" tabindex="-1"><a class="header-anchor" href="#_6-如何解决spring-bean中的循环依赖-√为何使用三级缓存解决循环依赖而不是二级缓存"><span>6. 如何解决spring bean中的循环依赖？√为何使用三级缓存解决循环依赖而不是二级缓存?</span></a></h1><ul><li>单例模式下Spring可以解决哪些情况的循环依赖 <ul><li>多例模式不支持，无限创建对象</li><li>AB均采用构造器注入，不支持。直接抛出BeanCurrentlylnCreationException异常。</li><li>AB均采用setter注入，支持</li><li>AB均采用属性自动注入，支持</li><li>A中注入的B为setter注入，B中注入的A为构造器注入，支持</li><li>B中注入的A为setter注入，A中注入的B为构造器注入，不支持</li><li>第四种可以，第五种不可以的原因是Spring在创建Bean时默认会根据自然排序进行创建，所以A会先于B进行创建。</li></ul></li><li>spring通过三级缓存解决循环依赖， <ul><li>singletonObjects 一级缓存。保存实例化、属性赋值、初始化完成的bean实例</li><li>earlySingletonObjects 二级缓存 。保存实例化完成的bean实例</li><li>singletonFactories 三级缓存，用于保存bean创建工厂，以便后面有机会创建代理对象</li></ul></li><li>实例化过程 <ul><li>A实例化并把A的ObjectFactory加入第三级缓存 <ul><li>A填充属性需要注入B -&gt; B实例化并把B的ObjectFactory加入第三级缓存</li><li>B填充属性需要注入A -&gt; 从第三级缓存移除A对象，A代理对象加入第二级缓存（此时A还是半成品，B注入的是A代理对象）</li><li>B属性注入完成，创建B代理对象（此时B是完成品） -&gt; 从第三级缓存移除B对象，B代理对象加入第一级缓存</li><li>A填充属性注入B代理对象，从第二级缓存移除A代理对象，A代理对象加入第一级缓存</li></ul></li></ul></li><li>如果没有AOP的话确实可以两级缓存就可以解决循环依赖的问题，如果加上AOP，两级缓存是无法解决的，不可能每次执行singleFactory.getObject()方法都给我产生一个新的代理对象，所以还要借助另外一个缓存来保存产生的代理对象</li></ul><h1 id="_7-autowired-的实现原理" tabindex="-1"><a class="header-anchor" href="#_7-autowired-的实现原理"><span>7. @Autowired 的实现原理？</span></a></h1><ul><li>在Bean的初始化阶段，会通过Bean后置处理器来进行前置和后置的处理。@Autowired功能是通过后置处理器<br> AutowiredAnnotationBeanPostProcessor来完成的</li><li>Spring在创建bean的过程中，最终会调用到doCreateBean()方法，在doCreateBean()方法中会调用populateBean()方法，来为bean进行属性填充，完成自动装配等工作。</li><li>在populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行第二次后置处理器的调用，这个时候，就会调用到AutowiredAnnotationBeanPostProcessor的postProcessPropertyValues()方法，在该方法中就会进行@Autowired注解的解析，然后实现自动装配</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>//属性赋值
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
          //…………
          if (hasInstAwareBpps) {
              if (pvs == null) {
                  pvs = mbd.getPropertyValues();
              }

              PropertyValues pvsToUse;
              for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
                  InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
                  pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
                  if (pvsToUse == null) {
                      if (filteredPds == null) {
                          filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
                      }
                      //执行后处理器，填充属性，完成自动装配
                      //调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法
                      pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
                      if (pvsToUse == null) {
                          return;
                      }
                  }
              }
          }
         //…………
  }

//先调用 findAutowiringMetadata()方法解析出 bean 中带有@Autowired 注解、@Inject 和@Value 注解的属性和方法。然后调用 metadata.inject()方法，进行属性填充。
  public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
      //@Autowired注解、@Inject和@Value注解的属性和方法
      InjectionMetadata metadata = this.findAutowiringMetadata(beanName, bean.getClass(), pvs);

      try {
          //属性填充
          metadata.inject(bean, beanName, pvs);
          return pvs;
      } catch (BeanCreationException var6) {
          throw var6;
      } catch (Throwable var7) {
          throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, var7);
      }
  }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_19-spring的aop以及实现方式-通知类型" tabindex="-1"><a class="header-anchor" href="#_19-spring的aop以及实现方式-通知类型"><span>19. spring的AOP以及实现方式,通知类型</span></a></h1><ul><li>AOP(Aspect-Oriented Programming)，面向切面编程:通过动态代理将通知织入目标对象.把一些业务逻辑中的相同代码抽取到一个独立的模块中，提高代码的可重用性。</li><li>实现方式 <ul><li>动态代理(优先):基于接口，被代理对象必须要实现接口,才能产生代理对象.</li><li>cglib代理：基于继承，对目标对象进行继承代理.目标对象不被final修饰。通过ASM读取目标类的字节码，然后修改字节码生成新的类</li></ul></li><li>应用：用于增强方法，权限认证、日志、事务、参数校验</li><li>常用术语 <ul><li>Joinpoint(连接点)：目标对象中，被拦截到的方法</li><li>Poincut(切入点)：目标对象，已经增强的方法。pointcut 的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice</li><li>Advice(通知/增强)：指拦截到连接点之后要执行的增强代码 <ul><li>前置通知（Before advice）：在某连接点（JoinPoint）之前执行的通知，但这个通知不能阻止连接点前的执行。ApplicationContext 中在 &lt; aop:aspect &gt; 里面使用 &lt; aop:before &gt; 元素进行声明；</li><li>后置通知（After advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。ApplicationContext 中在 &lt; aop:aspect &gt; 里面使用 &lt; aop:after &gt; 元素进行声明。</li><li>返回后通知（After return advice ：在某连接点正常完成后执行的通知，不包括抛出异常的情况。ApplicationContext 中在 &lt; aop:aspect &gt; 里面使用 &lt;&lt; after-returning &gt;&gt; 元素进行声明。</li><li>环绕通知（Around advice）：在 join point 前和 joint point 退出后都执行的 advice。ApplicationContext 中在 &lt; aop:aspect &gt; 里面使用 &lt; aop:around &gt; 元素进行声明。</li><li>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。ApplicationContext 中在 &lt; aop:aspect &gt; 里面使用 &lt; aop:after-throwing &gt; 元素进行声明。</li></ul></li><li>Target(目标对象)：被代理的对象</li><li>Weaving(织入)：将 aspect 和其他对象连接起来, 并创建 adviced object 的过程.</li><li>Proxy(代理)：将通知织入到目标对象之后，形成代理对象 Advice + Target Object = Advised Object = Proxy 。</li><li>aspect(切面)：切入点+通知 可以简单地认为, 使用 @Aspect 注解的类就是切面。</li></ul></li></ul><h1 id="_22-spring事务配置-处理方式" tabindex="-1"><a class="header-anchor" href="#_22-spring事务配置-处理方式"><span>22. spring事务配置，处理方式？</span></a></h1><ul><li>声明式事务：基于AOP，通过使用注解@Transactional或基于XML的配置事务，从而事务管理与业务代码分离。但无法用到代码块级别</li><li>编程式事务：通过TransactionTemplate和PlatformTransactionManager编码的方式实现事务管理，需要在代码中显式的调用事务的获得、提交、回滚。灵活性高，但维护困难</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public class AccountService {
    private TransactionTemplate transactionTemplate;

    public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
        this.transactionTemplate = transactionTemplate;
    }

    public void transfer(final String out, final String in, final Double money) {
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                // 转出
                accountDao.outMoney(out, money);
                // 转入
                accountDao.inMoney(in, money);
            }
        });
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_24-spring-的事务隔离级别" tabindex="-1"><a class="header-anchor" href="#_24-spring-的事务隔离级别"><span>24. Spring 的事务隔离级别？</span></a></h1><ul><li>Spring的接口TransactionDefinition中定义了表示隔离级别的常量，当然其实主要还是对应数据库的事务隔离级别：</li><li>ISOLATION_DEFAULT：使用后端数据库默认的隔离界别，MySQL 默认可重复读，Oracle 默认读已提交。</li><li>ISOLATION_READ_UNCOMMITTED：读未提交</li><li>ISOLATION_READ_COMMITTED：读已提交</li><li>ISOLATION_REPEATABLE_READ：可重复读</li><li>ISOLATION_SERIALIZABLE：串行化</li></ul><h1 id="_27-事务传播行为-有什么用-√" tabindex="-1"><a class="header-anchor" href="#_27-事务传播行为-有什么用-√"><span>27. 事务传播行为？有什么用？√</span></a></h1><ul><li>事务的传播行为propagation（service方法调用另外一个service方法的时候，仅限于不同类方法间相互调用）</li><li>事务的传播机制是指在一个事务中，对于多个事务性操作之间的关系和协调的处理方式。它决定了在一个事务方法中调用其他事务方法时，事务的范围和属性等。</li><li>支持当前事务 <ul><li>PROPAGATION_REQUIRED如果当前存在事务，则使用该事务。如果当前没有事务，就新建一个(默认)！！！</li><li>PROPAGATION_SUPPORTS如果当前存在事务，则使用该事务。如果当前没有事务，就不使用事务</li><li>PROPAGATION_MANDATORY如果当前存在事务，则使用该事务。如果当前没有事务，抛出异常</li></ul></li><li>不支持当前事务的情况 <ul><li>PROPAGATION_REQUIRES_NEW创建一个新的事务，如果有事务存在，挂起当前事务，</li><li>PROPAGATION_NOT_SUPPORTED以非事务方式运行，如果有事务存在，挂起当前事务</li><li>PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常</li><li>PROPAGATION_NESTED如果当前事务存在，则创建一个事务作为当前事务的嵌套事务来运行，如果当前没有事务，则等价PROPAGATION_REQUIRED</li><li>以 PROPAGATION_NESTED 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</li></ul></li><li>事务传播机制是使用 ThreadLocal 实现的，所以，如果调用的方法是在新线程中的，事务传播会失效。</li><li>在 Spring 中，只有通过 Spring 容器的 AOP 代理调用的公开方法（public method）上的@Transactional注解才会生效。Spring 默认使用基于 JDK 的动态代理（当接口存在时）或基于 CGLIB 的代理（当只有类时）来实现事务。这两种代理机制都只能代理公开的方法。</li></ul><h1 id="_28-声明式事务实现原理了解吗" tabindex="-1"><a class="header-anchor" href="#_28-声明式事务实现原理了解吗"><span>28. 声明式事务实现原理了解吗？</span></a></h1><ul><li>Spring的声明式事务管理是通过AOP（面向切面编程）和代理机制实现的。</li><li>第一步，在Bean初始化阶段创建代理对象： <ul><li>Spring容器在初始化单例Bean的时候，会遍历所有的BeanPostProcessor实现类，并执行其postProcessAfterInitialization方法。</li><li>在执行postProcessAfterInitialization方法时会遍历容器中所有的切面，查找与当前Bean匹配的切面，这里会获取事务的属性切面，也就是@Transactional注解及其属性值。</li><li>然后根据得到的切面创建一个代理对象，默认使用JDK动态代理创建代理，如果目标类是接口，则使用JDK动态代理，否则使用Cglib。</li></ul></li><li>第二步，在执行目标方法时进行事务增强操作： <ul><li>当通过代理对象调用Bean方法的时候，会触发对应的AOP增强拦截器，声明式事务是一种环绕增强，对应接口为MethodInterceptor，事务增强对该接口的实现为TransactionInterceptor</li><li>事务拦截器TransactionInterceptor在invoke方法中，通过调用父类TransactionAspectSupport的invokeWithinTransaction方法进行事务处理，包括开启事务、事务提交、异常回滚等。</li></ul></li></ul><h1 id="_29-声明式事务在哪些情况下会失效" tabindex="-1"><a class="header-anchor" href="#_29-声明式事务在哪些情况下会失效"><span>29. 声明式事务在哪些情况下会失效？</span></a></h1><ul><li>@Transactional应用在非public修饰的方法上。因为在SpringAOP代理时，TransactionInterceptor（事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy的内部类）的intercept方法或JdkDynamicAopProxy的invoke方法会间接调用AbstractFallbackTransactionAttributeSource的computeTransactionAttribute方法，获取Transactional注解的事务配置信息。</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>protectedTransactionAttributecomputeTransactionAttribute(Methodmethod,Class&lt;?&gt;targetClass){
  //Don&#39;tallowno-publicmethodsasrequired.
  if(allowPublicMethodsOnly()&amp;&amp;!Modifier.isPublic(method.getModifiers())){
    return null;
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>@Transactional注解属性propagation设置错误 <ul><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行；错误使用场景：在业务逻辑必须运行在事务环境下以确保数据一致性的情况下使用SUPPORTS。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：总是以非事务方式执行，如果当前存在事务，则挂起该事务。错误使用场景：在需要事务支持的操作中使用NOT_SUPPORTED。</li><li>TransactionDefinition.PROPAGATION_NEVER：总是以非事务方式执行，如果当前存在事务，则抛出异常。错误使用场景：在应该在事务环境下执行的操作中使用NEVER。</li></ul></li><li>@Transactional注解属性rollbackFor设置错误 <ul><li>rollbackFor用来指定能够触发事务回滚的异常类型。Spring默认抛出未检查unchecked异常（继承自RuntimeException的异常）或者Error才回滚事务，其他异常不会触发回滚事务。</li></ul></li><li>同一个类中方法调用，导致@Transactional失效 <ul><li>由SpringAOP代理造成的，因为只有事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。</li></ul></li></ul><h1 id="_9-spring注册bean的几种方式" tabindex="-1"><a class="header-anchor" href="#_9-spring注册bean的几种方式"><span>9. spring注册bean的几种方式</span></a></h1><ul><li>直接编码</li><li>配置文件 xml的bean标签</li><li>注解 <ul><li>@Component、@Service、@Controller</li><li>@Bean</li></ul></li><li>java config</li></ul><h1 id="_10-spring中的-required、-autowired、-qualifier注解的作用" tabindex="-1"><a class="header-anchor" href="#_10-spring中的-required、-autowired、-qualifier注解的作用"><span>10. spring中的@Required、@Autowired、@Qualifier注解的作用？</span></a></h1><ul><li>@Required注解，应用于Bean属性setter方法。表示属性必须注入否则抛出 BeanInitializationException 异常。</li><li>@Autowired用于在setter方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 Bean</li><li>@Qualifier指定id自动装配哪个bean</li></ul><h1 id="_11-解释什么叫延迟加载" tabindex="-1"><a class="header-anchor" href="#_11-解释什么叫延迟加载"><span>11. 解释什么叫延迟加载？</span></a></h1><ul><li>容器启动之后默认会创建所有作用域为单例的Bean，但是有的业务场景不需要提前创建。此时设置lazy-init=&quot;true&quot;。容器启动之后不会默认创建作用域为单例的Bean，而是在获得该Bean时才创建</li></ul><h1 id="_20-java热部署" tabindex="-1"><a class="header-anchor" href="#_20-java热部署"><span>20. java热部署</span></a></h1><ul><li>spring-boot-devtools、Spring Loaded实现原理，nio的WatchService监听文件夹变化，同时实现classLoader的findclass方法重新将class加载进内存</li></ul><h1 id="_21-spring容器创建过程" tabindex="-1"><a class="header-anchor" href="#_21-spring容器创建过程"><span>21. Spring容器创建过程</span></a></h1><p>AbstractApplicationContext调用refresh()方法通过调用obtainFreshBeanFactory()方法创建Bean工厂AnnotatedBeanDefinitionReader扫描注解doScan方法和XmlBeanDefinitionReader的doLoadBeanDefinitions方法sax方式解析xml将其封装成document对象，使用BeanDefinitionReaderUtils.registerBeanDefinition并注册到BeanDefinitionRegistry缓存中<br> 然后调用postProcessBeanFactory调用子类的BeanFactory的后置处理器，然后调用invokeBeanFactoryPostProcessors()执行后置处理器<br> 第三注册BeanPostProcessors()到BeanFactory中<br> 第四注册监听器<br> 第五实例化所有的Bean放到singletonObjects单例池里面</p><h1 id="_23-transactional-注解有哪些属性-如何使用" tabindex="-1"><a class="header-anchor" href="#_23-transactional-注解有哪些属性-如何使用"><span>23. @Transactional 注解有哪些属性？如何使用？</span></a></h1><ul><li>属性：propagation事务传播行为，isolation事务隔离级别、rollbackFor导致事务回滚的异常类数组、timeout事务超时回滚、readonly读写或只读事务</li><li>@Transactional 可用在接口、接口方法、类、类方法上。只被应用到 public 方法上，方法级别注解覆盖类级别的注解。</li></ul><h1 id="_25-spring-事务如何和不同的数据持久层框架-spring-jdbc、hibernate、spring-jpa、mybatis-做集成" tabindex="-1"><a class="header-anchor" href="#_25-spring-事务如何和不同的数据持久层框架-spring-jdbc、hibernate、spring-jpa、mybatis-做集成"><span>25. Spring 事务如何和不同的数据持久层框架(Spring JDBC、Hibernate、Spring JPA、MyBatis)做集成？</span></a></h1><ul><li>Spring通过org.springframework.transaction.PlatformTransactionManager进行事务管理管理</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public interface PlatformTransactionManager {
  // 根据事务定义 TransactionDefinition ，获得 TransactionStatus 。 
  //为什么不是创建事务呢？因为如果当前如果已经有事务，则不会进行创建，一般来说会跟当前线程进行绑定。
  //为什么返回TransactionStatus对象？因为TransactionStatus 中包含事务属性和事务的其它信息，例如是否只读、是否为新创建的事务等等
  TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;
  //为什么根据 TransactionStatus 情况，进行提交？例如说，带@Transactional注解的A方法，会调用 @Transactional 注解的B方法
  //在B方法结束调用后，会执行PlatformTransactionManager#commit(TransactionStatus status) 方法，此处事务是不能、也不会提交的
  //而是在A方法结束调用后，执行PlatformTransactionManager#commit(TransactionStatus status) 方法，提交事务
  void commit(TransactionStatus status) throws TransactionException;
  // 为什么根据 TransactionStatus 情况，进行回滚？原因同上
  void rollback(TransactionStatus status) throws TransactionException;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>不同的数据持久层框架，会有其对应的PlatformTransactionManager实现类，都基于AbstractPlatformTransactionManager这个骨架类。 <ul><li>HibernateTransactionManager，和Hibernate5事务管理做集成。</li><li>DataSourceTransactionManager，和JDBC事务管理做集成。也适用于MyBatis、Spring JDBC等等</li><li>JpaTransactionManager，和JPA事务管理做集成。</li></ul></li></ul><h1 id="_26-为什么在spring事务中不能切换数据源" tabindex="-1"><a class="header-anchor" href="#_26-为什么在spring事务中不能切换数据源"><span>26. 为什么在Spring事务中不能切换数据源？</span></a></h1><ul><li>在Spring的事务管理中，数据库连接会和当前线程所绑定，即使设置了另外一个数据源，使用的还是当前的数据源连接。</li><li>而且多个数据源且需要事务的场景会带来多事务一致性的问题</li><li>推荐除非了读写分离所带来的多数据源，其它情况下，建议只有一个数据源</li></ul><h1 id="_30-拦截器与过滤器区别√" tabindex="-1"><a class="header-anchor" href="#_30-拦截器与过滤器区别√"><span>30. 拦截器与过滤器区别√</span></a></h1><ul><li>拦截器是基于java的反射机制的，而过滤器是基于函数回调。</li><li>拦截器不依赖与servlet容器，过滤器依赖servlet容器。</li><li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li><li>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</li><li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</li><li>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</li></ul><h1 id="_31-spring区分环境" tabindex="-1"><a class="header-anchor" href="#_31-spring区分环境"><span>31. spring区分环境</span></a></h1><ul><li>spring.profiles.active=dev----application-dev.properties</li></ul></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/HeChuangJun/notes/edit/main/docs/interview/spring.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 1105128664@qq.com">HeChuangJun</span><!--]--><!--]--></div></div></footer><!----><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer"><a href="https://beian.miit.gov.cn/" target="_blank">鄂ICP备2020015769号-1</a></div><div class="vp-copyright">Copyright © 2025 HeChuangJun </div></footer></div><!--]--><!--]--><!--[--><!--[--><!--]--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-7KT7HDzT.js" defer></script>
  </body>
</html>
