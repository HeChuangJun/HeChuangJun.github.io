<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.9" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.32" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://javaguide.cn/interview/framework/springcloud.html"><meta property="og:site_name" content="JavaGuide"><meta property="og:title" content="Spring Cloud"><meta property="og:description" content="微服务概念？组件？Spring Cloud组件？√ 优缺点？流行的微服务解决方案及区别？ 微服务（Microservices）是一种软件架构风格，将一个大型应用程序划分为一组小型、自治且松耦合的服务。每个微服务负责执行特定的业务功能，并通过轻量级通信机制（如HTTP）相互协作。每个微服务可以独立开发、部署和扩展，使得应用程序更加灵活、可伸缩和可维护。 ..."><meta property="og:type" content="article"><meta property="og:image" content="https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQ70a7c92f073b2623dc4a104375c35b6a.png"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="HeChuangJun"><meta property="article:published_time" content="2023-01-01T00:00:00.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"Spring Cloud","image":["https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQ70a7c92f073b2623dc4a104375c35b6a.png","https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQ9b2b80e9526f5b4e11f3d33b3d0410cd.png","https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQ6bc9de47c7d69a3c14ef91758ec95a19.png","https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQb667e7307d4531649961085458871b44.png","https://290ff162.telegraph-image-eg9.pages.dev/file/62d5d0137dc8127da398a.jpg","https://290ff162.telegraph-image-eg9.pages.dev/file/7aa4fa0667258f4190419.jpg","https://290ff162.telegraph-image-eg9.pages.dev/file/c5e5a6603d8d79d4509d3.jpg","https://290ff162.telegraph-image-eg9.pages.dev/file/eff7e956169c3396d6691.png","https://290ff162.telegraph-image-eg9.pages.dev/file/bc82ce3be04420eac161e.jpg","https://290ff162.telegraph-image-eg9.pages.dev/file/e0a2b3f17439791ef0e97.png","https://290ff162.telegraph-image-eg9.pages.dev/file/f1c2597a611a4bcf6a468.png","https://290ff162.telegraph-image-eg9.pages.dev/file/e3a492135cfb1b9a68369.png","https://290ff162.telegraph-image-eg9.pages.dev/file/264d940d050468301c1fa.png","https://290ff162.telegraph-image-eg9.pages.dev/file/dbae39b1c21075990c42e.png","https://290ff162.telegraph-image-eg9.pages.dev/file/0456accaa69ce5192fac9.png","https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQe85d4b33946c0c9e11eb23fbf057d877.png","https://290ff162.telegraph-image-eg9.pages.dev/file/3f959676d10750e5c8902.png"],"datePublished":"2023-01-01T00:00:00.000Z","dateModified":null,"author":[{"@type":"Person","name":"HeChuangJun","url":"https://javaguide.cn/article/"}]}</script><meta name="robots" content="all"><meta name="author" content="Guide"><meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"><meta http-equiv="Pragma" content="no-cache"><meta http-equiv="Expires" content="0"><meta name="keywords" content="Java基础, 多线程, JVM, 虚拟机, 数据库, MySQL, Spring, Redis, MyBatis, 系统设计, 分布式, RPC, 高可用, 高并发"><meta name="description" content="「Java学习 + 面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，首选 JavaGuide！"><meta name="apple-mobile-web-app-capable" content="yes"><script>var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?5dd2e8c97962d57b7b8fea1737c01743";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();</script><link rel="alternate" type="application/atom+xml" href="https://javaguide.cn/atom.xml" title="JavaGuide Atom Feed"><link rel="alternate" type="application/json" href="https://javaguide.cn/feed.json" title="JavaGuide JSON Feed"><link rel="alternate" type="application/rss+xml" href="https://javaguide.cn/rss.xml" title="JavaGuide RSS Feed"><link rel="icon" href="/favicon.ico"><title>Spring Cloud | JavaGuide</title>
    <link rel="preload" href="/assets/style-B7LVZfe6.css" as="style"><link rel="stylesheet" href="/assets/style-B7LVZfe6.css">
    <link rel="modulepreload" href="/assets/app-7KT7HDzT.js"><link rel="modulepreload" href="/assets/springcloud.html-DkIuEbRi.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="/logo.png" alt><!----><span class="vp-site-name hide-in-pad">JavaGuide</span></a><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-center"><!--[--><!----><!--]--><!--[--><nav class="vp-nav-links"><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/interview/java/javabasics.html" aria-label="面试指南"><span class="font-icon icon iconfont icon-java" style=""></span>面试指南<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/backend/java/java.html" aria-label="后端"><span class="font-icon icon iconfont icon-java" style=""></span>后端<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/frontend/html.html" aria-label="前端"><span class="font-icon icon iconfont icon-book" style=""></span>前端<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/open-source-project/" aria-label="开源项目"><span class="font-icon icon iconfont icon-github" style=""></span>开源项目<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/books/" aria-label="技术书籍"><span class="font-icon icon iconfont icon-book" style=""></span>技术书籍<!----></a></div><div class="nav-item hide-in-mobile"><a class="route-link nav-link" href="/high-quality-technical-articles/" aria-label="程序人生"><span class="font-icon icon iconfont icon-article" style=""></span>程序人生<!----></a></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="知识星球"><span class="title"><span class="font-icon icon iconfont icon-planet" style=""></span>知识星球</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/about-the-author/zhishixingqiu-two-years.html" aria-label="星球介绍"><span class="font-icon icon iconfont icon-about" style=""></span>星球介绍<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/zhuanlan/" aria-label="星球专属优质专栏"><span class="font-icon icon iconfont icon-about" style=""></span>星球专属优质专栏<!----></a></li><li class="dropdown-item"><a href="https://www.yuque.com/snailclimb/rpkqw1/ncxpnfmlng08wlf1" rel="noopener noreferrer" target="_blank" aria-label="星球优质主题汇总" class="nav-link"><span class="font-icon icon iconfont icon-star" style=""></span>星球优质主题汇总<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button type="button" class="dropdown-title" aria-label="网站相关"><span class="title"><span class="font-icon icon iconfont icon-about" style=""></span>网站相关</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a class="route-link nav-link" href="/about-the-author/" aria-label="关于作者"><span class="font-icon icon iconfont icon-zuozhe" style=""></span>关于作者<!----></a></li><li class="dropdown-item"><a class="route-link nav-link" href="/timeline/" aria-label="更新历史"><span class="font-icon icon iconfont icon-history" style=""></span>更新历史<!----></a></li></ul></button></div></div></nav><!--]--><!--[--><!----><!--]--></div><div class="vp-navbar-end"><!--[--><!----><!--]--><!--[--><!----><div class="nav-item vp-repo"><a class="vp-repo-link" href="https://github.com/HeChuangJun/notes" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="nav-item hide-in-mobile"><button type="button" id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><!--]--><!--[--><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!--[--><!----><!--]--><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-interview" style=""></span><span class="vp-sidebar-title">概述</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-java" style=""></span><span class="vp-sidebar-title">Java</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><span class="font-icon icon iconfont icon-component" style=""></span><span class="vp-sidebar-title">常用框架</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/interview/framework/spring.html" aria-label="Spring"><span class="font-icon icon iconfont icon-bxl-spring-boot" style=""></span>Spring<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/interview/framework/springmvc.html" aria-label="Spring MVC"><span class="font-icon icon iconfont icon-bxl-spring-boot" style=""></span>Spring MVC<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/interview/framework/springboot.html" aria-label="Spring Boot"><span class="font-icon icon iconfont icon-bxl-spring-boot" style=""></span>Spring Boot<!----></a></li><li><a class="route-link nav-link active vp-sidebar-link vp-sidebar-page active" href="/interview/framework/springcloud.html" aria-label="Spring Cloud"><span class="font-icon icon iconfont icon-bxl-spring-boot" style=""></span>Spring Cloud<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/interview/framework/mybatis.html" aria-label="MyBatis"><span class="font-icon icon iconfont icon-bxl-spring-boot" style=""></span>MyBatis<!----></a></li><li><a class="route-link nav-link vp-sidebar-link vp-sidebar-page" href="/interview/framework/dubbo.html" aria-label="Dubbo"><span class="font-icon icon iconfont icon-bxl-spring-boot" style=""></span>Dubbo<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-computer" style=""></span><span class="vp-sidebar-title">计算机基础</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-database" style=""></span><span class="vp-sidebar-title">数据库</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-distributed-network" style=""></span><span class="vp-sidebar-title">分布式</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-design" style=""></span><span class="vp-sidebar-title">场景设计</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-fuzaijunheng" style=""></span><span class="vp-sidebar-title">问题排查</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-MQ" style=""></span><span class="vp-sidebar-title">消息队列</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-computer" style=""></span><span class="vp-sidebar-title">数据结构</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><span class="font-icon icon iconfont icon-computer" style=""></span><span class="vp-sidebar-title">算法</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!--[--><!----><!--]--></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!--[--><!----><!--]--><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Spring Cloud</h1><div class="page-info"><span class="page-author-info" aria-label="作者"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://javaguide.cn/article/" target="_blank" rel="noopener noreferrer">HeChuangJun</a></span><span property="author" content="HeChuangJun"></span></span><!----><!----><!----><span class="page-word-info" aria-label="字数"><svg xmlns="http://www.w3.org/2000/svg" class="icon word-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="word icon"><path d="M518.217 432.64V73.143A73.143 73.143 0 01603.43 1.097a512 512 0 01419.474 419.474 73.143 73.143 0 01-72.046 85.212H591.36a73.143 73.143 0 01-73.143-73.143z"></path><path d="M493.714 566.857h340.297a73.143 73.143 0 0173.143 85.577A457.143 457.143 0 11371.566 117.76a73.143 73.143 0 0185.577 73.143v339.383a36.571 36.571 0 0036.571 36.571z"></path></svg><span>约 15269 字</span><meta property="wordCount" content="15269"></span><span class="page-reading-time-info" aria-label="阅读时间"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 51 分钟</span><meta property="timeRequired" content="PT51M"></span></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!--[--><!----><!--]--><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#微服务概念-组件-spring-cloud组件-√-优缺点-流行的微服务解决方案及区别">微服务概念？组件？Spring Cloud组件？√ 优缺点？流行的微服务解决方案及区别？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#服务注册与发现作用-为什么要有服务注册与发现-服务发现模式-举例-eureka、zookeeper、nacos的区别-√">服务注册与发现作用？为什么要有服务注册与发现？服务发现模式？举例？Eureka、ZooKeeper、Nacos的区别？√</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#eureka介绍-实现原理-工作流程-√eureka-server高可用-缓存机制-自我保护模式-解决方法-怎么知道最近的服务-就近机房">Eureka介绍？实现原理？工作流程？√Eureka Server高可用？缓存机制？自我保护模式？解决方法？怎么知道最近的服务，就近机房？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#配置中心作用-nacos配置中心原理-长轮询机制-spring-cloud-config构建过程-apollo">配置中心作用？Nacos配置中心原理？长轮询机制？Spring Cloud Config构建过程？Apollo</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#http和rpc区别-feign和dubbo的区别-fegin-实现原理-为什么feign第一次调用耗时很长-解决方法-怎么实现认证传递-怎么做负载均衡-重试机制-feign-和-ribbon-的区别-feign怎么和ribbon、eureka整合-openfegin底层可以使用哪些客户端-√">HTTP和RPC区别？Feign和Dubbo的区别？Fegin？实现原理？为什么Feign第一次调用耗时很长？解决方法？怎么实现认证传递？怎么做负载均衡？重试机制？Feign 和 Ribbon 的区别？Feign怎么和Ribbon、Eureka整合？Openfegin底层可以使用哪些客户端？√</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#负载均衡作用-模式-ribbon介绍-核心组件-实现原理-负载均衡算法-√缓存机制-重试机制-怎么和eureka整合">负载均衡作用？模式？Ribbon介绍？核心组件？实现原理？负载均衡算法？√缓存机制？重试机制？怎么和Eureka整合？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#什么是服务雪崩-防止方法-为什么要使用服务保障-hystrix作用-原理√隔离策略-缓存机制-作用">什么是服务雪崩？防止方法？为什么要使用服务保障？Hystrix作用，原理√隔离策略？缓存机制？作用？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#服务熔断-服务降级-区别-熔断降级方案实现-hystrix容错机制-熔断机制和服务降级-及其实现">服务熔断？服务降级？区别？熔断降级方案实现？Hystrix容错机制（熔断机制和服务降级）及其实现？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#服务限流-sentinel怎么实现限流-限流算法-√流程控制规则-√怎么实现集群限流">服务限流？Sentinel怎么实现限流？限流算法？√流程控制规则？√怎么实现集群限流？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#为什么要有网关-zuul原理-spring-cloud-gateway-工作流程-为什么要用灰度发布-如何实现">为什么要有网关？zuul原理？ Spring Cloud Gateway？工作流程？为什么要用灰度发布？如何实现？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#链路追踪-为什么要链路追踪-skywalking-spring-cloud-sleuth原理">链路追踪？为什么要链路追踪？SkyWalking？Spring Cloud Sleuth原理</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#seata-支持哪些模式的分布式事务-实现原理-事务执行流程-全局事务id和分支事务id是怎么传递的-事务回滚是怎么实现的">Seata？支持哪些模式的分布式事务？实现原理？事务执行流程？全局事务ID和分支事务ID是怎么传递的？事务回滚是怎么实现的？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#监控和告警">监控和告警？</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#日志收集">日志收集？</a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!--[--><!----><!--]--></aside></div><!--[--><!----><!--]--><div class="theme-hope-content"><h2 id="微服务概念-组件-spring-cloud组件-√-优缺点-流行的微服务解决方案及区别" tabindex="-1"><a class="header-anchor" href="#微服务概念-组件-spring-cloud组件-√-优缺点-流行的微服务解决方案及区别"><span>微服务概念？组件？Spring Cloud组件？√ 优缺点？流行的微服务解决方案及区别？</span></a></h2><p>微服务（Microservices）是一种软件架构风格，将一个大型应用程序划分为一组小型、自治且松耦合的服务。每个微服务负责执行特定的业务功能，并通过轻量级通信机制（如HTTP）相互协作。每个微服务可以独立开发、部署和扩展，使得应用程序更加灵活、可伸缩和可维护。<br> 微服务架构演进方向：单体式-&gt;服务化SOA（Service-Oriented Architecture，面向服务的架构）-&gt;微服务<br> SOA是一种设计原则。关注服务的重用性和组合性，但没有规定服务的大小<br> 微服务是对SOA思想的一种具体实践方式，但不等同于SOA</p><ul><li>注册中心：基于spring-cloud-commons的discovery的DiscoveryClient接口，实现统一的客户端的注册发现。 <ul><li>Spring Cloud Netflix：spring-cloud-netflix-eureka-server和spring-cloud-netflix-eureka-client ，基于Eureka实现、Consul</li><li>Spring Cloud Alibaba：spring-cloud-alibaba-nacos-discovery，基于Nacos实现。</li><li>spring-cloud-zookeeper-discovery，基于Zookeeper实现。</li></ul></li><li>配置中心： <ul><li>Spring Cloud Netflix：Spring Cloud Config基于Git、SVN作为存储、consul</li><li>Spring Cloud Alibaba：spring-cloud-alibaba-nacos-config基于Nacos实现。</li><li>Apollo携程开源的配置中心。Spring Cloud最成熟的配置中心的选择。</li></ul></li><li>远程调用：用于在不同的微服务之间进行通信和协作 <ul><li>RESTful API：RestTemplate、Feign</li><li>RPC（远程过程调用）：如Dubbo、gRPC</li></ul></li><li>API网关：作为微服务架构的入口，统一暴露服务，并提供路由、负载均衡、安全认证等功能 <ul><li>Spring Cloud Netflix：spring-cloud-netflix-zuul基于Zuul1实现。Netflix最新开源的网关服务是Zuul2 ，基于响应式的网关服务。、spring-cloud-gateway ，基于Spring Webflux实现</li><li>Spring Cloud Alibaba：Gateway、Apisix等</li></ul></li><li>分布式事务：保证跨多个微服务的一致性和原子性操作 <ul><li>Spring Cloud Alibaba：Seata</li></ul></li><li>熔断器：用于防止微服务之间的故障扩散，提高系统的容错能力。 <ul><li>Spring Cloud Netflix：spring-cloud-netflix-hystrix基于 Hystrix 实现。</li><li>Spring Cloud Alibaba：spring-cloud-alibaba-sentinel基于 Sentinel 实现。、Resilience4j</li></ul></li><li>限流和降级：用于防止微服务过载，对请求进行限制和降级处理。 <ul><li>Spring Cloud Netflix：Hystrix</li><li>Spring Cloud Alibaba：Sentinel</li></ul></li><li>分布式追踪和监控：用于跟踪和监控微服务的请求流程和性能指标。 <ul><li>Spring Cloud Netflix：Spring Cloud Sleuth + Zipkin基于Zipkin实现</li><li>Spring Cloud Alibaba：SkyWalking监控链路和JVM等、Sentinel Dashboard</li></ul></li><li>负载均衡：基于spring-cloud-commons的loadbalancer的ServiceInstanceChooser接口实现统一的服务的选择。并且，负载均衡组件在选择需要调用的服务之后，还提供调用该服务的功能，具体方法见LoadBalancerClient接口的execute方法。 <ul><li>spring-cloud-netflix-ribbon，基于Ribbon实现。</li><li>spring-cloud-loadbalancer，提供简单的负载均衡功能。</li></ul></li></ul><p>优点</p><ul><li>每一个服务足够内聚,代码容易理解</li><li>开发效率提高，一个服务只做一件事</li><li>微服务能够被小团队单独开发</li><li>微服务是松耦合的，是有功能意义的服务</li><li>可以用不同的语言开发,面向接口编程</li><li>易于与第三方集成</li><li>微服务只是业务逻辑的代码，不会和 HTML、CSS 或者其他界面组合</li></ul><p>缺点</p><ul><li>分布式系统的复杂性</li><li>多服务运维难度，随着服务的增加，运维的压力也在增大</li><li>系统部署依赖</li><li>服务间通信成本</li><li>数据一致性和事务管理</li><li>系统集成测试</li><li>性能监控</li><li>团队沟通和协作成本</li></ul><table><thead><tr><th>特点</th><th>Dubbo</th><th>Spring Cloud Netflix</th><th>Spring Cloud Alibaba</th></tr></thead><tbody><tr><td>开发语言</td><td>Java</td><td>Java</td><td>Java</td></tr><tr><td>服务治理</td><td>提供完整的服务治理功能</td><td>提供部分服务治理功能</td><td>提供完整的服务治理功能</td></tr><tr><td>服务注册与发现</td><td>ZooKeeper/Nacos</td><td>Eureka/Consul</td><td>Nacos</td></tr><tr><td>负载均衡</td><td>自带负载均衡策略</td><td>Ribbon</td><td>Ribbon\Dubbo负载均衡策略</td></tr><tr><td>服务调用</td><td>RPC方式</td><td>RestTemplate/Feign</td><td>Feign/RestTemplate/Dubbo</td></tr><tr><td>熔断器</td><td>Sentinel</td><td>Hystrix</td><td>Sentinel/Resilience4j</td></tr><tr><td>配置中心</td><td>Apollo</td><td>Spring Cloud Config</td><td>Nacos Config</td></tr><tr><td>API网关</td><td>Higress/APISIX</td><td>Zuul/Gateway</td><td>Spring Cloud Gateway</td></tr><tr><td>分布式事务</td><td>Seata</td><td>不支持分布式事务</td><td>Seata</td></tr><tr><td>限流和降级</td><td>Sentinel</td><td>Hystrix</td><td>Sentinel</td></tr><tr><td>分布式追踪和监控</td><td>Skywalking</td><td>Spring Cloud Sleuth + Zipkin</td><td>SkyWalking或Sentinel Dashboard</td></tr><tr><td>微服务网格</td><td>Dubbo Mesh</td><td>不支持微服务网格</td><td>Service Mesh（Nacos+Dubbo Mesh）</td></tr><tr><td>社区活跃度</td><td>相对较高</td><td>目前较低</td><td>相对较高</td></tr><tr><td>孵化和成熟度</td><td>孵化较早，成熟度较高</td><td>成熟度较高</td><td>孵化较新，但迅速发展</td></tr></tbody></table><h2 id="服务注册与发现作用-为什么要有服务注册与发现-服务发现模式-举例-eureka、zookeeper、nacos的区别-√" tabindex="-1"><a class="header-anchor" href="#服务注册与发现作用-为什么要有服务注册与发现-服务发现模式-举例-eureka、zookeeper、nacos的区别-√"><span>服务注册与发现作用？为什么要有服务注册与发现？服务发现模式？举例？Eureka、ZooKeeper、Nacos的区别？√</span></a></h2><p>管理和维护分布式系统中微服务的地址和元数据的组件。用于实现服务注册和发现</p><ul><li>服务注册：各个服务在启动时向注册中心注册自己的网络地址、服务实例信息和其他相关元数据。这样，其他服务就可以通过注册中心获取到当前可用的服务列表。</li><li>服务发现：客户端通过向注册中心查询特定服务的注册信息，获得可用的服务实例列表。这样客户端就可以根据需要选择合适的服务进行调用，实现了服务间的解耦。</li><li>负载均衡：对同一服务的多个实例进行负载均衡，将请求分发到不同的实例上，提高整体的系统性能和可用性。</li><li>故障恢复：监测和检测服务的状态，当服务实例发生故障或下线时，可以及时更新注册信息，从而保证服务能够正常工作。</li><li>服务治理：进行服务的配置管理、动态扩缩容、服务路由、灰度发布等操作，实现对服务的动态管理和控制</li></ul><p>屏蔽、解耦服务之间相互依赖的细节。服务之间的远程调用必须要知道IP、端口信息。调用方直接配置被调用方的IP、端口，这种调用直接依赖IP、端口的方式存在依赖，如被调用的IP、端口变化后，调用方也要同步修改。通过服务发现，将服务的IP、端口转化成服务名来调用。<br> 对微服务进行动态配置。微服务架构中，服务众多、服务之间的相互依赖错综复杂，无论是服务主动停止、意外挂掉，还是因为流量增加对服务实现扩容，这些服务或状态上的动态变化，都需要尽快的通知到被调用方，被调用方采取相应的策略。对于服务注册与发现要实时管理者服务的数据和状态，包括服务的注册上线、服务主动下线，异常服务的踢出。服务发现将服务IP、端口等细节通过一个服务名抽象给调用者，并动态管理者各个微服务的状态检测、状态更新，服务上线，下线等，这些都是微服务治理的基础，包括，负载均衡，链路跟踪。</p><p>客户端发现模式：客户端决定相应服务实例的网络位置，并且对请求实现负载均衡。客户端查询服务注册表，后者是一个可用服务实例的数据库；然后使用负载均衡算法从中选择一个实例，并发出请求<br> 服务端发现模式：客户端通过负载均衡器向某个服务提出请求，负载均衡器查询服务注册表，并将请求转发到可用的服务实例。如同客户端发现，服务实例在服务注册表中注册或注销。</p><table><thead><tr><th>特性</th><th>Eureka</th><th>ZooKeeper</th><th>Nacos</th></tr></thead><tbody><tr><td>开发公司</td><td>Netflix</td><td>Apache 基金会</td><td>阿里巴巴</td></tr><tr><td>CAP</td><td>AP（可用性和分区容忍性）</td><td>CP（一致性和分区容忍性）</td><td>AP、CP</td></tr><tr><td>功能</td><td>服务注册与发现</td><td>分布式协调、配置管理、分布式锁</td><td>服务注册与发现、配置管理、服务管理</td></tr><tr><td>定位</td><td>适用于构建基于 HTTP 的微服务架构</td><td>通用的分布式协调服务框架</td><td>适用于微服务和云原生应用</td></tr><tr><td>访问协议</td><td>HTTP</td><td>TCP</td><td>HTTP/DNS</td></tr><tr><td>自我保护</td><td>支持</td><td>-</td><td>支持</td></tr><tr><td>数据存储</td><td>内嵌数据库、多个实例形成集群</td><td>ACID 特性的分布式文件系统 ZAB 协议</td><td>内嵌数据库、MySQL 等</td></tr><tr><td>健康检查</td><td>Client Beat</td><td>Keep Alive</td><td>TCP/HTTP/MYSQL/Client Beat</td></tr><tr><td>特点</td><td>简单易用、自我保护机制</td><td>高性能、强一致性</td><td>动态配置管理、流量管理、灰度发布等</td></tr></tbody></table><ul><li>ZooKeeper：leader+follower，leader写，同步到follower，follower读，保证顺序一致性，主动推送，leader崩溃的时候，为了保证数据一致性，尽量不要读到不一致的数据，此时要重新选举leader以及做数据同步，此时集群会短暂的不可用</li><li>Eureka：peer-to-peer，各节点都能写也都能读，每个节点通过异步复同步给其他节点，所以可能数据不一致，任何一个节点宕机，其他节点正常工作，可用性高</li><li>Nacos：基于raft算法。还提供了配置管理、元数据管理和流量管理等功能，并且提供了一个可视化的控制台管理界面。</li></ul><h2 id="eureka介绍-实现原理-工作流程-√eureka-server高可用-缓存机制-自我保护模式-解决方法-怎么知道最近的服务-就近机房" tabindex="-1"><a class="header-anchor" href="#eureka介绍-实现原理-工作流程-√eureka-server高可用-缓存机制-自我保护模式-解决方法-怎么知道最近的服务-就近机房"><span>Eureka介绍？实现原理？工作流程？√Eureka Server高可用？缓存机制？自我保护模式？解决方法？怎么知道最近的服务，就近机房？</span></a></h2><p>由两个组件组成：Eureka服务端，服务注册中心，支持集群部署；Eureka 客户端，Java客户端，用来处理服务注册与发现。<br> 在应用启动时，Eureka客户端向服务端注册自己的服务信息，同时将服务端的服务信息缓存到本地。客户端会和服务端周期性的进行心跳交互，以更新服务租约和服务信息。</p><p>服务注册与发现: 服务实例启动时向Eureka Server发送注册请求，将自己的信息注册到注册中心。Eureka Server会将这些信息保存在内存中，并提供REST接口供其他服务查询。服务消费者可以通过查询服务实例列表来获取可用的服务提供者实例<br> 服务健康检查: 通过心跳机制来检测服务实例的健康状态。服务实例会定期向Eureka Server发送心跳表明自己的存活状态。如果Eureka Server在一定时间内没有收到某个服务实例的心跳，则会将其标记为不可用，并从服务列表中移除，下线实例。<br> 服务负载均衡: Eureka客户端在调用其他服务时，会从本地缓存中获取服务的注册信息。如果缓存中没有对应的信息，则会向Eureka Server发送查询请求。Eureka Server会返回一个可用的服务实例列表给客户端，客户端可以使用负载均衡算法选择其中一个进行调用。</p><p>Eureka 工作流程<br> Eureka Server 启动成功，等待服务端注册如果配置了集群，Eureka Servers 之间会通过 Replicate 同步注册表信息，每个服务器都维护完整的服务注册表。<br> Eureka Client 启动时根据配置的 Eureka Server 地址去注册中心注册服务客户端向注册中心注册自己并成为可用服务。<br> Eureka Client 定时全量或者增量从注册中心获取服务注册表，并将获取到的信息缓存到本地客户端以一定频率同步服务注册表，以便本地缓存最新信息。<br> Eureka Client 会每 30 秒向 Eureka Server 发送一次心跳请求，证明客户端服务正常确保注册表中的实例是健康的。<br> 当 Eureka Server 90 秒内没有收到 Eureka Client 的心跳，注册中心认为该节点失效，会注销该实例。超时未收到心跳后，Eureka Server 将该实例标记为下线并从注册表中移除。<br> 单位时间内 Eureka Server 统计到大量 Eureka Client 没有上送心跳，可能为网络异常，进入自我保护机制在自我保护模式中，Eureka Server 暂时不剔除未上报心跳的客户端。<br> 当 Eureka Client 心跳请求恢复正常之后，Eureka Server 自动退出自我保护模式网络恢复后，自我保护模式结束，正常执行剔除逻辑。<br> 服务调用时，Eureka Client 会先从本地缓存找寻调取的服务通过本地缓存提升调用性能，减少对注册中心的依赖。<br> 如果获取不到，Eureka Client 从注册中心刷新注册表，再同步到本地缓存 在缓存失效或服务信息不完整时，主动更新注册表。<br> Eureka Client 程序关闭时向 Eureka Server 发送取消请求，Eureka Server 将实例从注册表中删除客户端主动注销，确保服务列表的实时性。</p><p>多实例部署: 通过将多个Eureka Server实例部署在不同的节点上，当其中一个实例发生故障时，其他实例仍然可以提供服务，并保持注册信息的一致性。<br> 服务注册信息的复制: 当一个服务实例向Eureka Server注册时，每个Eureka Server实例都会复制其他实例的注册信息，以保持数据的一致性。当某个Eureka Server实例发生故障时，其他实例可以接管其工作，保证整个系统的正常运行。<br> 自我保护机制: ~，防止由于网络抖动或其他原因导致的误剔除，提高系统的稳定性</p><figure><img src="https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQ70a7c92f073b2623dc4a104375c35b6a.png" alt="eurekacache.png" tabindex="0"><figcaption>eurekacache.png</figcaption></figure><p>当Eureka Server节点在短时间内丢失了过多实例的连接时（比如网络故障或频繁的启动关闭客户端）就会进入自我保护模式，保护服务注册表中的信息，不再删除服务注册表中的数据（即不会注销任何微服务），当网络故障恢复后，就会自动退出自我保护模式<br> 解决方法<br> 等待Eureka Server自动恢复等待网络恢复（或者没有频繁的启动与关闭实例）<br> 依次重启Eureka Server：对Eureka Server做负载均衡，无效的实例会被清除。<br> 关闭Eureka自我保护模式</p><div class="language-yaml line-numbers-mode" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">server</span><span class="token punctuation">:</span>
    <span class="token key atrule">enable-self-preservation</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
    <span class="token key atrule">eviction-interval-timer-in-ms</span><span class="token punctuation">:</span> <span class="token number">4000</span> <span class="token comment"># This is not required</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过属性prefer-same-zone-eureka<br> 如果false则只和service-url的第一个注册中心注册并维持心跳检测，只有在第一个注册失败的情况下，才会依次向其它的注册中心注册，总共重试3次，注册失败后每隔一个心跳时间，会再次尝试。<br> 如果true，先通过region取availability-zones内的第一个zone的service-url下的第一个注册中心进行注册和维持心跳，不再向其它的注册中心注册和维持心跳。只有在第一个注册失败的情况下，才会依次向其它的注册中心注册，总共重试3次，注册失败后每隔一个心跳时间，会再次尝试。为了保证服务注册到同一个 zone 的注册中心，一定要注意 availability-zones 的顺序，必须把同一zone写在最前面</p><div class="language-yaml line-numbers-mode" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token comment"># 尽量向同一区域的 eureka 注册,默认为true</span>
    <span class="token key atrule">prefer-same-zone-eureka</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token comment"># 地区</span>
    <span class="token key atrule">region</span><span class="token punctuation">:</span> tianjin
    <span class="token key atrule">availability-zones</span><span class="token punctuation">:</span>
      <span class="token key atrule">tianjin</span><span class="token punctuation">:</span> zone<span class="token punctuation">-</span><span class="token number">1</span><span class="token punctuation">,</span>zone<span class="token punctuation">-</span><span class="token number">2</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>
      <span class="token key atrule">zone-1</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//IP1<span class="token punctuation">:</span>port/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//IP2<span class="token punctuation">:</span>port/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//IP3<span class="token punctuation">:</span>port/eureka/
      <span class="token key atrule">zone-2</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//IP1<span class="token punctuation">:</span>port/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//IP2<span class="token punctuation">:</span>port/eureka/<span class="token punctuation">,</span>http<span class="token punctuation">:</span>//IP3<span class="token punctuation">:</span>port/eureka/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="配置中心作用-nacos配置中心原理-长轮询机制-spring-cloud-config构建过程-apollo" tabindex="-1"><a class="header-anchor" href="#配置中心作用-nacos配置中心原理-长轮询机制-spring-cloud-config构建过程-apollo"><span>配置中心作用？Nacos配置中心原理？长轮询机制？Spring Cloud Config构建过程？Apollo</span></a></h2><p>用于集中管理微服务的配置信息(例如数据库连接地址、服务端口、日志级别等)，动态修改配置而不需要重启服务</p><p>配置信息存储：默认用内嵌数据库Derby存储配置信息，可换MySQL<br> 注册配置信息：服务启动时，Nacos Client会向Nacos Server注册的配置信息，Nacos把配置信息写入存储，并生成版本号。<br> 获取配置信息：服务运行期间，Nacos Client通过API从Nacos Server获取配置信息。Server根据键查找对应的配置信息并返回给Client<br> 监听配置变化：Nacos Client通过注册监听器的方式实现对配置信息的监听。当配置信息发生变化时，Nacos Server会通知已注册的监听器，并触发相应的回调方法</p><p>客户端和服务端的交互分为：推（Push）和拉（Pull），Nacos采用长轮询进行配置的动态刷新。<br> 客户端发起Pull请求，服务端检查配置是否有变更。如果没有变更，则设置一个定时任务，并将当前的客户端连接加入到等待队列中。<br> 在等待期间，如果配置发生变更，服务端会立即返回结果给客户端，完成一次&quot;推送&quot;操作。<br> 如果没有配置变更，等待时间达到预设的超时时间后，服务端会自动返回结果给客户端，即使配置没有变更。<br> 如果在等待期间，通过Nacos Dashboard或API对配置进行了修改，会触发一个事件机制，服务端会遍历等待队列，找到发生变更的配置项对应的客户端连接，并将变更的数据通过连接返回，完成一次&quot;推送&quot;操作。<br> 降低服务端压力，避免了大量的长连接占用内存资源</p><p>提供服务器端和客户端。服务器存储后端的默认实现使用 Git ，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。<br> 这个还是静态的，得配合 Spring Cloud Bus 实现动态的配置更新。</p><p>配置服务器：为配置客户端提供其对应的配置信息，配置信息的来源为配置仓库，启动时即拉取配置仓库的信息，缓存到本地仓库中。<br> 配置客户端：除了配置服务器之外的应用服务，启动时从配置服务器拉取其对应的配置信息。<br> 配置仓库：为配置服务器提供配置源信息，配置仓库的实现可以支持多种方式。</p><p>构建 Spring cloud config 配置中心</p><details><summary>创建Spring Boot项目并添加config-server依赖</summary><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-config-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><p>入口类的main方法类上添加注解 @EnableConfigServer</p><details><summary>在application.properties中配置git仓库</summary><div class="language-yaml line-numbers-mode" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token comment"># 接口 URL:/{application}/{profile}/{label}</span>
spring.cloud.config.server.git.uri=https<span class="token punctuation">:</span>//github.com/username/config<span class="token punctuation">-</span>repo
spring.cloud.config.server.git.clone<span class="token punctuation">-</span>on<span class="token punctuation">-</span>start=true
spring.cloud.config.server.git.searchPaths=config<span class="token punctuation">-</span>center
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><p>构建 Springcloud config 配置中心仓库：在github上设置配置中心，本地创建文件夹wkcto，然后在里面创建文件夹config-center，然后在里面创建四个配置文件。使用 git push 推送到远程仓库，然后启动配置中心，通过/{application}/{profile}/{label}就能访问配置文件</p><p>构建Spring cloud config配置中心客户端</p><details><summary>创建Spring Boot项目并添加spring-cloud-starter-config依赖</summary><div class="language-xml line-numbers-mode" data-ext="xml" data-title="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details> 创建 bootstrap.properties 文件用于获取配置信息。其中 name、profile、label 分别对应配置文件中的应用名、环境名和Git分支或标签名。 然后用@RefreshScope动态刷新配置，用注解获取配置内容如@value <h2 id="http和rpc区别-feign和dubbo的区别-fegin-实现原理-为什么feign第一次调用耗时很长-解决方法-怎么实现认证传递-怎么做负载均衡-重试机制-feign-和-ribbon-的区别-feign怎么和ribbon、eureka整合-openfegin底层可以使用哪些客户端-√" tabindex="-1"><a class="header-anchor" href="#http和rpc区别-feign和dubbo的区别-fegin-实现原理-为什么feign第一次调用耗时很长-解决方法-怎么实现认证传递-怎么做负载均衡-重试机制-feign-和-ribbon-的区别-feign怎么和ribbon、eureka整合-openfegin底层可以使用哪些客户端-√"><span>HTTP和RPC区别？Feign和Dubbo的区别？Fegin？实现原理？为什么Feign第一次调用耗时很长？解决方法？怎么实现认证传递？怎么做负载均衡？重试机制？Feign 和 Ribbon 的区别？Feign怎么和Ribbon、Eureka整合？Openfegin底层可以使用哪些客户端？√</span></a></h2><p>微服务中基于HTTP风格的远程调用通常用Feign实现，基于RPC的远程调用通常用Dubbo实现</p><table><thead><tr><th>-</th><th>HTTP（Hypertext Transfer Protocol超文本传输协议）</th><th>RPC（Remote Procedure Call，远程过程调用）</th></tr></thead><tbody><tr><td>定义</td><td>用于传输超文本的协议。应用层协议，强调网络通信；</td><td>用于实现分布式系统中不同节点之间通信的协议。强调服务之间的远程调用</td></tr><tr><td>通信方式</td><td>基于请求-响应模型，客户端发送请求，服务器返回响应。</td><td>基于方法调用模型，客户端调用远程方法并等待结果。</td></tr><tr><td>传输协议</td><td>基于TCP协议，可使用其他传输层协议如TLS/SSL进行安全加密。</td><td>TCP、UDP。</td></tr><tr><td>数据格式</td><td>基于文本，JSON、XML</td><td>二进制、JSON、Protocol Buffers等。</td></tr><tr><td>接口定义</td><td>使用RESTful风格的接口进行定义，常用的方法有GET、POST、PUT、DELETE等。</td><td>使用IDL（接口定义语言）进行接口定义，如Protocol Buffers、Thrift等。</td></tr><tr><td>跨语言性</td><td>支持跨语言通信，可以使用HTTP作为通信协议实现不同语言之间的通信。</td><td>支持跨语言通信，可以使用IDL生成不同语言的客户端和服务端代码。</td></tr><tr><td>灵活性</td><td>更加灵活，适用于不同类型的应用场景，如Web开发、API调用等。</td><td>更加高效，适用于需要高性能和低延迟的分布式系统。</td></tr></tbody></table><table><thead><tr><th>-</th><th>Feign</th><th>Dubbo</th></tr></thead><tbody><tr><td>定义</td><td>声明式的Web服务客户端，用于简化HTTP API的调用。</td><td>分布式服务框架，用于构建面向服务的微服务架构。</td></tr><tr><td>通信方式</td><td>基于HTTP协议，使用RESTful风格的接口进行定义和调用。也可以RPC协议</td><td>基于RPC协议，支持多种序列化协议如gRPC、Hessian等。也可以HTTP协议</td></tr><tr><td>服务发现</td><td>通常结合服务注册中心（如Eureka、Consul）进行服务发现和负载均衡。</td><td>通过ZooKeeper、Nacos等进行服务注册和发现，并提供负载均衡功能。</td></tr><tr><td>服务治理</td><td>不直接提供服务治理功能，需要结合其他组件或框架进行服务治理。</td><td>提供服务注册与发现、负载均衡、容错机制、服务降级等服务治理功能。</td></tr><tr><td>跨语言性</td><td>支持跨语言通信，可以使用HTTP作为通信协议实现不同语言之间的通信。</td><td>支持跨语言通信，通过Dubbo的IDL生成不同语言的客户端和服务端代码。</td></tr><tr><td>生态系统</td><td>集成了Spring Cloud生态系统，与Spring Boot无缝集成。</td><td>拥有完整的生态系统，包括注册中心、配置中心、监控中心等组件。</td></tr><tr><td>适用场景</td><td>适用于构建RESTful风格的微服务架构，特别适合基于HTTP的微服务调用。</td><td>适用于构建面向服务的微服务架构，提供更全面的服务治理和容错机制。</td></tr></tbody></table><p>Feign使用RestTemplate实现Http调用，实现了spring-cloud-openfeign<br> 主要特点和功能包括：<br> 声明式API：用注解来定义和描述对远程服务的访问<br> 集成Ribbon负载均衡：根据服务名和可用实例进行动态路由，并分发请求到不同的服务实例上，提高系统的可用性和可伸缩性。<br> 容错机制：支持Hystrix容错框架，可以在调用远程服务时提供容错和断路器功能。当远程服务不可用或响应时间过长时，Feign可以快速失败并返回预设的响应结果，避免对整个系统造成级联故障。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">&quot;example&quot;</span><span class="token punctuation">,</span> url <span class="token operator">=</span> <span class="token string">&quot;https://api.example.com&quot;</span><span class="token punctuation">)</span> 
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ExampleService</span> <span class="token punctuation">{</span> 
    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/endpoint&quot;</span><span class="token punctuation">)</span> 
    <span class="token class-name">String</span> <span class="token function">getEndpointData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Feign会对定义了@FeignClient的接口创建一个动态代理。接口本质调用Feign创建的动态代理<br> Feign的动态代理会根据接口上@RequestMapping 等注解，来动态构造出你要请求的服务的地址。<br> 最后针对这个地址，发起请求、解析响应。<br> 通过@EnableFeignClients和FeignClient注解 通过动态代理在本地实例化远程接口-&gt;封装Request对象并进行编码-&gt;使用restTemplate发起http请求并对获取结果进行解码。<br><img src="https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQ9b2b80e9526f5b4e11f3d33b3d0410cd.png" alt="feginprinciple.png"></p><p>Ribbon的懒加载机制，当第一次调用发生时触发加载过程，包括从服务注册中心获取服务列表、建立连接池等操作，这个加载过程会增加首次调用的耗时。</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>ribbon: 
   eager-load: 
     enabled: <span class="token boolean">true</span> 
       clients: service-1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>预热Feign客户端，启动时触发一次无关紧要的调用，来提前加载Ribbon和其他相关组件。相当于提前进行了第一次调用。</p><p>使用拦截器传递认证信息。实现RequestInterceptor接口定义拦截器，把认证信息添加到请求头中，然后将其注册到Feign的配置中</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span> 
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FeignClientConfig</span> <span class="token punctuation">{</span> 
     <span class="token annotation punctuation">@Bean</span> 
     <span class="token keyword">public</span> <span class="token class-name">RequestInterceptor</span> <span class="token function">requestInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
         <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RequestInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
             <span class="token annotation punctuation">@Override</span> 
             <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">RequestTemplate</span> template<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
                 <span class="token comment">// 添加认证信息到请求头中 </span>
                 template<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">&quot;Authorization&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Bearer &quot;</span> <span class="token operator">+</span> <span class="token function">getToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
             <span class="token punctuation">}</span> 
         <span class="token punctuation">}</span><span class="token punctuation">;</span> 
     <span class="token punctuation">}</span> 
  
     <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">getToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
         <span class="token comment">// 获取认证信息的逻辑，可以从SecurityContext或其他地方获取 </span>
         <span class="token comment">// 返回认证信息的字符串形式 </span>
         <span class="token keyword">return</span> <span class="token string">&quot;your_token&quot;</span><span class="token punctuation">;</span> 
     <span class="token punctuation">}</span> 
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>//Ribbon+RestTemplate的重试
@Bean
@LoadBalanced
public RestTemplate restTemplate() {
  SimpleClientHttpRequestFactory simpleClientHttpRequestFactory = new   SimpleClientHttpRequestFactory();
  simpleClientHttpRequestFactory.setConnectTimeout(1000);
  simpleClientHttpRequestFactory.setReadTimeout(1000);
  return new RestTemplate(simpleClientHttpRequestFactory);
}
在此基础上，使用如下配置，即可实现重试：
spring.cloud.loadbalancer.retry.enabled=true
ribbon:
  # 同一实例最大重试次数，不包括首次调用
  MaxAutoRetries: 1
  # 重试其他实例的最大重试次数，不包括首次所选的server
  MaxAutoRetriesNextServer: 2
  # 是否所有操作都进行重试
  OkToRetryOnAllOperations: false

因为 Ribbon 和 Feign 都有重试机制，在整合 Ribbon 的情况下，不使用 Feign 重试，而是使用 Ribbon 的重试。
ribbon:
  MaxAutoRetries: 1
  MaxAutoRetriesNextServer: 2
  OkToRetryOnAllOperations: false
相关Issue可参考：https://github.com/spring-cloud/spring-cloud-netflix/issues/467

Zuul的重试
# 开启了重试
zuul.retryable: true
ribbon:
  MaxAutoRetries: 1
  MaxAutoRetriesNextServer: 2
  OkToRetryOnAllOperations: false
# 指定局部路由开启重试，局部配置优先级更高。
zuul.routes.&lt;routename&gt;.retryable=true

基于HTTP响应码重试
clientName.ribbon.retryableStatusCodes: 404,502
Hystrix的超时时间必须大于超时的时间，否则，一旦Hystrix超时，就没办法继续重试了。
不建议将ribbon.OkToRetryOnAllOperations 设为true。因为一旦启用该配置，则表示重试任何操作，包括POST请求，而由于缓存了请求体，此时可能会影响服务器的资源。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Ribbon和Feign都是使用于调用用其余服务的，不过方式不同。<br> 启动类用的注解不同。Ribbon使用@RibbonClient ；Feign使用@EnableFeignClients 。<br> 服务的指定位置不同。Ribbon在@RibbonClient注解上设置；Feign则是在定义声明方法的接口中用@FeignClient注解上设置<br> 调使用方式不同<br> Ribbon需要构建Http请求，模拟Http请求而后用RestTemplate发送给其余服务<br> Feign采使用接口的方式，将需要调使用的其余服务的方法定义成声明方法就可，不需要构建Http请求。不过要注意的是声明方法的注解、方法签名要和提供服务的方法完全一致</p><p><img src="https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQ6bc9de47c7d69a3c14ef91758ec95a19.png" alt="feginribboneureka.png"><br> 首先，调用Feign 创建的动态代理<br> 然后，Feign 调用 Ribbon 发起调用流程。</p><ul><li>首先，Ribbon 会从 Eureka Client 里获取到对应的服务列表。</li><li>然后，Ribbon 使用负载均衡算法获得使用的服务。</li><li>ribbon调用对应的服务，调用 Feign ，而 Feign 调用 HTTP 库最终调用使用的服务。</li><li>因为 Feign 和 Ribbon 都存在使用 HTTP 库调用指定的服务，两者集成后保留Feign的调用，而Ribbon只负责负载均衡功能</li></ul><p>Apache HttpClient(默认)线程安全<br> OkHttp：异步请求、HTTP/2和WebSocket支持，支持连接池复用连接,<br> //连接池配置参数<br> maxIdleConnections：最大空闲连接数。<br> keepAliveDuration：空闲连接的存活时间，超过这个时间后，连接会被关闭。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">okhttp3<span class="token punctuation">.</span></span><span class="token class-name">ConnectionPool</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">okhttp3<span class="token punctuation">.</span></span><span class="token class-name">OkHttpClient</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">okhttp3<span class="token punctuation">.</span></span><span class="token class-name">Request</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">okhttp3<span class="token punctuation">.</span></span><span class="token class-name">Response</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">TimeUnit</span></span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OkHttpExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>

        <span class="token class-name">ConnectionPool</span> connectionPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConnectionPool</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">OkHttpClient</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">OkHttpClient<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">connectionPool</span><span class="token punctuation">(</span>connectionPool<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Request</span> request1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Request<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">url</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.example.com/page1&quot;</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">Request</span> request2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Request<span class="token punctuation">.</span>Builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">url</span><span class="token punctuation">(</span><span class="token string">&quot;http://www.example.com/page2&quot;</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Response</span> response1 <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">newCall</span><span class="token punctuation">(</span>request1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Response 1 code: &quot;</span> <span class="token operator">+</span> response1<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Simulate some delay</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">Response</span> response2 <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">newCall</span><span class="token punctuation">(</span>request2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Response 2 code: &quot;</span> <span class="token operator">+</span> response2<span class="token punctuation">.</span><span class="token function">code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="负载均衡作用-模式-ribbon介绍-核心组件-实现原理-负载均衡算法-√缓存机制-重试机制-怎么和eureka整合" tabindex="-1"><a class="header-anchor" href="#负载均衡作用-模式-ribbon介绍-核心组件-实现原理-负载均衡算法-√缓存机制-重试机制-怎么和eureka整合"><span>负载均衡作用？模式？Ribbon介绍？核心组件？实现原理？负载均衡算法？√缓存机制？重试机制？怎么和Eureka整合？</span></a></h2><p>优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。</p><p>客户端模式：客户端节点有一份服务端清单，从Eureka服务注册中心获取。在Spring Cloud中使用@LoadBalanced注解开启客户端模式<br> 服务端模式（nginx）：维护一个可用的服务端清单，然后通过心跳机制来删除故障的服务端节点以保证清单中都是可以正常访问的服务端节点。负载均衡服务器按照某种配置好的规则从可用服务端清单中选出一台服务器去处理客户端的请求。</p><p>Ribbon是Netflix开源的一个客户端负载均衡器.Ribbon通过从服务注册中心获取可用服务列表，并通过负载均衡算法选择合适的服务实例进行请求转发，提供客户端的软件负载均衡算法。</p><p>Server封装了服务实例的ip和端口之类<br> ServerList获取服务实例列表的<br> ServerListUpdater是用来更新服务注册表的数据<br> IRule负责负载均衡的算法的<br> IClientConfig获取到一些配置Ribbon的一些配置<br> ILoadBalancer主要是用来协调上面提到的各个核心组件的，使得他们能够协调工作</p><figure><img src="https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQb667e7307d4531649961085458871b44.png" alt="ribbonprinciple.png" tabindex="0"><figcaption>ribbonprinciple.png</figcaption></figure><p>Round Robin轮询<br> Random 随机<br> AvailabilityFilteringRule会优先过滤掉由于多次访问故障而处于断路器跳闸状态被标记为circuit tripped的服务，还有并发的连接数（active connections 超过配置的阈值）超过临界值的服务，然后对剩余的服务列表按照轮训策略进行访问<br> WeightedResponseTimeRule根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的机率越大，刚启动时统计信息不足使用RoundRobinRule策略，统计信息足切换到WeightedResponseTimeRule<br> RetryRule先按照RoundRobinRule策略获取服务，如果获取服务失败则在制定时间内进行重试<br> BestAvailableRule会优先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，选择一个最小的并发请求的server.逐个考察Server，如果Server被tripped则忽略，在选择ActiveRequestsCount最小的server<br> ZoneAvoidanceRule复合判断server所在区域的性能和server的可用性选择服务器</p><p>Ribbon从Eureka Client获取服务列表。然后，Ribbon 使用负载均衡算法获得使用的服务并调用</p><h2 id="什么是服务雪崩-防止方法-为什么要使用服务保障-hystrix作用-原理√隔离策略-缓存机制-作用" tabindex="-1"><a class="header-anchor" href="#什么是服务雪崩-防止方法-为什么要使用服务保障-hystrix作用-原理√隔离策略-缓存机制-作用"><span>什么是服务雪崩？防止方法？为什么要使用服务保障？Hystrix作用，原理√隔离策略？缓存机制？作用？</span></a></h2><p>分布式系统中某个服务故障引发连锁反应，导致多个服务不可用甚至整个系统瘫痪的现象</p><p>服务高可用部署：通过冗余部署、故障转移等方式来减少单点故障的影响。<br> 限流和熔断：对服务之间的请求进行限流和熔断，以防止过多的请求涌入导致后端服务不可用。<br> 缓存和降级：合理使用缓存来减轻后端服务的负载压力，并在必要时进行服务降级，保证核心功能的可用性。</p><p>为了防止雪崩</p><p>熔断，控制故障范围。防止雪崩</p><p>Hystrix是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。<br> 旨在通过添加延迟容错和容错逻辑来提高分布式系统的弹性，防止雪崩效应的发生。它通过隔离服务之间的依赖关系、限制并发线程池的大小、实现熔断机制等方式来实现容错。</p><p>线程池隔离(支持超时)。tomcat线程会将请求任务交给服务内部线程池的线程处理，线程完成后将调用结果返回给tomcat。从而实现资源隔离，服务内部的线程池的数量就决定了整个服务并发度；当请求的服务网络开销比较大的时候，或者是请求比较耗时的时候使用，因为，可以保证大量的容器(tomcat)线程可用，不会由于服务原因，一直处于阻塞或等待状态，快速失败返回<br> 信号量隔离。限制tomcat访问服务的线程数达到限流目的。请求缓存服务时使用，因为这类服务的返回通常会非常的快，不会占用容器线程太长时间，而且也减少了线程切换的一些开销，提高了缓存服务的效率<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/62d5d0137dc8127da398a.jpg" alt="hystrixprinciple.png"></p><p>减少重复的请求数。降低依赖服务的返回数据始终保持一致。<br> 在同一个用户请求的上下文中，相同依赖服务的返回数据始终保持一致。<br> 请求缓存在run()和construct()执行之前生效，所以可以有效减少不必要的线程开销</p><h2 id="服务熔断-服务降级-区别-熔断降级方案实现-hystrix容错机制-熔断机制和服务降级-及其实现" tabindex="-1"><a class="header-anchor" href="#服务熔断-服务降级-区别-熔断降级方案实现-hystrix容错机制-熔断机制和服务降级-及其实现"><span>服务熔断？服务降级？区别？熔断降级方案实现？Hystrix容错机制（熔断机制和服务降级）及其实现？</span></a></h2><p>服务熔断（Circuit Breaker）是微服务架构中的容错机制，用于保护系统免受服务故障或异常的影响。当某个服务出现故障或异常时，服务熔断可以快速隔离该服务，确保系统稳定可用。<br> 它通过监控服务的调用情况，当错误率或响应时间超过阈值时，触发熔断机制，后续请求将返回默认值或错误信息，避免资源浪费和系统崩溃。<br> 服务熔断还支持自动恢复，重新尝试对故障服务的请求，确保服务恢复正常后继续使用。</p><p>服务降级（Fallback）是微服务架构中的容错机制，用于在系统资源紧张或服务故障时保证核心功能的可用性。<br> 当系统出现异常情况时，服务降级会主动屏蔽一些非核心或可选的功能，而只提供最基本的功能，以确保系统的稳定运行。通过减少对资源的依赖，服务降级可以保证系统的可用性和性能。<br> 它可以根据业务需求和系统状况来制定策略，例如替换耗时操作、返回默认响应、返回静态错误页面等。</p><p>服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）实现方式不太一样；服务降级具有代码侵入性(由控制器完成/或自动降级)，熔断一般称为自我熔断。</p><table><thead><tr><th>框架</th><th>实现方案</th><th>特点</th></tr></thead><tbody><tr><td>Spring Cloud Netflix</td><td>Hystrix</td><td>提供线程隔离、服务降级、请求缓存、请求合并等功能可与Spring Cloud其他组件无缝集成.官方已宣布停止维护，推荐使用Resilience4j代替</td></tr><tr><td>Spring Cloud</td><td>Resilience4j</td><td>轻量级服务熔断库 提供类似于Hystrix的功能 具有更好的性能和更简洁的API 可与Spring Cloud其他组件无缝集成</td></tr><tr><td>Spring Cloud Alibaba</td><td>Sentinel</td><td>阿里巴巴开源的流量控制和熔断降级组件提供实时监控、流量控制、熔断降级等功能与Spring Cloud Alibaba生态系统紧密集成</td></tr><tr><td>Dubbo</td><td>Dubbo自带熔断降级机制</td><td>Dubbo框架本身提供的熔断降级机制可通过配置实现服务熔断和降级与Dubbo的RPC框架紧密集成</td></tr></tbody></table><p>服务熔断：当服务的错误率或响应时间超过Hystrix预设的阈值时，熔断器将会打开，后续的请求将不再发送到实际的服务提供方，而是返回预设的默认值或错误信息。快速隔离故障服务，防止故障扩散，提高系统的稳定性和可用性。熔断方式有以下几种：<br> 强制熔断：不再进行服务调用。比如服务提供方宕机<br> 根据阈值熔断：当服务调用失败率达到一定阈值时，将后续请求快速失败。<br> 半开状态熔断：在熔断器开启一段时间后，尝试发送一个测试请求到服务提供方，如果请求成功，则熔断器进入半开状态，否则继续保持开启状态。<br> 降级：~<br> 服务降级：当服务熔断打开时调用自定义降级方法或返回默认值保证系统继续正常运行。例如返回缓存数据、执行简化的逻辑或调用其他可靠的服务，以提供有限但可用的功能。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>netflix<span class="token punctuation">.</span>hystrix<span class="token punctuation">.</span>contrib<span class="token punctuation">.</span>javanica<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">HystrixCommand</span></span><span class="token punctuation">;</span>
 <span class="token comment">//服务降级 </span>
 <span class="token annotation punctuation">@Service</span> 
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyService</span> <span class="token punctuation">{</span> 
     <span class="token annotation punctuation">@HystrixCommand</span><span class="token punctuation">(</span>fallbackMethod <span class="token operator">=</span> <span class="token string">&quot;fallbackMethod&quot;</span><span class="token punctuation">)</span> 
     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">myServiceMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> 
     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">fallbackMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
         <span class="token comment">// 降级方法的逻辑，当服务调用失败时会执行此方法，可以返回默认值或执行其他备用逻辑 </span>
     <span class="token punctuation">}</span> 
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请求缓存（Request Caching）：缓存对同一请求的响应结果，当下次请求相同的数据时，直接从缓存中获取，避免重复的网络请求，提高系统的性能和响应速度<br> 请求合并（Request Collapsing）：将多个并发的请求合并为一个批量请求，减少网络开销和资源占用。高并发场景下有效地减少请求次数，提高系统的性能。<br> 实时监控和度量（Real-time Monitoring and Metrics）：对服务的执行情况进行监控和统计，包括错误率、响应时间、并发量等指标。通过监控数据，可以及时发现和解决服务故障或性能问题。<br> 线程池隔离（Thread Pool Isolation）：每个依赖服务的请求都放在独立的线程池中执行，避免因某个服务的故障导致整个系统的线程资源耗尽。提高系统的稳定性和可用性。</p><p>通过HystrixCircuitBreaker实现。有三种状态:CLOSED-关闭；OPEN-打开；HALF_OPEN-半开<br> OPEN表示熔断状态打开，命令执行时，直接调用回退逻辑。<br> 红线：初始时处于CLOSED状态，链路处于健康状态。当周期(HystrixCommandProperties.default_metricsRollingStatisticalWindow = 10000 ms)内，总请求数超过一定量(HystrixCommandProperties.circuitBreakerRequestVolumeThreshold = 20) 。错误请求占总请求数超过一定比例(HystrixCommandProperties.circuitBreakerErrorThresholdPercentage = 50% ) 。断路器从CLOSED变成OPEN状态<br> 绿线：断路器处于OPEN状态，命令执行时，若当前时间超过断路器开启时间一定时间(HystrixCommandProperties.circuitBreakerSleepWindowInMilliseconds = 5000ms)，断路器变成HALF_OPEN状态，尝试调用正常逻辑，根据执行是否成功，打开或关闭熔断器【蓝线】。<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/7aa4fa0667258f4190419.jpg" alt="hystrixcircuitbreakerstatuschange.png"></p><h2 id="服务限流-sentinel怎么实现限流-限流算法-√流程控制规则-√怎么实现集群限流" tabindex="-1"><a class="header-anchor" href="#服务限流-sentinel怎么实现限流-限流算法-√流程控制规则-√怎么实现集群限流"><span>服务限流？Sentinel怎么实现限流？限流算法？√流程控制规则？√怎么实现集群限流？</span></a></h2><p>通过对并发访问/请求进行限速或者一个时间窗口内的的请求进行限速来保护系统，达到限制速率则可以拒绝服务（定向到错误页或告知资源没有了）、排队或等待（比如秒杀、评论、下单）、降级（返回兜底数据或默认数据，如商品详情页库存默认有货）。</p><p>Sentinel通过动态管理限流规则，根据定义的规则对请求进行限流控制。</p><details><summary>定义资源：可以是URL、方法等，用于标识需要进行限流的请求。</summary><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//原业务方法. </span>
<span class="token annotation punctuation">@SentinelResource</span><span class="token punctuation">(</span>blockHandler <span class="token operator">=</span> <span class="token string">&quot;blockHandlerForGetUser&quot;</span><span class="token punctuation">)</span> 
<span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">&quot;getUserById command failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span> 
  
<span class="token comment">// blockHandler 函数，原方法调用被限流/降级/系统保护时调用 </span>
<span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">blockHandlerForGetUser</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">,</span> <span class="token class-name">BlockException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">&quot;admin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details><summary>配置限流规则：在Sentinel的配置文件中定义资源的限流规则。规则可以包括资源名称、限流阈值、限流模式（令牌桶或漏桶）等。</summary><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>private static void initFlowQpsRule() { 
     List&lt;FlowRule&gt; rules = new ArrayList&lt;&gt;(); 
     FlowRule rule1 = new FlowRule(); 
     rule1.setResource(resource); 
     // Set max qps to 20 
     rule1.setCount(20); 
     rule1.setGrade(RuleConstant.FLOW_GRADE_QPS); 
     rule1.setLimitApp(&quot;default&quot;); 
     rules.add(rule1); 
     FlowRuleManager.loadRules(rules); 
 }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details> 监控流量：Sentinel会监控每个资源的流量情况，包括请求的QPS（每秒请求数）、线程数、响应时间等。 限流控制：当请求到达时，Sentinel会根据资源的限流规则判断是否需要进行限流控制。如果请求超过了限流阈值，则可以进行限制、拒绝或进行其他降级处理。 <p>使用滑动窗口限流算法来实现限流。基于时间窗口的限流算法。将一段时间划分为多个时间窗口，并在每个时间窗口内统计请求的数量。通过动态地调整时间窗口的大小和滑动步长，可以更精确地控制请求的通过速率。</p><p>流量控制原理是监控应用流量的QPS或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性<br> 1.QPS(Queries Per Second)：当调用相关url对应的资源时，QPS达到单机阈值时限流<br> 2.线程数：当调用相关url对应的资源时，线程数达到单机阈值时限流<br> 设置限流模式</p><ul><li>直连模式 默认的流控处理就是(直连--&gt;快速失败);</li><li>关联模式 当关联的资源达到阈值，就限流自己。</li><li>链路模式 只针对从指定链路访问到本资源的请求做统计，判断是否超过阈值。直接拒绝直接拒绝（RuleConstant.CONTROL_BEHAVIOR_DEFAULT）方式是默认的流量控制方式，当QPS超过任意规则的阈值后，新的请求就会被立即拒绝，拒绝方式为抛出FlowException。</li></ul><p>利用Token Server和Token Client的机制来实现。Client向Token Server发送请求，Token Server根据配置的规则决定是否限流。</p><h2 id="为什么要有网关-zuul原理-spring-cloud-gateway-工作流程-为什么要用灰度发布-如何实现" tabindex="-1"><a class="header-anchor" href="#为什么要有网关-zuul原理-spring-cloud-gateway-工作流程-为什么要用灰度发布-如何实现"><span>为什么要有网关？zuul原理？ Spring Cloud Gateway？工作流程？为什么要用灰度发布？如何实现？</span></a></h2><p>动态路由：反向代理<br> 安全控制：统一认证（支持 HMAC, JWT, Basic, OAuth 2.0等常用协议）和鉴权（权限控制、IP 黑白名单）<br> 协议转换<br> 熔断、限流<br> 灰度发布<br> api组合：可以调用一次网关实现调用两次微服务的功能<br> 请求分析，记录日志<br> 缓存<br> 健康检查<br> 可用性<br> 高性能<br> API版本管理</p><p>作用：API 网关，路由，负载均衡等多种作用。<br> 类似Nginx反向代理的功能<br> 在微服务架构中，后端服务往往不直接开放给调用端，而是通过一个 API网关根据请求的 url ，路由到相应的服务。当添加API网关后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/c5e5a6603d8d79d4509d3.jpg" alt="zuulprinciple.png"></p><p>Route（路由）：定义了请求的匹配规则和转发目标。通过配置路由，可以将请求映射到后端的服务实例或URL上。路由规则可以根据请求的路径、方法、请求头等条件进行匹配，并指定转发的目标URI。<br> Predicate（断言）：断言用于匹配请求的条件，如果请求满足断言的条件，则会应用所配置的过滤器。Spring Cloud Gateway提供了多种内置的断言，如Path（路径匹配）、Method（请求方法匹配）、Header（请求头匹配）等，同时也支持自定义断言。<br> Filter（过滤器）：过滤器用于对请求进行处理和转换，可以修改请求、响应以及执行其他自定义逻辑。Spring Cloud Gateway提供了多个内置的过滤器，如请求转发、请求重试、请求限流等。同时也支持自定义过滤器，可以根据需求编写自己的过滤器逻辑。</p><p><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/eff7e956169c3396d6691.png" alt="springcloudgateway.png"><br> Gateway Handler（网关处理器）：网关处理器是Spring Cloud Gateway的核心组件，负责将请求转发到匹配的路由上。它根据路由配置和断言条件进行路由匹配，选择合适的路由进行请求转发。网关处理器还会依次应用配置的过滤器链，对请求进行处理和转换。<br> Gateway Filter Chain（网关过滤器链）：网关过滤器链由一系列过滤器组成，按照配置的顺序依次执行。每个过滤器可以在请求前、请求后或请求发生错误时进行处理。过滤器链的执行过程可以修改请求、响应以及执行其他自定义逻辑。</p><p>SpringGateway执行流程<br> 接受请求：接收客户端的 HTTP 请求。<br> 寻找路由规则：根据配置的路由规则（如 URI、Header、Path 等），匹配到适合的路由。<br> WEB 过滤器链：触发全局过滤器和 Gateway Filter，进行一些通用的前置处理，例如日志记录、鉴权、限流等。<br> 核心过滤器链执行：核心过滤器执行，比如 RouteToRequestUrlFilter（设置目标地址）、NettyRoutingFilter（将请求路由到目标服务）等。<br> 请求转发到匹配的目标服务<br> 响应回写</p><p>收到目标服务返回的响应后，执行后置过滤器处理（如修改响应数据、记录日志等），然后将响应回写给客户端。</p><p>Gray Release/金丝雀发布：在软件或服务发布过程中，将新版本的功能或服务以较小的比例引入到生产环境中，仅向部分用户或节点提供新功能的一种发布策略。<br> 在传统的全量发布中，新版本的功能会一次性全部部署到所有的用户或节点上。如果新版本存在缺陷或问题，可能会对所有用户或节点产生严重的影响，导致系统崩溃或服务不可用。灰度发布采用较小的规模，并逐步将新版本的功能引入到生产环境中，仅向一小部分用户或节点提供新功能。通过持续监测和评估，可以在发现问题时及时回滚或修复。这种逐步引入新版本的方式可以降低风险，并提高系统的稳定性和可靠性。</p><p>根据用户划分：根据用户标识或用户组进行划分，在整个用户群体中只选择一小部分用户获得新功能。（常用）<br> 根据地域划分：在不同地区或不同节点上进行划分，在其中的一小部分地区或节点进行新功能的发布。<br> 根据流量划分：根据流量的百分比或请求次数进行划分，只将一部分请求流量引导到新功能上。</p><p>前端在灰度测试用户请求头打上标签，例如&quot;grap-tag: true&quot;，而其他则为访问正式服务。<br> 在负载均衡器Spring Cloud LoadBalancer中对请求头&quot;grap-tag&quot;进行判断，如果此标签不为空，并等于&quot;true&quot;时，表示访问灰度发布的服务，否则只访问正式的服务<br> 在网关Spring Cloud Gateway中将Header标签&quot;grap-tag: true&quot;继续往下一个调用服务中传递<br> 关键思路<br> 注册中心区分正常服务和灰度服务；<br> 负载均衡正确转发正常服务和灰度服务；<br> 网关和 HTTP 工具传递灰度标签。</p><details><summary>区分正式服务和灰度服务</summary><p>在灰度服务既注册中心的MetaData（元数据）中标识为灰度服务，而元数据中没有标识（灰度服务）的则为正式服务，以Nacos为例</p><div class="language-yaml line-numbers-mode" data-ext="yml" data-title="yml"><pre class="language-yaml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> canary<span class="token punctuation">-</span>user<span class="token punctuation">-</span>service
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">username</span><span class="token punctuation">:</span> nacos
        <span class="token key atrule">password</span><span class="token punctuation">:</span> nacos
        <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>
        <span class="token key atrule">namespace</span><span class="token punctuation">:</span> public
        <span class="token key atrule">register-enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> 
        <span class="token key atrule">metadata</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> &quot;grap<span class="token punctuation">-</span>tag&quot;<span class="token punctuation">:</span><span class="token string">&quot;true&quot;</span> <span class="token punctuation">}</span> <span class="token comment"># 标识自己为灰度服务</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details><summary>负载均衡Spring Cloud LoadBalancer 判断并调用灰度服务</summary><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">//自定义负载均衡器，并使用轮询算法。如果Header中有灰度标签，则只查询灰度服务的节点实例，否则则查询出所有的正式节点实例（以供服务调用或服务转发）</span>
<span class="token keyword">private</span> <span class="token class-name">Response</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ServiceInstance</span><span class="token punctuation">&gt;</span></span> <span class="token function">getInstanceResponse</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ServiceInstance</span><span class="token punctuation">&gt;</span></span> instances<span class="token punctuation">,</span><span class="token class-name">Request</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 实例为空</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instances<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>log<span class="token punctuation">.</span><span class="token function">isWarnEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            log<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token string">&quot;No servers available for service: &quot;</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>serviceId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">EmptyResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 服务不为空</span>
        <span class="token class-name">RequestDataContext</span> dataContext <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">RequestDataContext</span><span class="token punctuation">)</span> request<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">HttpHeaders</span> headers <span class="token operator">=</span> dataContext<span class="token punctuation">.</span><span class="token function">getClientRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 判断是否为灰度发布（请求）</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>headers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">GlobalVariables</span><span class="token punctuation">.</span><span class="token constant">GRAY_KEY</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                headers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">GlobalVariables</span><span class="token punctuation">.</span><span class="token constant">GRAY_KEY</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 灰度发布请求，得到新服务实例列表</span>
            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ServiceInstance</span><span class="token punctuation">&gt;</span></span> findInstances <span class="token operator">=</span> instances<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
                    <span class="token function">filter</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> s<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">GlobalVariables</span><span class="token punctuation">.</span><span class="token constant">GRAY_KEY</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>
                            s<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">GlobalVariables</span><span class="token punctuation">.</span><span class="token constant">GRAY_KEY</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>findInstances<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 存在灰度发布节点</span>
                instances <span class="token operator">=</span> findInstances<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 查询非灰度发布节点</span>
            <span class="token comment">// 灰度发布测试请求，得到新服务实例列表</span>
            instances <span class="token operator">=</span> instances<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
                    <span class="token function">filter</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> s<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">GlobalVariables</span><span class="token punctuation">.</span><span class="token constant">GRAY_KEY</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span>
                            <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">getMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">GlobalVariables</span><span class="token punctuation">.</span><span class="token constant">GRAY_KEY</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;true&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 随机正数值 ++i（ &amp; 去负数）</span>
        <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>position<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span><span class="token punctuation">;</span>
        <span class="token comment">// ++i 数值 % 实例数 取模 -&gt; 轮询算法</span>
        <span class="token keyword">int</span> index <span class="token operator">=</span> pos <span class="token operator">%</span> instances<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 得到服务实例方法</span>
        <span class="token class-name">ServiceInstance</span> instance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServiceInstance</span><span class="token punctuation">)</span> instances<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DefaultResponse</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details><summary>网关传递灰度标识</summary><ul><li>要在网关 Spring Cloud Gateway 中传递灰度标识，只需要在 Gateway 的全局自定义过滤器中设置 Response 的 Header 即可，具体实现代码如下：package com.example.gateway.config;</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>import com.loadbalancer.canary.common.GlobalVariables;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component
public class LoadBalancerFilter implements GlobalFilter {
    @Override
    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        // 得到 request、response 对象
        ServerHttpRequest request = exchange.getRequest();
        ServerHttpResponse response = exchange.getResponse();
        if (request.getQueryParams().getFirst(GlobalVariables.GRAY_KEY) != null) {
            // 设置金丝雀标识
            response.getHeaders().set(GlobalVariables.GRAY_KEY,
                    &quot;true&quot;);
        }
        // 此步骤正常，执行下一步
        return chain.filter(exchange);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><details><summary>Openfeign 传递灰度标签HTTP </summary><ul><li>调用工具 Openfeign 传递灰度标签的实现代码如下：</li></ul><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">import</span> <span class="token import"><span class="token namespace">feign<span class="token punctuation">.</span></span><span class="token class-name">RequestInterceptor</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">feign<span class="token punctuation">.</span></span><span class="token class-name">RequestTemplate</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">jakarta<span class="token punctuation">.</span>servlet<span class="token punctuation">.</span>http<span class="token punctuation">.</span></span><span class="token class-name">HttpServletRequest</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>context<span class="token punctuation">.</span>request<span class="token punctuation">.</span></span><span class="token class-name">RequestContextHolder</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>context<span class="token punctuation">.</span>request<span class="token punctuation">.</span></span><span class="token class-name">ServletRequestAttributes</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Enumeration</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedHashMap</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span></span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FeignRequestInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">RequestInterceptor</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">apply</span><span class="token punctuation">(</span><span class="token class-name">RequestTemplate</span> template<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 从 RequestContextHolder 中获取 HttpServletRequest</span>
        <span class="token class-name">ServletRequestAttributes</span> attributes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ServletRequestAttributes</span><span class="token punctuation">)</span>
                <span class="token class-name">RequestContextHolder</span><span class="token punctuation">.</span><span class="token function">getRequestAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 获取 RequestContextHolder 中的信息</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> headers <span class="token operator">=</span> <span class="token function">getHeaders</span><span class="token punctuation">(</span>attributes<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 放入 openfeign 的 RequestTemplate 中</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> entry <span class="token operator">:</span> headers<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            template<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token doc-comment comment">/**
     * 获取原请求头
     */</span>
    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">getHeaders</span><span class="token punctuation">(</span><span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Enumeration</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> enumeration <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeaderNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>enumeration <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>enumeration<span class="token punctuation">.</span><span class="token function">hasMoreElements</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">String</span> key <span class="token operator">=</span> enumeration<span class="token punctuation">.</span><span class="token function">nextElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">String</span> value <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">getHeader</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> map<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><h2 id="链路追踪-为什么要链路追踪-skywalking-spring-cloud-sleuth原理" tabindex="-1"><a class="header-anchor" href="#链路追踪-为什么要链路追踪-skywalking-spring-cloud-sleuth原理"><span>链路追踪？为什么要链路追踪？SkyWalking？Spring Cloud Sleuth原理</span></a></h2><p>可以可视化地追踪请求从一个微服务到另一个微服务的调用情况。除了排查问题，链路追踪还可以帮助优化性能，可视化依赖关系、服务监控和告警</p><figure><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/bc82ce3be04420eac161e.jpg" alt="sleuthprinciple.png" tabindex="0"><figcaption>sleuthprinciple.png</figcaption></figure><h2 id="seata-支持哪些模式的分布式事务-实现原理-事务执行流程-全局事务id和分支事务id是怎么传递的-事务回滚是怎么实现的" tabindex="-1"><a class="header-anchor" href="#seata-支持哪些模式的分布式事务-实现原理-事务执行流程-全局事务id和分支事务id是怎么传递的-事务回滚是怎么实现的"><span>Seata？支持哪些模式的分布式事务？实现原理？事务执行流程？全局事务ID和分支事务ID是怎么传递的？事务回滚是怎么实现的？</span></a></h2><p>从业务无侵入的两阶段提交（全局事务）着手，在传统的两阶段上进行改进，把一个分布式事务理解成一个包含了若干分支事务的全局事务。而全局事务的职责是协调它管理的分支事务达成一致性，要么一起成功提交，要么一起失败回滚<br> AT（Atomikos）模式：默认。在业务代码中嵌入事务上下文，拦截并解析业务代码中的SQL语句，通过对数据库连接进行拦截和代理，实现事务的管理和协调。<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/e0a2b3f17439791ef0e97.png" alt="seataat1.png"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/f1c2597a611a4bcf6a468.png" alt="seataat2.png"><br> TCC（Try-Confirm-Cancel）模式：基于补偿机制的分布式事务模式。业务逻辑需要实现Try、Confirm和Cancel三个阶段的操作。通过调用业务代码中的Try、Confirm和Cancel方法，并在每个阶段记录相关的操作日志<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/e3a492135cfb1b9a68369.png" alt="seatatcc.png"><br> SAGA模式：基于事件驱动的分布式事务模式。每个服务都可以发布和订阅事件，通过事件的传递和处理来实现分布式事务的一致性。Seata提供了与SAGA模式兼容的Saga框架，用于管理和协调分布式事务的各个阶段。<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/264d940d050468301c1fa.png" alt="seatasaga.png"><br> XA模式：基于两阶段提交（Two-Phase Commit）协议的分布式事务模式。通过与数据库的XA事务协议进行交互，实现对分布式事务的管理和协调。需要数据库本身支持XA事务，并且需要配置相应的数据源<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/dbae39b1c21075990c42e.png" alt="seataxa.png"></p><ul><li>你们公司是如何处理分布式事务的？ <ul><li>我们某某特别严格的场景，用的是 TCC 来保证强一致性。</li><li>其他场基于阿里的 RocketMQ 来实现了分布式事务。如果是一般的分布式事务场景，订单插入之后要调用库存服务更新库存，库存数据没有资金那么的敏感，可以用可靠消息最终一致性方案。</li><li>基于seata的AT模式，有undolog</li></ul></li><li>一阶段:业务数据和回滚日志记录UNDO LOG在同一个本地事务中提交，释放本地锁和连接资源</li><li>二阶段:提交异步化，非常快速地完成。回滚通过一阶段的回滚日志进行反向补偿。</li></ul><p>主要包括三个核心组件<br> 事务协调器TC（Transaction Coordinator）：负责协调和管理分布式事务的整个过程。管理全局的分支事务的状态，用于全局性事务的提交和回滚。它接收事务的开始和结束请求，并根据事务的状态进行协调和处理。还负责记录和管理事务的全局事务 ID（Global Transaction ID）和分支事务 ID（Branch Transaction ID）。<br> 事务管理器TM（Transaction Manager）：用于开启、提交或回滚事务。负责全局事务的管理和控制。它协调各个分支事务的提交或回滚，并保证分布式事务的一致性和隔离性。还负责与事务协调器进行通信，并将事务的状态变更进行持久化。<br> 资源管理器RM（Resource Manager）：负责管理和控制各个参与者（Participant）的事务操作。它与事务管理器进行通信，并根据事务管理器的指令执行相应的事务操作，包括提交和回滚。用于分支事务上的资源管理，向TC注册分支事务，上报分支事务的状态，接收TC的命令来提交或者回滚分支事务。<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/0456accaa69ce5192fac9.png" alt="seatamodel.png"></p><p>基于两阶段提交（Two-Phase Commit）协议执行机制：<br> 一阶段：预提交。事务协调器TC向各个资源管理器发送预提交请求，资源管理器RM执行相应的事务操作并返回执行结果。业务数据和回滚日志记录在同一个本地事务中提交，并释放本地锁和连接资源。<br> 二阶段：真正提交。包括两个步骤：<br> 提交异步化：事务协调器发出提交请求，各个资源管理器提交。<br> 回滚反向补偿：如果在预提交阶段中有任何一个资源管理器返回失败结果，TC出回滚请求，各个RM回滚，利用一阶段的回滚日志进行反向补偿</p><p>事务发起方（Transaction Starter发起分布式事务的服务）发起全局事务：向Seata的事务协调器TC申请开启全局事务，生成全局事务ID（Global Transaction ID）。<br> 事务协调器TC创建全局事务记录：并生成分支事务ID（Branch Transaction ID）。<br> 分支事务注册：事务发起方将全局事务ID和分支事务ID发送给各个参与者（Participant），即资源管理器。参与者将分支事务ID注册到本地事务管理器，并将事务的执行结果反馈给事务协调器。<br> 执行业务逻辑：在分布式事务的上下文中，各个参与者执行各自的本地事务，即执行业务逻辑和数据库操作。<br> 预提交阶段：事务发起方向事务协调器发送预提交请求，事务协调器将预提交请求发送给各个参与者。<br> 执行本地事务确认：参与者接收到预提交请求后，执行本地事务的确认操作，并将本地事务的执行结果反馈给事务协调器。<br> 全局事务提交或回滚：事务协调器根据参与者反馈的结果进行判断，如果所有参与者的本地事务都执行成功，事务协调器发送真正的提交请求给参与者，参与者执行最终的提交操作；如果有任何一个参与者的本地事务执行失败，事务协调器发送回滚请求给参与者，参与者执行回滚操作。<br> 完成全局事务：事务协调器TC接收到参与者的提交或回滚结果后，根据结果更新全局事务的状态，并通知事务发起方全局事务的最终结果。</p><figure><img src="https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQe85d4b33946c0c9e11eb23fbf057d877.png" alt="seata.png" tabindex="0"><figcaption>seata.png</figcaption></figure><p>通过上下文传递的方式进行传递。传递方式包括参数传递、线程上下文传递和消息中间件传递。可根据业务场景和技术选型进行选择和调整。</p><p>通过回滚日志。每个参与者在执行本地事务期间生成回滚日志，记录了对数据的修改操作，参与者根据回滚日志中的信息执行撤销操作，将数据恢复到事务开始前的状态。<br> 可以将日志存储在不同的介质中。通过回滚日志的持久化和恢复，确保事务的一致性和恢复性</p><h2 id="监控和告警" tabindex="-1"><a class="header-anchor" href="#监控和告警"><span>监控和告警？</span></a></h2><p>Prometheus：开源的监控系统，具有灵活的数据模型和强大的查询语言，能够收集和存储时间序列数据。它可以通过HTTP协议定期拉取微服务的指标数据，并提供可扩展的存储和查询功能。<br> Grafana：开源的可视化仪表板工具，与 Prometheus 结合使用，创建实时和历史数据的仪表板。Grafana 提供了丰富的图表和可视化选项，可以帮助用户更好地理解和分析微服务的性能和状态。</p><h2 id="日志收集" tabindex="-1"><a class="header-anchor" href="#日志收集"><span>日志收集？</span></a></h2><p>ELK<br> Elasticsearch：分布式搜索和分析引擎，用于存储和索引大量的日志数据。它提供了快速的搜索和聚合功能，可以高效地处理大规模的日志数据。<br> Logstash：用于收集、过滤和转发日志数据的工具。它可以从各种来源（如文件、网络、消息队列等）收集日志数据，并对数据进行处理和转换，然后将其发送到Elasticsearch进行存储和索引。<br> Kibana：用于日志数据可视化和分析的工具。它提供了丰富的图表、仪表盘和搜索功能，可以帮助用户实时监控和分析日志数据，发现潜在的问题和趋势。</p><p>Elasticsearch提供数据存储和检索能力，Logstash负责将日志收集到ES，Kibana负责日志数据的可视化分析。<br> 使用ELK进行微服务日志收集的一般流程如下：</p><p><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/3f959676d10750e5c8902.png" alt="elk.png"><br> 在每个微服务中配置日志输出：将微服务的日志输出到标准输出（stdout）或日志文件。<br> 使用Logstash收集日志：配置Logstash收集器，通过配置输入插件（如文件输入、网络输入等）监听微服务的日志输出，并进行过滤和处理。<br> 将日志数据发送到Elasticsearch：配置Logstash的输出插件，将经过处理的日志数据发送到Elasticsearch进行存储和索引。<br> 使用Kibana进行可视化和分析：通过Kibana连接到Elasticsearch，创建仪表盘、图表和搜索查询，实时监控和分析微服务的日志数据。<br> 除了应用最广泛的ELK，还有一些其它的方案比如Fluentd、Graylog、Loki、Filebeat，一些云厂商也提供了付费方案，比如阿里云的sls。</p></div><!--[--><!----><!--]--><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/HeChuangJun/notes/edit/main/docs/interview/framework/springcloud.md" rel="noopener noreferrer" target="_blank" aria-label="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><!----><!----></div></footer><nav class="vp-page-nav"><a class="route-link nav-link prev" href="/interview/framework/springboot.html" aria-label="Spring Boot"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon iconfont icon-bxl-spring-boot" style=""></span>Spring Boot</div></a><a class="route-link nav-link next" href="/interview/framework/mybatis.html" aria-label="MyBatis"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">MyBatis<span class="font-icon icon iconfont icon-bxl-spring-boot" style=""></span></div></a></nav><!----><!--[--><!----><!--]--><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer"><a href="https://beian.miit.gov.cn/" target="_blank">鄂ICP备2020015769号-1</a></div><div class="vp-copyright">Copyright © 2025 HeChuangJun </div></footer></div><!--]--><!--]--><!--[--><!--[--><!--]--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-7KT7HDzT.js" defer></script>
  </body>
</html>
