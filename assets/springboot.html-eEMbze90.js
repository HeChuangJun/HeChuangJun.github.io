import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as t,e as n}from"./app-7KT7HDzT.js";const a={},r=n(`<h1 id="_1-springboot优缺点" tabindex="-1"><a class="header-anchor" href="#_1-springboot优缺点"><span>1. springboot优缺点？</span></a></h1><ul><li><p>√快速构建项目，通过 Intellij IDEA 或者官方的 Spring Initializr 就可以快速创建新项目</p></li><li><p>√自动配置:提供了一系列的 Starter,对主流框架的无配置集成</p></li><li><p>√项目独立运行，内嵌servlet容器Tomcat、Jetty 或者 Undertow</p></li><li><p>提供运行时应用监控。Spring Boot 提供基于 HTTP、JMX、SSH 对运行时的项目进行监控。</p></li><li><p>极大地提高了开发、部署效率</p></li><li><p>因为自动配置 Spring Bean 的功能，我们可能无法知道，哪些 Bean 被进行创建了。这个时候，如果我们想要自定义一些 Bean ，可能存在冲突，或者不知道实际注入的情况。</p></li></ul><h1 id="_2-如何统一引入spring-boot版本" tabindex="-1"><a class="header-anchor" href="#_2-如何统一引入spring-boot版本"><span>2. 如何统一引入Spring Boot版本？</span></a></h1><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>方式1.继承 spring-boot-starter-parent 项目，容易与别的项目冲突
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;
&lt;/parent&gt;
方式2.导入 spring-boot-dependencies 项目依赖，比较自由
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
            &lt;version&gt;1.5.1.RELEASE&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_3-spring-boot-有哪些配置方式" tabindex="-1"><a class="header-anchor" href="#_3-spring-boot-有哪些配置方式"><span>3. Spring Boot 有哪些配置方式？</span></a></h1><ul><li>XML 配置文件。<code>&lt;bean&gt;</code></li><li>注解配置。@Component</li><li>Java Config 配置。使用 @Bean 和 @Configuration</li></ul><h1 id="_4-spring-boot-有哪几种读取配置的方式" tabindex="-1"><a class="header-anchor" href="#_4-spring-boot-有哪几种读取配置的方式"><span>4. Spring Boot 有哪几种读取配置的方式？</span></a></h1><ul><li>@Value注解，读取配置到属性。支持和 @PropertySource注解一起使用，指定使用的配置文件。</li><li>@ConfigurationProperties注解，读取配置到类上。支持和@PropertySource注解一起使用，指定使用的配置文件。</li></ul><h1 id="_5-bootstrap-properties和application-properties有何区别" tabindex="-1"><a class="header-anchor" href="#_5-bootstrap-properties和application-properties有何区别"><span>5. bootstrap.properties和application.properties有何区别?</span></a></h1><ul><li>bootstrap(.yml/.properties)：由父ApplicationContext加载，比applicaton优先加载，配置在应用程序上下文的引导阶段生效。在SpringCloud Config或者Nacos中会用到。且属性不能被覆盖；</li><li>application(.yml/.properties)：由ApplicatonContext加载，用于项目的自动化配置。</li></ul><h1 id="_6-springboot中如何解决跨域问题" tabindex="-1"><a class="header-anchor" href="#_6-springboot中如何解决跨域问题"><span>6. SpringBoot中如何解决跨域问题 ?</span></a></h1><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping(&quot;/**&quot;)
                .allowedOrigins(&quot;*&quot;)
                .allowCredentials(true)
                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;OPTIONS&quot;)
                .maxAge(3600);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_7-springboot配置文件读取顺序-√" tabindex="-1"><a class="header-anchor" href="#_7-springboot配置文件读取顺序-√"><span>7. springboot配置文件读取顺序？√</span></a></h1><ul><li><p>config/application.properties|yml（项目根目录中config目录下）</p></li><li><p>application.properties|yml（项目根目录下）</p></li><li><p>resources/config/application.properties|yml（项目resources目录中config目录下）</p></li><li><p>resources/application.properties|yml（项目的resources目录下）</p></li><li><p>如果同一个目录下，默认先读取application.properties。然后application.yml</p></li><li><p>如果同一个配置属性，默认使用第1个读取到的</p></li><li><p>配置文件放置在项目的resources目录下，因为配置文件的修改，通过热部署不用重新启动项目，热部署作用范围是classpath下</p></li></ul><h1 id="_8-springboot实现将配置文件放到classpath-那么所有的文件将不受所放位置的影响" tabindex="-1"><a class="header-anchor" href="#_8-springboot实现将配置文件放到classpath-那么所有的文件将不受所放位置的影响"><span>8. springboot实现将配置文件放到classpath，那么所有的文件将不受所放位置的影响</span></a></h1><ul><li>Xbootclasspath/a:与路径无空格 路径为同jar路径下的config文件，此时所有的配置文件都会像classpath一样加载</li><li>java -Xbootclasspath/a:/config/ -jar testspringbootMybaits-0.0.1-SNAPSHOT.jar注意此时的配置文件会覆盖原来的配置！！！！！！</li><li>/config/根目录，config/相对当前目录</li><li>jar包指定编码启动 java -Dfile.encoding=utf-8 -jar test.jar</li></ul><h1 id="_9-springboot-自动配置原理、-enableautoconfiguration实现原理" tabindex="-1"><a class="header-anchor" href="#_9-springboot-自动配置原理、-enableautoconfiguration实现原理"><span>9. SpringBoot 自动配置原理、@EnableAutoConfiguration实现原理</span></a></h1><ul><li>@SpringBootApplication注解包含了@EnableAutoConfiguration，@Configuration（指定类是 Bean 定义的配置类），@ComponentScan(扫描指定包下的 Bean),而@EnableAutoConfiguration(打开自动配置功能)使用了@Import({AutoConfigurationImportSelector.class}) 而AutoConfigurationImportSelector，使用ImportSelector接口的selectImports方法加载META-INF/spring.factories文件的信息org.springframework.boot.autoconfigure.EnableAutoConfiguration=，封装成beanName，加载到IOC容器中，实现自动配置功能</li><li>SpringBoot在启动时扫描项目所依赖的jar包，寻找包含spring.factories文件的jar</li><li>根据spring.factories配置加载AutoConfigure类</li><li>根据[@Conditional 等条件注解](Spring Boot 条件注解) 的条件，进行自动配置并将Bean注入Spring IoC中</li></ul><h1 id="如何自定义一个springboot-srarter" tabindex="-1"><a class="header-anchor" href="#如何自定义一个springboot-srarter"><span>如何自定义一个SpringBoot Srarter?</span></a></h1><ul><li>引入 SpringBoot 相关依赖</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>编写配置文件:定义了属性配置的前缀</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>@ConfigurationProperties(prefix = &quot;hello&quot;)
public class HelloProperties {
    private String name;
    //省略getter、setter
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>自动装配</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>@Configuration
@EnableConfigurationProperties(HelloProperties.class)
public class HelloPropertiesConfigure {
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>配置自动类:在/resources/META-INF/spring.factories文件中添加自动配置类路径</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\
    cn.fighter3.demo.starter.configure.HelloPropertiesConfigure

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="springboot-启动原理" tabindex="-1"><a class="header-anchor" href="#springboot-启动原理"><span>Springboot 启动原理？</span></a></h1><ul><li>SpringApplication这个类主要做了以下四件事情： <ul><li>推断应用的类型是普通的项目还是 Web 项目</li><li>查找并加载所有可用初始化器 ， 设置到 initializers 属性中</li><li>找出所有的应用程序监听器，设置到 listeners 属性中</li><li>推断并设置 main 方法的定义类，找到运行的主类<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/4c9e3994321ee4a06a9e5.png" alt="springbootstart.png"></li></ul></li><li>为什么SpringBoot在启动的时候能够找到main方法上的@SpringBootApplication注解？</li><li>因为它利用了Java的反射机制和类加载机制，SpringApplication.run(Class&lt;?&gt;primarySource,String...args)方法接收两个参数：第一个是主应用类（即包含main方法的类），第二个是命令行参数。primarySource参数提供了一个起点，SpringBoot通过它来加载应用上下文。</li><li>SpringBoot利用Java反射机制来读取传递给run方法的类（MyApplication.class）。它会检查这个类上的注解，包括@SpringBootApplication。</li></ul><h1 id="spring-boot-默认的包扫描路径是什么" tabindex="-1"><a class="header-anchor" href="#spring-boot-默认的包扫描路径是什么"><span>Spring Boot 默认的包扫描路径是什么？</span></a></h1><ul><li>以启动类 @SpringBootApplication 注解所在的包为根目录的，默认情况会扫描启动类所在包及其子包下的所有组件。</li></ul>`,31),o=[r];function l(s,p){return i(),t("div",null,o)}const g=e(a,[["render",l],["__file","springboot.html.vue"]]),u=JSON.parse('{"path":"/interview/springboot.html","title":"springboot","lang":"zh-CN","frontmatter":{"title":"springboot","date":"2023-01-01T00:00:00.000Z","tags":"java","categories":"面试","description":"1. springboot优缺点？ √快速构建项目，通过 Intellij IDEA 或者官方的 Spring Initializr 就可以快速创建新项目 √自动配置:提供了一系列的 Starter,对主流框架的无配置集成 √项目独立运行，内嵌servlet容器Tomcat、Jetty 或者 Undertow 提供运行时应用监控。Spring Boot...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/interview/springboot.html"}],["meta",{"property":"og:site_name","content":"JavaGuide"}],["meta",{"property":"og:title","content":"springboot"}],["meta",{"property":"og:description","content":"1. springboot优缺点？ √快速构建项目，通过 Intellij IDEA 或者官方的 Spring Initializr 就可以快速创建新项目 √自动配置:提供了一系列的 Starter,对主流框架的无配置集成 √项目独立运行，内嵌servlet容器Tomcat、Jetty 或者 Undertow 提供运行时应用监控。Spring Boot..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://290ff162.telegraph-image-eg9.pages.dev/file/4c9e3994321ee4a06a9e5.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-07T01:56:33.000Z"}],["meta",{"property":"article:author","content":"HeChuangJun"}],["meta",{"property":"article:published_time","content":"2023-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-07T01:56:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"springboot\\",\\"image\\":[\\"https://290ff162.telegraph-image-eg9.pages.dev/file/4c9e3994321ee4a06a9e5.png\\"],\\"datePublished\\":\\"2023-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-07T01:56:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeChuangJun\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[],"git":{"createdTime":1733536593000,"updatedTime":1733536593000,"contributors":[{"name":"HeChuangJun","email":"1105128664@qq.com","commits":1}]},"readingTime":{"minutes":4.26,"words":1279},"filePathRelative":"interview/springboot.md","localizedDate":"2023年1月1日","excerpt":"<!-- TOC -->\\n<!-- /TOC -->\\n<h1>1. springboot优缺点？</h1>\\n<ul>\\n<li>\\n<p>√快速构建项目，通过 Intellij IDEA 或者官方的 Spring Initializr 就可以快速创建新项目</p>\\n</li>\\n<li>\\n<p>√自动配置:提供了一系列的 Starter,对主流框架的无配置集成</p>\\n</li>\\n<li>\\n<p>√项目独立运行，内嵌servlet容器Tomcat、Jetty 或者 Undertow</p>\\n</li>\\n<li>\\n<p>提供运行时应用监控。Spring Boot 提供基于 HTTP、JMX、SSH 对运行时的项目进行监控。</p>\\n</li>\\n<li>\\n<p>极大地提高了开发、部署效率</p>\\n</li>\\n<li>\\n<p>因为自动配置 Spring Bean 的功能，我们可能无法知道，哪些 Bean 被进行创建了。这个时候，如果我们想要自定义一些 Bean ，可能存在冲突，或者不知道实际注入的情况。</p>\\n</li>\\n</ul>","autoDesc":true}');export{g as comp,u as data};
