import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e}from"./app-7KT7HDzT.js";const t={},o=e(`<h2 id="_1-数据库三大范式-varchar与char、blob和text区别-datetime和timestamp异同-存储货币、ip、emoji😊" tabindex="-1"><a class="header-anchor" href="#_1-数据库三大范式-varchar与char、blob和text区别-datetime和timestamp异同-存储货币、ip、emoji😊"><span>.1. 数据库三大范式？varchar与char、blob和text区别？DATETIME和TIMESTAMP异同？存储货币、ip、emoji😊？</span></a></h2><p>第一范式1NF：字段值具有原子性，不能再分。姓名字段如果区分姓和名则分为两个字段<br> 第二范式2NF：满足第一范式基础上，表中每一列都和全部主键相关，而不能只与一部分主键相关（联合主键）。订单表的商品价格只与商品ID相关，与订单ID无关<br> 第三范式3NF：满足第二范式基础上，表中每一列都和主键直接相关，而不能间接相关。订单表的订单编号和商品编号，商品名称与商品ID相关再与订单相关，应拆分为订单表、订单商品关联表、商品表<br> 控制数据冗余，节省空间，可冗余数据，空间换时间，避免跨表跨库查询，提高性能</p><p>char长度固定；varchar长度不固定<br> char插入数据的长度小于固定长度时用空格填充，会删除插入数据的尾部空格；VARCHAR按照插入的数据长度来存储，不会删除尾部空格<br> 因为长度固定，char存取速度要比varchar快，可能浪费空间，空间换时间；因为长度不固定，varchar比char存取慢，不浪费空间，时间换空间<br> char最多存255个字符与字符集无关，字节数与字符集有关，因为不同字符集对字符的编码字节数不同；varchar最多存65532个字节，包括小于等于255个字符用1个、否则2个字节存储字符串的长度信息，字符数与字符集有关<br> varchar(50)最多存50个字符。varchar(50)和(200)在相同字符数时字节数一样，但VARCHAR(200)在长度信息部分会多1个字节，排序时消耗更多内存<br> 对于长度相对固定的字符串使用char，对于长度不确定使用varchar</p><p>都用于保存大文本<br> blob用于存储二进制数据，比如照片；text用于存储大字符串。比如文章<br> blob没有字符集，text有字符集，并且根据字符集的校对规则对值进行排序和比较</p><p>同：存储时间的表现格式一致YYYY-MM-DD HH:MM:SS；能存储微秒（秒后6位小数秒）<br> 异<br> DATETIME的日期范围是1000-01-0100:00:00.000000到9999-12-31 23:59:59.999999；TIMESTAMP 1970-01-0100:00:01.000000UTC到2038-01-0903:14:07.999999UTC<br> DATETIME存储空间为8字节；4字节<br> DATETIME存储时间与时区无关；有关<br> DATETIME默认值为null；TIMESTAMP不为空，默认当前时间(CURRENT_TIMESTAMP)<br><code>范默大时</code></p><p>Decimal和Numric，字符串存储保存小数精度。如DECIMAL(9,2)，9代表将总的小数位数，2代表小数点后的位数。存储范围从-9999999.99到9999999.99，float和double以二进制存储存在误差<br> bigint</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> sessions <span class="token punctuation">(</span>ipaddress<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>inet_aton<span class="token punctuation">(</span><span class="token string">&#39;192.168.0.1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> inet_ntoa<span class="token punctuation">(</span>ipaddress<span class="token punctuation">)</span> <span class="token keyword">FROM</span> sessions<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">from</span> t <span class="token keyword">WHERE</span> inet_aton<span class="token punctuation">(</span>ip<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> inet_aton<span class="token punctuation">(</span><span class="token string">&#39;192.168.1.3&#39;</span><span class="token punctuation">)</span> 
<span class="token operator">AND</span> inet_aton<span class="token punctuation">(</span>ip<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> inet_aton<span class="token punctuation">(</span><span class="token string">&#39;192.168.1.20&#39;</span><span class="token punctuation">)</span>
字符串，使用<span class="token number">4</span>字节的utf8mb4编码
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> blogs <span class="token keyword">modify</span> content <span class="token keyword">text</span> <span class="token keyword">CHARACTER</span> 
<span class="token keyword">SET</span> utf8mb4 <span class="token keyword">COLLATE</span> utf8mb4_unicode_ci <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-sql分类、查第3-10条、sql执行顺序-√内连接、左连接、右连接、交叉连接、笛卡尔积区别-in-exists-delete、truncate-drop-union-union-all-count-1-、count-、count-主键-列名-区别-函数-sql的隐式数据类型转换" tabindex="-1"><a class="header-anchor" href="#_2-sql分类、查第3-10条、sql执行顺序-√内连接、左连接、右连接、交叉连接、笛卡尔积区别-in-exists-delete、truncate-drop-union-union-all-count-1-、count-、count-主键-列名-区别-函数-sql的隐式数据类型转换"><span>.2. SQL分类、查第3-10条、SQL执行顺序？√内连接、左连接、右连接、交叉连接、笛卡尔积区别？in/exists，delete、truncate/drop，UNION/UNION ALL，count(1)、count(*)、count(主键|列名)区别？函数,SQL的隐式数据类型转换？</span></a></h2><p>Structure Query Language结构化查询语言<br> Data Definition Languages定义数据段、数据库、表、列、索引等数据库对象create、alter、drop<br> Data Manipulation操纵 Language 添加、删除、更新和查询数据库记录insert、delete、update<br> Data Query Language查询数据表的记录select<br> Data Control Language 定义数据库、表、字段、用户的访问权限和安全级别grant、revoke</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">## 创建数据库</span>
<span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> 数据库名 <span class="token punctuation">[</span><span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">COLLATE</span> 校对规则<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">## 查看所有数据库/表/数据库详细说明(编码)</span>
<span class="token keyword">SHOW</span> <span class="token keyword">DATABASES</span><span class="token punctuation">;</span>
<span class="token keyword">SHOW</span> <span class="token keyword">TABLES</span><span class="token punctuation">;</span>
<span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> 数据库名<span class="token punctuation">;</span>

<span class="token comment">## 选择/查看操作的数据库</span>
<span class="token keyword">USE</span> 数据库名<span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token keyword">DATABASE</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">## 改变数据库的全局特性</span>
<span class="token keyword">ALTER</span> <span class="token keyword">DATABASE</span> 数据库名 <span class="token punctuation">[</span><span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">COLLATE</span> 校对规则<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">## 删除数据库</span>
<span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> 数据库名<span class="token punctuation">;</span>

<span class="token comment">## 创建表/MEMORY表/MERGE表</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">(</span>列名 数据类型<span class="token punctuation">(</span>长度<span class="token punctuation">)</span><span class="token punctuation">[</span>约束<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token keyword">ENGINE</span><span class="token operator">=</span>存储引擎<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> 字符集<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">COLLATE</span> 校对规则<span class="token punctuation">]</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ENGINE</span><span class="token operator">=</span>MEMORY <span class="token keyword">select</span>子句
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">(</span>列名 类型<span class="token punctuation">(</span>长度<span class="token punctuation">)</span><span class="token punctuation">[</span>约束<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> 
<span class="token keyword">engine</span><span class="token operator">=</span><span class="token keyword">merge</span> <span class="token keyword">union</span><span class="token operator">=</span><span class="token punctuation">(</span>表名<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>INSERT_METHOD<span class="token operator">=</span><span class="token keyword">LAST</span><span class="token operator">|</span><span class="token keyword">FIRST</span><span class="token operator">|</span><span class="token keyword">NO</span><span class="token punctuation">]</span>

<span class="token comment">## 查看表定义/建表sql</span>
DES 表名<span class="token punctuation">;</span>
<span class="token keyword">SHOW</span> <span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">;</span>

<span class="token comment">## 删除表</span>
<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">;</span>
<span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> 表名<span class="token punctuation">;</span>

<span class="token comment">## 增加表字段</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">ADD</span> 列名 类型（长度）<span class="token punctuation">[</span>约束<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">FIRST</span> <span class="token operator">|</span> <span class="token keyword">AFTER</span> 列名<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">## 修改表字段类型(长度)[约束]/改整个字段</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">MODIFY</span> 列名 类型<span class="token punctuation">(</span>长度<span class="token punctuation">)</span><span class="token punctuation">[</span>约束<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token keyword">FIRST</span> <span class="token operator">|</span> <span class="token keyword">AFTER</span> 列名<span class="token punctuation">]</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 CHANGE  旧列名 新列名 类型<span class="token punctuation">(</span>长度<span class="token punctuation">)</span><span class="token punctuation">[</span>约束<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">FIRST</span> <span class="token operator">|</span> <span class="token keyword">AFTER</span> 列名<span class="token punctuation">]</span>

<span class="token comment">## 删除字段</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">DROP</span> 列名<span class="token punctuation">;</span>

<span class="token comment">## 改表名/字符集</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 旧表名 <span class="token keyword">RENAME</span> 新表名<span class="token punctuation">;</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 表名 <span class="token keyword">character</span> <span class="token keyword">set</span> 字符集<span class="token punctuation">;</span>

<span class="token comment">## 增加外键/删外键</span>
<span class="token comment">## \`RESTRICT\`和\`NO ACTION\`限制在子表有关联记录的情况下主表不能更新；</span>
<span class="token comment">## \`CASCADE\`主表在更新或者删除时，更新或者删除子表对应记录；</span>
<span class="token comment">## \`SET NULL\`表示主表在更新或者删除的时候，子表的对应字段被 \`SET NULL\`</span>

<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 子表 <span class="token keyword">add</span> <span class="token keyword">constraint</span> 外键名以_fk结尾 <span class="token keyword">foreign</span> <span class="token keyword">key</span> <span class="token punctuation">(</span>子表外键列名<span class="token punctuation">)</span> 
<span class="token keyword">references</span> 主表<span class="token punctuation">(</span>主键<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">ON</span> <span class="token keyword">DELETE</span><span class="token operator">/</span><span class="token keyword">UPDATE</span> <span class="token keyword">RESTRICT</span><span class="token operator">/</span><span class="token keyword">CASCADE</span><span class="token operator">/</span><span class="token keyword">SET</span> <span class="token boolean">NULL</span><span class="token operator">/</span><span class="token keyword">NO</span> <span class="token keyword">ACTION</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> 子表 <span class="token keyword">drop</span> <span class="token keyword">foreign</span> <span class="token keyword">key</span> 外键名<span class="token punctuation">;</span>

<span class="token comment">## 添加主键约束</span>
<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">ADD</span> <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>列名<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">## 查字符集对应的校对规则/编码</span>
<span class="token keyword">show</span> <span class="token keyword">character</span> <span class="token keyword">set</span><span class="token punctuation">;</span>
<span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">&#39;char%&#39;</span><span class="token punctuation">;</span>

<span class="token comment">## 修改mysql的隔离级别</span>
<span class="token keyword">set</span> <span class="token keyword">session</span> <span class="token keyword">transaction</span> <span class="token keyword">isolation</span> <span class="token keyword">level</span>

<span class="token comment">## 创建/删除索引</span>
<span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span><span class="token operator">|</span>FULLTEXT<span class="token operator">|</span>SPATIAL<span class="token punctuation">]</span> <span class="token keyword">INDEX</span> 索引名 <span class="token punctuation">[</span><span class="token keyword">USING</span> 索引类型<span class="token punctuation">]</span> <span class="token keyword">ON</span> 表名 <span class="token punctuation">(</span>列名<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span>长度<span class="token punctuation">)</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> 索引名 <span class="token keyword">ON</span> 表名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">## 添加记录</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> 表名 <span class="token punctuation">[</span><span class="token punctuation">(</span>列名<span class="token number">1</span>，列名<span class="token number">2</span>，列名<span class="token number">3.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>值<span class="token number">1</span>，值<span class="token number">2</span>，值<span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">(</span>值<span class="token number">3</span><span class="token punctuation">,</span> 值<span class="token number">3</span><span class="token punctuation">,</span> 值<span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>

<span class="token comment">## 修改(多表)记录</span>
<span class="token keyword">UPDATE</span> 表<span class="token number">1</span><span class="token punctuation">[</span><span class="token punctuation">,</span>表<span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">SET</span> 列名<span class="token operator">=</span>值<span class="token punctuation">[</span><span class="token punctuation">,</span>列名<span class="token operator">=</span>值<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">where</span> 条件<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">## 删除(多表)记录</span>
<span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> 表名 <span class="token punctuation">[</span><span class="token keyword">where</span> 条件<span class="token punctuation">]</span> <span class="token keyword">auto_increment</span>记录不清空，同一个事务可以找回数据
<span class="token keyword">DELETE</span> t1<span class="token punctuation">,</span>t2…tn <span class="token keyword">FROM</span> t1<span class="token punctuation">,</span>t2…tn <span class="token keyword">JOIN</span> <span class="token punctuation">[</span><span class="token keyword">where</span> 条件<span class="token punctuation">]</span>

<span class="token comment">## 开始。提交。回滚事务</span>
<span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span><span class="token keyword">COMMIT</span><span class="token punctuation">;</span><span class="token keyword">ROLLBACK</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">## 查询记录</span>
<span class="token keyword">SELECT</span> <span class="token punctuation">[</span><span class="token keyword">distinct</span>全部列<span class="token punctuation">,</span>非第一列<span class="token punctuation">]</span> <span class="token operator">*</span><span class="token operator">/</span>列名 <span class="token punctuation">[</span><span class="token keyword">as</span> <span class="token identifier"><span class="token punctuation">\`</span>别名<span class="token punctuation">\`</span></span><span class="token punctuation">]</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> 表名 
<span class="token punctuation">[</span><span class="token keyword">inner</span><span class="token operator">/</span><span class="token keyword">left</span><span class="token operator">/</span><span class="token keyword">right</span> <span class="token keyword">join</span> 表名 <span class="token keyword">on</span> 条件<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">where</span> 条件<span class="token punctuation">]</span> 
<span class="token punctuation">[</span><span class="token keyword">group</span> <span class="token keyword">by</span> 条件 <span class="token punctuation">[</span><span class="token keyword">WITH ROLLUP</span> 对分类聚合后的结果进行再汇总 和<span class="token keyword">ORDER</span> <span class="token keyword">BY</span>排斥<span class="token punctuation">]</span> 
<span class="token punctuation">[</span><span class="token keyword">having</span> 条件 对分类结果再条件过滤<span class="token punctuation">]</span><span class="token punctuation">]</span>  
<span class="token punctuation">[</span><span class="token keyword">order</span> <span class="token keyword">by</span> 条件 <span class="token keyword">asc</span><span class="token operator">/</span><span class="token keyword">desc</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>多个字段时，相同的按第二个字段排，依次类推，默认升序<span class="token punctuation">]</span> 
<span class="token punctuation">[</span><span class="token keyword">limit</span> offset_start<span class="token punctuation">[</span><span class="token punctuation">,</span>row_count<span class="token punctuation">]</span> offset_start<span class="token operator">=</span><span class="token punctuation">(</span>第几页<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>row_count row_count每页数量<span class="token punctuation">]</span>

<span class="token comment">## 子查询[not] in、=、!=、[not] exists、ALL、ANY、SOME，表连接用于优化子查询</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> 表名 <span class="token keyword">where</span> 列名<span class="token operator">=</span>（<span class="token keyword">select</span> <span class="token keyword">where</span> 列名<span class="token operator">=</span>值）<span class="token punctuation">;</span>

表与表的关系
一对多：部门与员工、分类和商品，从表（多）外键指向主表（一）主键
多对多：学生和课程、商品和订单，建立中间表，两个字段作为从表，指向（多）的主键，拆成两个一对多
外键操作
从表外键是对主表主键的引用、类型必须一样
从表不能添加<span class="token punctuation">(</span>更新<span class="token punctuation">)</span>，主表中不存在的数据。主表不能删除（更新），从表中已经使用的数据
外键的目的是保证数据完整性
删除数据：①解除主从表的约束关系、②先删除从表中与主表有关系的数据，再删除主表中的数据
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment">## 创建用户</span>
<span class="token keyword">CREATE</span> <span class="token keyword">USER</span> <span class="token string">&#39;uname&#39;</span><span class="token variable">@&#39;host&#39;</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">&#39;pwd&#39;</span><span class="token punctuation">;</span>
<span class="token comment">## 授权</span>
<span class="token keyword">GRANT</span> <span class="token keyword">ALL</span><span class="token punctuation">[</span><span class="token keyword">PRIVILEGES</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token keyword">SELECT</span><span class="token operator">/</span><span class="token keyword">INSERT</span> <span class="token keyword">ON</span> 库名<span class="token punctuation">.</span>表名 <span class="token keyword">TO</span> <span class="token string">&#39;uname&#39;</span><span class="token variable">@&#39;localhost&#39;</span> IDENTIFIED <span class="token keyword">BY</span> <span class="token string">&#39;pwd&#39;</span>
<span class="token comment">## 回收</span>
<span class="token keyword">REVOKE</span> <span class="token keyword">ALL</span><span class="token punctuation">[</span><span class="token keyword">PRIVILEGES</span><span class="token punctuation">]</span><span class="token operator">/</span><span class="token keyword">SELECT</span><span class="token operator">/</span><span class="token keyword">INSERT</span> <span class="token keyword">ON</span> 库名<span class="token punctuation">.</span>表名 <span class="token keyword">FROM</span> <span class="token string">&#39;uname&#39;</span><span class="token variable">@&#39;localhost&#39;</span>
<span class="token comment">## 删除用户</span>
<span class="token keyword">DROP</span> <span class="token keyword">USER</span> <span class="token string">&#39;uname&#39;</span><span class="token variable">@&#39;host&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>SELECT * FROM table_name LIMIT 2, 8;</p><p>FROM，ON，JOIN，WHERE，GROUP BY，ACG_FUNC，CUBE|ROLLUP，HAVING，SELECT，DISTINCT，ORDER BY，LIMIT<br> 聚合函数在WHERE之后执行 故WHERE不能用聚合函数</p><p>inner join内连接，取得两张表中满足连接条件的记录。相当于两个数据集的交集<br> outer join外连接：取得两张表中满足连接条件的记录，和某张表中不满足匹配关系的记录。分为<br> left join返回左表（FROM子句中的表）所有记录，以及右表满足连接条件的记录。如果右表中没有匹配的记录，则结果中右表的部分会以NULL填充，right join右连接相反<br> crossjoin交叉连接：显示两张表所有记录，笛卡尔积在SQL的实现，如果A表有m行，B表有n行，那么A和B交叉连接的结果就有m*n行。<br> 笛卡尔积：集合A={a,b}，集合B={0,1,2}，AxB={&lt;a,o&gt;,&lt;a,1&gt;,&lt;a,2&gt;,&lt;b,0&gt;,&lt;b,1&gt;,&lt;b,2&gt;}</p><p>in语句把外表（from子句中的表）和内表（in子查询的表）作hash连接(先内后外)。exists语句对外表作loop循环，每次loop循环再对内表进行查询(先外后内)<br> 子查询表大用exists，小用in。”小表驱动大表“思想：exist驱动表是外表，in是内表<br> not exists比not in快，not in内外表都全表扫描；而not extsts的子查询能用索引</p><table><thead><tr><th style="text-align:center;"></th><th>delete</th><th>truncate</th><th>drop</th></tr></thead><tbody><tr><td style="text-align:center;">类型</td><td>DML</td><td>DDL</td><td>DDL</td></tr><tr><td style="text-align:center;">回滚</td><td>可回滚</td><td>不可回滚</td><td>不可回滚</td></tr><tr><td style="text-align:center;">删除内容</td><td>删除部分数据，不释放空间</td><td>删除所有数据,释放空间删除数据后重新写数据会从1开始</td><td>删除表结构，索引和权限也会被删除</td></tr><tr><td style="text-align:center;">删除速度</td><td>慢，逐行删除</td><td>快</td><td>最快</td></tr></tbody></table><p>都是对两个结果集进行并集操作，Union去重并排序(按默认规则)，Union All不去重不排序；速度快</p><p>MyISAM执行count(<code>*</code>)会返回存储在磁盘上的表总行数，效率高<br> InnoDB执行count(<code>*</code>)需要实时计数；因为innodb每个事务查询结果有差异，故不存储表总行数</p><p>count(<code>*</code>)允许null。不取值，自动扫描索引树小的。减少扫描数据量<br> count(1)允许null，不取值，1代表代码行，速度比count(主键id)快。因为返回id会涉及到解析以及拷贝字段值操作<br> count(主键id/列名)不允许null。取id/列名值<br> 效率排序：count(字段)&lt;count(主键id)&lt;count(1)≈count(<em>)，建议使用count(</em>)</p><p>字符串函数</p><ul><li>CANCAT(S1,S2,…Sn) 连接 S1,S2,…Sn 为一个字符串，与NULL连接的结果是NULL</li><li>LENGTH():</li><li>SUBSTRING(str,x,y) 返回从x位置起y个字符长度的子串</li><li>REPLACE(str,a,b)</li><li>LOWER(str)、UPPER(str) 将所有字符变为小、大写</li><li>TRIM(str) 去掉头尾的空格</li></ul><p>数值函数</p><ul><li>ABS(x) 返回x绝对值</li><li>CEIL(x)、FLOOR(x) 返回大于/小于或等于给定数值的最小/大整数。</li><li>ROUND(x,y) 返回x四舍五入有y位小数的值。如果是整数，将会保留y位数量的0；y不写默认0</li><li>MOD(x，y) 取模</li><li>BIT_OR()、BIT_AND()配合GROUP BY统计，比如用十进制数字存储买过的商品，每位的1表示买了，0表示没买，则BIT_OR表示客户买过哪些商品，BIT_AND表示每次都买的商品</li></ul><p>日期和时间函数</p><ul><li>NOW()、CURDATE()、CURTIME()当前年月日时分秒 年月日 时分秒</li><li>DATE_ADD(date,INTERVAL expr type)和DATE_SUB()返回一个日期或时间值加上、减去一个时间间隔的时间值</li><li>DATEDIFF(expr,expr2) 返回两个时间之间的天数</li></ul><p>聚合函数</p><ul><li>SUM()、AVG()、COUNT()、MAX()、MIN()、GROUP_CONCAT()将多个行值连接为一个字符串</li></ul><p>流程函数</p><ul><li>IF(value,t f)如果value是true，返回t；否则返回f</li><li>IFNULL(value1,value2) 如果value1不为空返回value1，否则返回value2</li><li>CASE WHEN [value1] THEN[result1]…ELSE[default]END 如果value1是true，返回 result1，否则返回 default</li><li>CASE [expr] WHEN [value1] THEN[result1]…ELSE[default]END 如果expr等于value1，返回result1，否则返回default</li><li>COALESCE()：返回第一个非NULL值</li></ul><p>格式化函数</p><ul><li>FORMAT() 格式化数字为字符串，用于显示货币。SELECT FORMAT(1234567.8945, 2) AS xx;</li></ul><p>类型转换函数</p><ul><li>CAST(): CAST(&#39;2024-01-01&#39; AS DATE) AS casted_date;</li><li>CONVERT()：CONVERT(&#39;123&#39;, SIGNED INTEGER) AS converted_number;</li></ul><p>当不同数据类型的值进行运算或比较时，会发生隐式数据类型转换。可以通过显式转换来规避</p><h2 id="_3-基础架构-sql查询语句如何执行-bin目录下的可执行文件-数据存储形式" tabindex="-1"><a class="header-anchor" href="#_3-基础架构-sql查询语句如何执行-bin目录下的可执行文件-数据存储形式"><span>.3. 基础架构？SQL查询语句如何执行？bin目录下的可执行文件？数据存储形式</span></a></h2><figure><img src="https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMwfb5fc110878f57454fdbc10ae180c0cf.png" alt="mysqlinfrastructure.png" tabindex="0"><figcaption>mysqlinfrastructure.png</figcaption></figure><p>客户端：用于连接处理、授权认证等<br> Server层：实现所有跨存储引擎的功能，比如函数、存储过程、触发器等。不同的存储引擎共用Server层<br> 存储引擎层：负责数据存储和提取。在create table时用engine = MyISAM指定。Server层通过接口与存储引擎进行通信。屏蔽了不同存储引擎的差异</p><p>客户端发送SQL查询语句到MySQL服务器。<br> 连接器与客户端建立连接，检查客户端对表有没有执行查询的权限<br> 查询缓存，(8.0后移除，因为表更新后缓存随时失效) 如果在缓存中找到key查询的语句，那么value将查询结果返回给客户端。如果找不到，则继续执行。执行完成后，执行结果会被存入查询缓存中<br> 分析器做语法分析，提取sql语句中select等关键字、判断是否有语法错误<br> 优化器优化查询语句，确定SQL执行计划、使用的索引及各个表的连接顺序<br> 执行器按照执行计划调用数据库引擎接口，取这个表的每一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中，直到取到这个表的最后一行，返回执行结果。</p><p>mysql：MySQL客户端<br> mysqldump：数据库备份工具，用于数据备份、迁移或恢复。<br> mysqladmin：管理工具，用来创建数据库、删除数据库、查看MySQL服务器的状态<br> mysqlcheck：命令行工具，用于检查、修复、分析和优化数据库表<br> mysqlimport：用于从文本文件中导入数据到数据库表中<br> mysqlshow：用于显示MySQL数据库服务器中的数据库、表、列等信息<br> mysqlbinlog：用于查看MySQL二进制日志文件的内容、恢复数据、查看数据变更等</p><p><img src="https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMw9eb4a7174ea187aeef637e6655e3ae2f.png" alt="mysqlrow.png"><br> 段Segment：表空间由多个段组成，创建索引时会创建数据段和索引段，数据段用来存储叶子阶段中的数据；索引段用来存储非叶子节点的数据。回滚段包含了事务执行过程中用于数据回滚的旧数据。<br> 区Extent：段由多个区组成，区是一组连续的页，通常包含64个连续的页，1M的数据。使用区进行数据分配可以优化磁盘操作，减少磁盘IO次数<br> 页Page：InnoDB存储数据的基本单元，大小为16KB，索引树上的一个节点就是一个页。数据库每次读写都是以16KB为单位的<br> 行Row：InnoDB采用行存储方式，数据按照行进行组织和管理，行数据可能有多个格式，比如说COMPACT、REDUNDANT、DYNAMIC等<br> MySQL8默认的行格式是DYNAMIC，如果超过了页内联存储的限制，则会被存储在溢出页中。show table status like &#39;%article%&#39;查看行格式</p><h2 id="_4-常见存储引擎-选择-innodb和mylsam区别" tabindex="-1"><a class="header-anchor" href="#_4-常见存储引擎-选择-innodb和mylsam区别"><span>.4. 常见存储引擎？选择？InnoDB和MylSAM区别？</span></a></h2><p>InnoDB支持事务、外键、全文索引、B+树索引、哈希索引， <code>事外全b哈</code><br> MyISAM支持全文、B+树索引；MEMORY支持B+树、哈希索引</p><p>InnoDB：对事务，并发条件下数据一致性要求高，外键，崩溃恢复，数据操作包括增删改查操作<br> MyISAM：~要求不高，插入和查询记录操作多，更新和删除操作少，如Web数据仓储<br> MEMORY：对访问速度要求高，数据量小，内容固定(代码表)、安全性要求低，如临时表，存放查询的中间结果。需要保证数据库异常后能恢复<br> MERGE：一个对象将MyISAM表以逻辑方式组合在一起。突破对单个MyISAM表大小的限制，并且通过将不同的表分布在多个磁盘上，提高访问效率。如数据仓储等VLDB环境<br> 根据业务灵活选择，因为不同表能用不同的存储引擎</p><p><code>MVCC主存锁事外，恢复索行</code><br> MyISAM表可以没有主键；InnoDB不设定主键或者非空唯一索引时自动生成一个6字节的隐藏主键<br> 都用.frm文件存储表的定义，MyISAM用.MYD存储数据；.MYI存储索引。InnoDB用.ibd 存储数据和索引<br> MyISAM只支持表级锁；InnoDB支持行级锁<br> MyISAM不支持MVCC、事务、外键、数据库异常崩溃后的安全恢复；InnoDB支持<br> MyISAM的索引为非聚簇索引，数据结构是B树，索引和数据分开存储。InnoDB的索引是聚簇索引，数据结构是B+树，索引和数据不分开存储<br> MyISAM保存了表的总行数；InnoDB没有</p><h2 id="_5-日志文件及作用-更新语句执行流程-为什么要两阶段提交-binlog和redolog区别-redo-log怎么刷入磁盘的" tabindex="-1"><a class="header-anchor" href="#_5-日志文件及作用-更新语句执行流程-为什么要两阶段提交-binlog和redolog区别-redo-log怎么刷入磁盘的"><span>.5. 日志文件及作用？更新语句执行流程？为什么要两阶段提交？binlog和redolog区别？redo log怎么刷入磁盘的？</span></a></h2><p><code>be sugr</code><br> 错误日志errorlog：记录运行过程中发生错误时的信息<br> 慢查询日志slowquerylog：记录执行时间超过long_query_time的查询语句<br> 一般查询日志generallog：记录所有对MySQL数据库请求的信息，不建议开启<br> 重做日志redolog：记录对于InnoDB表的每个写操作，用于崩溃恢复(InnoDB独有)<br> 回滚日志undolog：记录数据被修改前的值，用于事务的回滚(InnoDB独有)<br> 二进制日志binlog包括二进制索引文件（.index）、二进制日志文件（.00000*）</p><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 配置文件my.cnf/.ini</span>
<span class="token comment"># 默认关闭。开启binlog</span>
<span class="token comment"># show variables like &#39;%log_bin%&#39;; 查看binlog是否开启</span>
log_bin <span class="token operator">=</span> mysql<span class="token operator">-</span>bin

<span class="token comment"># 单个日志文件最大字节</span>
max_binlog_size<span class="token operator">=</span><span class="token number">104857600</span>

<span class="token comment"># 只保留7天的binlog。防止binlog占用过多存储空间</span>
expire_logs_days <span class="token operator">=</span> <span class="token number">7</span>

<span class="token comment"># 写操作时数据会先写入操作系统的缓存，再将数据写入磁盘。</span>
<span class="token comment"># 默认0表示依赖操作系统的磁盘缓存策略</span>
<span class="token comment"># 1表示每次写操作后都同步到磁盘，数据安全性高，但性能差</span>
sync_binlog<span class="token operator">=</span><span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>范内方时</code><br> 记录范围：binlog记录所有存储引擎的日志，用于主从复制、恢复和备份。redolog记录InnoDB存储引擎的日志，用于崩溃恢复和保证事务持久性<br> 记录内容：binlog记录DDL和DML语句（除了数据查询语句），是逻辑日志。redolog记录物理数据页的修改操作，是物理日志。<br> 写入方式：binlog是追加写入，所有日志会顺序追加到文件末尾，直到达到文件大小限制后新建一个文件继续记录。redolog是循环写入的，日志空间固定大小，写到文件末尾时会回到文件开头，覆盖旧日志数据<br> 写入时间：binlog在事务提交时写入，只写磁盘一次。而redolog在事务进行的过程中不断写入</p><p><img src="https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMw201927a567c82aa72d89af16b57cffd1.jpg" alt="mysqlexecuteupdate.jpg"><br> 执行器先找引擎获取ID=2这一行。如果这行所在的数据页在内存中，则直接返回给执行器；否则，需要先从磁盘读入内存并返回<br> 执行器拿到引擎给的行数据N，得到新数据N+1，再调用引擎接口写入新数据。引擎将数据更新到内存中，同时将更新操作记录到redolog，此时redolog处于prepare状态。然后通知执行器执行提交事务<br> 执行器生成更新操作的binlog，并把binlog写入磁盘<br> 执行器调用引擎的提交事务接口，引擎把redolog改成提交commit状态，更新完成<br> redolog写入时有两个阶段的提交，binlog写入之前prepare状态的写入和binlog写入之后commit状态的写入</p><p>如果采用“单阶段”提交，会导致原来数据库的状态和被恢复后的数据库的状态不一致<br> 假设ID=2的行c=0，执行update T set c=c+1 where ID=2<br> 先写redo log后写binlog。假设redo log写完，MySQL异常重启。redo log已写，崩溃恢复以后事务生效，c=1。而用binlog恢复临时库时，由于binlog丢失，恢复出来c=0，与数据库的值不同<br> 先写binlog后写redo log。假设binlog写完，MySQL异常重启。redo log未写，崩溃恢复以后事务无效，c=0。而用binlog来恢复时多了“把c从0改成1”日志，恢复出来c=1，与数据库的值不同</p><p>redo log由一定数量的redo log block组成。~<br> 写入机制：事务执行过程中先把日志写到redo log buffer。 然后写到redo log的文件系统缓存page cache(fwrite)，然后再同步到磁盘文件（fsync）</p><p>redo log buffer空间不足时：relog buffer日志量超过总容量innodb_log_buffer_size的一半，后台线程会主动写盘fwrite保存在文件系统，但没有调用fsync<br> innodb_flush_log_at_trx_commit=1时，并行事务提交时顺便将本事务的redo log buffer持久化到磁盘。假设事务A写了一些redo log到buffer中，此时有另外一个线程的事务B提交，事务B要把redo log buffer里的日志全部持久化到磁盘。此时会和事务A在redo log buffer里的日志一起持久化到磁盘<br> innodb_flush_log_at_trx_commit=2时，后台线程每秒都会刷新redo log buffer中的redo log到磁盘<br> 正常关闭服务器时<br> 触发checkpoint机制：redolog用writepos表示当前记录的位置，checkpoint表示当前要擦除的位置，都是往后移动并且循环的，write pos和checkpoint(cp)之间用来写日志。当write_pos追上checkpoint时，表示redolog日志已经写满需要将buffer中日志页都刷到磁盘释放空间</p><h2 id="_6-索引分类-原理√为什么innodb要使用b-树作为索引-不用普通、平衡二叉树、红黑树、b树√-b-树能存储多少条数据呢-hash、b-树索引-聚簇索引与非聚簇索引区别-回表-覆盖索引-索引下推优化-最左匹配原则" tabindex="-1"><a class="header-anchor" href="#_6-索引分类-原理√为什么innodb要使用b-树作为索引-不用普通、平衡二叉树、红黑树、b树√-b-树能存储多少条数据呢-hash、b-树索引-聚簇索引与非聚簇索引区别-回表-覆盖索引-索引下推优化-最左匹配原则"><span>.6. 索引分类？原理√为什么InnoDB要使用B+树作为索引？不用普通、平衡二叉树、红黑树、B树√？B+树能存储多少条数据呢？Hash、B+树索引，聚簇索引与非聚簇索引区别？回表？覆盖索引？索引下推优化？最左匹配原则？</span></a></h2><ul><li>按功能分 <ul><li>主键索引：表中每行数据唯一的非空索引。一张数据表有只能有一个主键</li><li>唯一索引：保证数据列中每行数据的唯一性，允许有空值。</li><li>普通索引：基本的索引类型，用于加速查询。允许数据重复和NULL</li><li>全文索引：用于检索大文本数据中的信息，避免使用like %…%</li><li>外键索引：保证数据的一致性和实现级联操作，但性能较差，生产中建议通过业务代码约束</li></ul></li><li>按数据结构分 <ul><li>B+树索引：查询效率O(logN)</li><li>Hash索引：基于哈希表的索引，查询效率O(1)，只适合=和in查询，不适合范围查询和排序。哈希冲突时通过拉链法来解决。InnoDB使用了自适应哈希索引Adaptive Hash Index, AHI技术，SHOW VARIABLES LIKE &#39;innodb_adaptive_hash_index&#39;查看</li></ul></li><li>按存储位置分：聚簇索引、非聚簇索引</li></ul><p><code>根据索引特点</code><br> 索引是一种数据结构，用来加速数据查询操作。通过索引可以快速定位表中的数据行，避免全表扫描<br> MySQL默认存储引擎为InnoDB，使用B+树作为默认的索引结构。B+树是多路平衡查找树。具有以下特点<br><strong>查询速度快</strong><br> B+树实际数据都存储在叶子节点，叶子节点通过指针相互连接形成有序链表。提高了范围查询和排序效率，因为只需顺序访问链表<br> B+树非叶子节点只存储索引键和子节点的指针。降低了树的高度，减少了磁盘IO次数<br> B+树节点的大小通常与磁盘页的大小一致，能够在一次磁盘 I/O 操作中读取一个完整的节点。在树的高度较低的情况下，减少磁盘I/O次数，提高了查询速度。<br><strong>查询性能稳定</strong>：B+树所有叶子节点都在同一层，保证了从根节点到任意叶子节点的路径长度是相同的。时间复杂度稳定为O(log n)</p><p>如果插入的数据是有序的，那么二叉树会退化成链表，查询复杂度增至O(n)</p><p>红黑树/平衡树的节点只能包含2个节点，随着数据增多可能导致树的高度过高，查询性能下降</p><p>B树的数据分散在非叶子和叶子节点上，导致范围查询和排序可能需要遍历多个层级和节点，效率不如B+树以及不同查询可能需要通过不同的层级得到数据，导致查询路径不一致，查询稳定性不如B+树</p><p>假设主键ID是bigint类型，长度8字节。指针6字节，一共14字节。非叶子节点(一页)可存储16384/14=1170个单元(键值+指针)<br> 一个指针指向一页，一页可以放16条数据，树深度为2时可以存放1170x16=18720条数据<br> 树深度为3的时候，可以存储的数据为1170x1170x16=21902400条记录。<br> 理论B+树的高度一般为2-4层，满足千万级数据的存储。查找数据时一次页的查找代表一次IO，通过主键索引查询只需要2-4次IO</p><p>B+树支持范围查询、排序、最左匹配原则，Hash索引不支持。<br> Hash索引在等值查询上比B+树效率高</p><p>聚簇索引的索引结构和数据一起存放。非聚簇索引中索引结构和数据分开存放。<br> 聚簇索引的叶子节点存储索引和索引对应的数据。非聚簇索引的叶子节点存储指向数据行的指针(主键ID)<br> InnoDB主键使用的是聚簇索引，MyISAM不管是主键索引，还是二级索引使用的都是非聚簇索引。<br> 一个表只能有一个聚簇索引，但可以有多个非聚簇索引。</p><p>使用非聚簇索引进行查询时，先找到主键ID再去聚簇索引上找到真正的行数据的过程</p><p>查询时已经在索引树上获得想要的数据，无需回表的查询，可以通过建立联合索引支持覆盖索引，牺牲空间</p><p>Index Condition Pushdown ICP在多个索引查询条件下，索引扫描时减少回表，通过过滤不必要的数据的过程，提高查询效率<br> 假设有组合索引A,B,查询语句where A=? and B=?,如果没有索引下推，则每次都会根据A=?回表判断B=?，有索引下推则会根据A=?和B=?索引组合判断减少回表</p><p>在使用联合索引时，查询会优先使用索引中从左到右排列的字段，直到遇到无法匹配的字段为止。可以是联合索引的最左N个字段，字符串索引的最左M个字符。例如：用name，age联合索引，name = &#39;张三&#39;或者where name like &#39;张%&#39;</p><h2 id="_7-锁分类-如何解决库存超卖问题-行锁实现-意向锁" tabindex="-1"><a class="header-anchor" href="#_7-锁分类-如何解决库存超卖问题-行锁实现-意向锁"><span>.7. 锁分类？如何解决库存超卖问题？行锁实现？意向锁？</span></a></h2><ul><li>按锁粒度分 <ul><li>表锁：开销小，加锁快；锁定粒度大，发生锁冲突概率高，并发度低，不会死锁</li><li>行锁：开销大，加锁慢；锁定粒度小，发生锁冲突概率低，并发度高，会死锁</li><li>页锁：开销和加锁速度介于表锁和行锁之间；锁定粒度介于表锁和行锁之间，并发度一般，会死锁</li></ul></li><li>按兼容性分 <ul><li>共享锁（SLock）/读锁（readlock），相互不阻塞。</li><li>排他锁（XLock）/写锁（writelock），排它锁是阻塞的</li></ul></li><li>按加锁机制分：乐观锁、悲观锁</li></ul><div class="language-sql line-numbers-mode" data-ext="sql" data-title="sql"><pre class="language-sql"><code><span class="token comment"># 乐观锁</span>
<span class="token keyword">UPDATE</span> inventory <span class="token keyword">SET</span> count <span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> version <span class="token operator">=</span> version <span class="token operator">+</span> <span class="token number">1</span> 
<span class="token keyword">WHERE</span> product_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">AND</span> version <span class="token operator">=</span> current_version<span class="token punctuation">;</span>
<span class="token comment"># 悲观锁</span>
<span class="token keyword">START</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> inventory <span class="token keyword">WHERE</span> product_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
<span class="token keyword">UPDATE</span> inventory <span class="token keyword">SET</span> count <span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">WHERE</span> product_id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>RecordLock记录锁</strong>：唯一索引和主键索引等值查询时锁定匹配的记录<br><strong>GapLock间隙锁</strong>：等值或者范围查询没有匹配到记录时锁定两个记录之间间隙，左开右开区间<br><strong>Next-keyLock临键锁</strong>：记录锁+间隙锁，范围查询并且匹配到记录时同时锁住记录和索引之间的间隙，临键锁锁住的区间会包含最后一个record的右边的临键区间。例如select * from t where id &gt; 5 and id &lt;= 7 for update;会锁住(4,7]、(7,+∞)。当唯一性索引等值查询匹配到一条记录时临键锁会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁<br> 间隙锁和临键锁都是用来解决幻读问题的，在读已提交隔离级别下都失效</p><p>Insert Intention Lock插入意向锁。用于提升并发插入的性能<br> 允许多个事务并发插入记录到不冲突的索引范围中<br> 当一个事务尝试向一个表中插入一条记录时，InnoDB会在插入的位置上设置插入意向锁，表示这个事务打算在某个范围内插入数据。两个事务如果在同一个表的不同索引区间插入数据，它们的插入意向锁可以共存。当插入操作发生时会在插入行上加行锁。如果事务之间在同一位置插入数据，行锁才会引发冲突和等待</p><p>意向锁是表级锁，用于支持表锁和行锁的并发操作，避免全表级锁与行锁发生冲突<br> 分意向共享锁（IS）和意向排他锁（IX）。<br> 如果一个事务需要在某个表的行上加行锁时会先申请一个意向排他锁IX，而另一个事务想对同一个表加表锁，如果检查到有意向锁存在，则被阻塞到意向锁释放</p><h2 id="_8-mysql事务特性-怎么保证-并发事务问题-事务隔离级别-默认-实现-mvcc实现原理-会加锁吗" tabindex="-1"><a class="header-anchor" href="#_8-mysql事务特性-怎么保证-并发事务问题-事务隔离级别-默认-实现-mvcc实现原理-会加锁吗"><span>.8. MySQL事务特性？怎么保证？并发事务问题？事务隔离级别？默认？实现？MVCC实现原理？会加锁吗？</span></a></h2><p><strong>原子性Atomicity</strong>：一个事务的所有操作要么全部提交成功，要么全部失败回滚。使用undo log~<br><strong>一致性Consistency</strong>：一个事务前后数据的完整性必须保持一致。比如银行转账事务中转账前后两个账户的总金额应保持不变。假如A账户100块给B账户10块转10块，不管成功与否，A、B的总金额都是110块.通过原子性、隔离性、持久性和业务代码<br><strong>隔离性Isolation</strong>：一个事务的执行不能被其他事务干扰。使用MVCC(多版本并发控制)机制来处理并发事务实现多种隔离级别<br><strong>持久性Durability</strong>：一个事务提交后对数据的更改就是永久性的，系统崩溃也不会丢失。InnoDB使用redo log记录数据页的物理更改。崩溃时通过redo log恢复未写入的数据，确保数据不丢失</p><p>脏读dirty read: 一个事务读取到了另一个事务尚未提交的数据<br> 不可重复读non-repeatable read: 一个事务读到了另一个事务已经提交的update数据 两次读取的数据的内容不一致<br> 幻读/虚读phantom read: 一个事务读到了另一个事务已经提交的insert、delete数据 两次读取的数据的数量不一致</p><p>读未提交ReadUncommitted读取尚未提交的数据，都不能解决<br> 读已提交ReadCommitted读取已经提交的数据，解决脏读（oracle默认）<br> 可重复读RepeatableRead一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的，除非是自己修改的数据。解决脏读和不可重复读（mysql默认）<br> 串行化Serializable对于同一行记录，写加写锁，读加读锁。读写锁冲突时，后访问的事务必须等前一个事务执行完成才能继续执行。解决所有<br> 性能read uncommitted&gt;read committed&gt;repeatable read&gt;serialazable，安全性相反</p><p>读未提交：读事务不加锁，写事务加排他锁<br> 读已提交：读事务加共享锁，读取后立即释放（造成不可重复读原因）写事务加排他锁，事务提交才释放<br> 可重复读：读事务加共享锁直到事务结束。写事务加排他锁和间隙锁防止其他事务在范围内插入或删除数据<br> 串行化：读写事务都加排他锁，或者使用MVCC</p><p>Multi Version Concurrency Control多版本并发控制，用与解决并发事务问题，提高并发性能（读操作基于快照，不加锁。写操作UPDATE、DELETE、INSERT、SELECT ... FOR UPDATE 或 LOCK IN SHARE MODE会加锁以避免写冲突），保证隔离性。通过undolog版本链和ReadView机制实现<br><strong>版本链</strong>：InnoDB每一行记录都有两个隐藏列<br> DB_TRX_ID，保存创建这个版本的事务ID<br> DB_ROLL_PTR，指向undo日志记录的指针，用于事务回滚恢复数据。当一个事务对数据进行修改时，InnoDB会将修改前的数据记录到Undo log中并用undolog指针指向undolog日志记录，当一条记录被多个事务依次修改时，InnoDB会通过undo log记录指针将旧版本数据连接成链表，形成一个“版本链”。这个链表从最新版本指向之前的旧版本。如果事务提交，undolog会在某个时间点被清除。如果事务回滚，InnoDB会根据undolog回滚数据<br><strong>ReadView</strong> 用于确定事务中哪些版本的行记录是可见的。包含以下信息<br> m_ids：活跃事务的事务id列表。<br> min_trx_id：活跃事务中最小的事务id，m_ids中的最小值<br> max_trx_id：分配给下一个事务的事务id<br> creator_trx_id：表示生成ReadView事务的事务id<br> 访问某条记录时，根据以下规则判断某个版本是否可见<br> 如果被访问版本的DB_TRX_ID属性值<br> 等于creator_trx_id，表明生成该版本的事务是自己修改的，所以该版本可以被访问<br> 小于min_trx_id，~已经提交，~可以~<br> 大于max_trx_id，~还未开启，~不可以~<br> 介于min_trx_id和max_trx_id且m_ids列表中，~还活跃，~不可以~；如果不在，~已经提交，~可以~<br> 如果某个版本的数据不可以被访问，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么查询结果就不包含该记录。<br> READCOMMITTED每次读取数据前生成一个ReadView<br> REPEATABLEREAD第一次读取数据时生成一个ReadView</p><h2 id="_9-数据库读写分离-分配怎么实现-主从复制原理了解吗-主从同步延迟原因-处理-百万级别以上的数据如何删除-添加字段-自增id用完怎么办" tabindex="-1"><a class="header-anchor" href="#_9-数据库读写分离-分配怎么实现-主从复制原理了解吗-主从同步延迟原因-处理-百万级别以上的数据如何删除-添加字段-自增id用完怎么办"><span>.9. 数据库读写分离？分配怎么实现？主从复制原理了解吗？主从同步延迟原因？处理？百万级别以上的数据如何删除？添加字段？自增id用完怎么办？</span></a></h2><p>读写分离基本原理是将数据库读写操作分散到不同的节点上。基本实现是:<br> 数据库服务器搭建主从集群，一主一从或一主多从。<br> 主机负责写操作，从机只负责读操作。<br> 主机通过复制将数据同步到从机，每台数据库服务器都存储了所有的业务数据。</p><p>程序代码/中间层封装：在代码中抽象一个数据访问层，实现读写操作分离和数据库服务器连接的管理。例如淘宝的TDDL（Taobao Distributed Data Layer）<br> 中间件封装：使用中间件实现读写操作分离和数据库服务器连接的管理。对于业务服务器来说，访问中间件和访问数据库没有区别。</p><p>主从复制Master-Slave Replication将数据从主数据库复制到从数据库，用于数据备份和恢复</p><p>主服务器上，binlog记录了所有修改数据的语句（如 INSERT、UPDATE、DELETE）<br> 主服务器上的一个线程（二进制日志转储线程）负责读取binlog日志的内容并发送给从服务器<br> 从服务器接收到二进制日志数据后，将数据写入中继日志Relay Log（从服务器上的一个本地存储）<br> 从服务器上有一个SQL线程会读取中继日志并执行，从而将更改应用到从数据库中，完成同步<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/eb5eaa6b07dd6988b2e6e.png" alt="mysqlslave.jpg"></p><p>网络延迟、主库写入压力大、从库SQL线程执行效率低（只有一个线程）</p><p>写操作后的读操作发给主服务器。注册账号完成后登录的读操作发给主服务器。影响业务代码<br> 读从机失败后再读一次主机。只需对底层数据库访问的API进行封装即可，不影响业务代码，实现代价较小，但如果有很多二次读取，将增加主机的读操作压力。黑客暴力破解账号会导致大量的二次读取操作<br> 关键业务读写操作发给主服务器，非关键业务采用读写分离。对于用户注册+登录的业务读写操作全部访问主机，用户的介绍、爰好、等级等业务采用读写分离</p><p>索引需要额外的维护成本，因为索引文件是单独存在，所以对数据的增加，修改，删除都会产生额外的对索引文件的操作，会降低执行效率。<br> 在删除数据库百万级别数据的时候删除数据的速度和创建的索引数量是成正比的<br> 删除索引、删除其中无用数据、重新创建索引</p><p>通过中间表转换，创建一个临时的新表复制旧表结构，添加字段，再把复制旧表数据，删除旧表，新表改名为旧表，数据可能丢失<br> 用pt-online-schema-change工具在线修改表结构，原理通过中间表<br> 如果一张表数据量大且是热表（读写频繁），先在从库添加再主从切换，再将其他几个节点上添加字段</p><p>主键自增值达到上限后不变。继续插入数据时主键冲突<br> 无主键自增row_id 6字节(0到2^48-1)达到上限后会归0重新递增。row_id重复则覆盖数据。InnoDB维护了全局的dict_sys.row_id，无主键的表插入数据是都用dict_sys.row_id值作为row_id，然后把值加1</p>`,89),p=[o];function l(c,i){return s(),a("div",null,p)}const u=n(t,[["render",l],["__file","mysql.html.vue"]]),k=JSON.parse('{"path":"/interview/db/mysql.html","title":"MySQL","lang":"zh-CN","frontmatter":{"title":"MySQL","date":"2023-01-01T00:00:00.000Z","tags":"java","categories":"面试","description":".1. 数据库三大范式？varchar与char、blob和text区别？DATETIME和TIMESTAMP异同？存储货币、ip、emoji😊？ 第一范式1NF：字段值具有原子性，不能再分。姓名字段如果区分姓和名则分为两个字段 第二范式2NF：满足第一范式基础上，表中每一列都和全部主键相关，而不能只与一部分主键相关（联合主键）。订单表的商品价格只与...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/interview/db/mysql.html"}],["meta",{"property":"og:site_name","content":"JavaGuide"}],["meta",{"property":"og:title","content":"MySQL"}],["meta",{"property":"og:description","content":".1. 数据库三大范式？varchar与char、blob和text区别？DATETIME和TIMESTAMP异同？存储货币、ip、emoji😊？ 第一范式1NF：字段值具有原子性，不能再分。姓名字段如果区分姓和名则分为两个字段 第二范式2NF：满足第一范式基础上，表中每一列都和全部主键相关，而不能只与一部分主键相关（联合主键）。订单表的商品价格只与..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMwfb5fc110878f57454fdbc10ae180c0cf.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"HeChuangJun"}],["meta",{"property":"article:published_time","content":"2023-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL\\",\\"image\\":[\\"https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMwfb5fc110878f57454fdbc10ae180c0cf.png\\",\\"https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMw9eb4a7174ea187aeef637e6655e3ae2f.png\\",\\"https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMw201927a567c82aa72d89af16b57cffd1.jpg\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/eb5eaa6b07dd6988b2e6e.png\\"],\\"datePublished\\":\\"2023-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeChuangJun\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":".1. 数据库三大范式？varchar与char、blob和text区别？DATETIME和TIMESTAMP异同？存储货币、ip、emoji😊？","slug":"_1-数据库三大范式-varchar与char、blob和text区别-datetime和timestamp异同-存储货币、ip、emoji😊","link":"#_1-数据库三大范式-varchar与char、blob和text区别-datetime和timestamp异同-存储货币、ip、emoji😊","children":[]},{"level":2,"title":".2. SQL分类、查第3-10条、SQL执行顺序？√内连接、左连接、右连接、交叉连接、笛卡尔积区别？in/exists，delete、truncate/drop，UNION/UNION ALL，count(1)、count(*)、count(主键|列名)区别？函数,SQL的隐式数据类型转换？","slug":"_2-sql分类、查第3-10条、sql执行顺序-√内连接、左连接、右连接、交叉连接、笛卡尔积区别-in-exists-delete、truncate-drop-union-union-all-count-1-、count-、count-主键-列名-区别-函数-sql的隐式数据类型转换","link":"#_2-sql分类、查第3-10条、sql执行顺序-√内连接、左连接、右连接、交叉连接、笛卡尔积区别-in-exists-delete、truncate-drop-union-union-all-count-1-、count-、count-主键-列名-区别-函数-sql的隐式数据类型转换","children":[]},{"level":2,"title":".3. 基础架构？SQL查询语句如何执行？bin目录下的可执行文件？数据存储形式","slug":"_3-基础架构-sql查询语句如何执行-bin目录下的可执行文件-数据存储形式","link":"#_3-基础架构-sql查询语句如何执行-bin目录下的可执行文件-数据存储形式","children":[]},{"level":2,"title":".4. 常见存储引擎？选择？InnoDB和MylSAM区别？","slug":"_4-常见存储引擎-选择-innodb和mylsam区别","link":"#_4-常见存储引擎-选择-innodb和mylsam区别","children":[]},{"level":2,"title":".5. 日志文件及作用？更新语句执行流程？为什么要两阶段提交？binlog和redolog区别？redo log怎么刷入磁盘的？","slug":"_5-日志文件及作用-更新语句执行流程-为什么要两阶段提交-binlog和redolog区别-redo-log怎么刷入磁盘的","link":"#_5-日志文件及作用-更新语句执行流程-为什么要两阶段提交-binlog和redolog区别-redo-log怎么刷入磁盘的","children":[]},{"level":2,"title":".6. 索引分类？原理√为什么InnoDB要使用B+树作为索引？不用普通、平衡二叉树、红黑树、B树√？B+树能存储多少条数据呢？Hash、B+树索引，聚簇索引与非聚簇索引区别？回表？覆盖索引？索引下推优化？最左匹配原则？","slug":"_6-索引分类-原理√为什么innodb要使用b-树作为索引-不用普通、平衡二叉树、红黑树、b树√-b-树能存储多少条数据呢-hash、b-树索引-聚簇索引与非聚簇索引区别-回表-覆盖索引-索引下推优化-最左匹配原则","link":"#_6-索引分类-原理√为什么innodb要使用b-树作为索引-不用普通、平衡二叉树、红黑树、b树√-b-树能存储多少条数据呢-hash、b-树索引-聚簇索引与非聚簇索引区别-回表-覆盖索引-索引下推优化-最左匹配原则","children":[]},{"level":2,"title":".7. 锁分类？如何解决库存超卖问题？行锁实现？意向锁？","slug":"_7-锁分类-如何解决库存超卖问题-行锁实现-意向锁","link":"#_7-锁分类-如何解决库存超卖问题-行锁实现-意向锁","children":[]},{"level":2,"title":".8. MySQL事务特性？怎么保证？并发事务问题？事务隔离级别？默认？实现？MVCC实现原理？会加锁吗？","slug":"_8-mysql事务特性-怎么保证-并发事务问题-事务隔离级别-默认-实现-mvcc实现原理-会加锁吗","link":"#_8-mysql事务特性-怎么保证-并发事务问题-事务隔离级别-默认-实现-mvcc实现原理-会加锁吗","children":[]},{"level":2,"title":".9. 数据库读写分离？分配怎么实现？主从复制原理了解吗？主从同步延迟原因？处理？百万级别以上的数据如何删除？添加字段？自增id用完怎么办？","slug":"_9-数据库读写分离-分配怎么实现-主从复制原理了解吗-主从同步延迟原因-处理-百万级别以上的数据如何删除-添加字段-自增id用完怎么办","link":"#_9-数据库读写分离-分配怎么实现-主从复制原理了解吗-主从同步延迟原因-处理-百万级别以上的数据如何删除-添加字段-自增id用完怎么办","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":32.78,"words":9833},"filePathRelative":"interview/db/mysql.md","localizedDate":"2023年1月1日","excerpt":"<!--more-->\\n<h2>.1. 数据库三大范式？varchar与char、blob和text区别？DATETIME和TIMESTAMP异同？存储货币、ip、emoji😊？</h2>\\n<p>第一范式1NF：字段值具有原子性，不能再分。姓名字段如果区分姓和名则分为两个字段<br>\\n第二范式2NF：满足第一范式基础上，表中每一列都和全部主键相关，而不能只与一部分主键相关（联合主键）。订单表的商品价格只与商品ID相关，与订单ID无关<br>\\n第三范式3NF：满足第二范式基础上，表中每一列都和主键直接相关，而不能间接相关。订单表的订单编号和商品编号，商品名称与商品ID相关再与订单相关，应拆分为订单表、订单商品关联表、商品表<br>\\n控制数据冗余，节省空间，可冗余数据，空间换时间，避免跨表跨库查询，提高性能</p>","autoDesc":true}');export{u as comp,k as data};
