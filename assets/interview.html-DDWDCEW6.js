import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as r,c as d,a as e,b as i,d as l,e as a}from"./app-7KT7HDzT.js";const v={},c=a('<h1 id="自我介绍" tabindex="-1"><a class="header-anchor" href="#自我介绍"><span>自我介绍</span></a></h1><ul><li><p>面试官早上好，我是xxx，来自广东清远，2018年从广东药科大学制药工程专业毕业，目前有5年java开发经验，做过传统医疗项目和互联网社交项目，在项目里面使用过springboot、mybatis框架、redis分布式缓存组件，rabbitmq消息队列，mysql数据库等，在上一份工作中负责核心模块开发，参与过需求评审和数据库设计，有在linux上排查线上问题的经验。希望能加入贵公司担任java开发工程师，谢谢</p></li><li><p>Good morning, interviewer, My name is xxx,I come from Qingyuan,a city in Guangdong Province. I was graduated from Guangdong Pharmaceutical University in 2018, majoring in pharmaceutical engineering. l have been working as a java development engineer for 5 years, and have done traditional medical projects and Internet social projects, in which I have used springboot, mybatis framework and redis distributed cache component. rabbitmq message queue, mysql database, etc. In my last job, I was responsible for core module development, participated in requirement review and database design, and had experience in troubleshooting online problems on linux. I hope I can make a good performance today. That’s all. Thank you for giving me the chance.</p></li><li><p>面试官早上好，我是xxx，广东清远人，18年广东药科大学毕业，制药工程专业，目前住在天河梅花园，是一个i人，平时喜欢看书跑步，与陌生人熟悉后就会变成e人，乐观开朗</p></li></ul><h1 id="场景设计" tabindex="-1"><a class="header-anchor" href="#场景设计"><span>场景设计</span></a></h1><ul><li>先完成再完美：我想了一下可以这么做，时间有限，可能有些不合理地方，然后说方案</li><li>想到多少说多少，部分也没关系</li><li>不会就坦诚说还有xx部分，因为xx地方没有想到，可不可以给点提示</li><li>不知道选什么方案就提出选择困难原因</li></ul><h1 id="遇到不懂的地方" tabindex="-1"><a class="header-anchor" href="#遇到不懂的地方"><span>遇到不懂的地方</span></a></h1><ul><li>没听清，不好意思你是指xxx内容还是xxx内容，把范围缩小，不会就不要说</li><li>不懂，这个我不大了解，我猜是这样的或者我没怎么了解，但我知道xxxx和它差不多，也能做到zzz目的</li></ul><h1 id="项目" tabindex="-1"><a class="header-anchor" href="#项目"><span>项目</span></a></h1><ul><li>项目难点或者亮点？</li><li>项目为什么用？而不用？为什么这么设计？</li><li>项目描述 <ul><li>1.项目的背景(这个项目解决什么问题)，1分钟以内要描述完</li><li>2.项目包含的功能/模块，简单说明每个功能的作用</li><li>3.你参与并负责的横块</li><li>4.项目采用的技术架构</li><li>5.项目中的难点、亮点和个人的成长 <ul><li>1.体现你解决问题的能力</li><li>2.体现你的学习能力</li><li>3.体现你的架构思维</li><li>4.体现你的团队协作能力</li><li>5.体现你的管理能偶</li><li>6.体现你的技术能力</li><li>也就是只要能够体现上述这些能力的，都可以去总结出来，不一定是高并发/高性能的一些事情比如独立从0到1搭建微服务架构、第一次参与线上问题的诊断和解决</li></ul></li></ul></li></ul><h1 id="你有没有什么想问的" tabindex="-1"><a class="header-anchor" href="#你有没有什么想问的"><span>你有没有什么想问的？</span></a></h1><ul><li>如果职位描述没有写部门或者业务，可以问具体做什么业务，团队规模多少</li><li>就刚才的面试，你觉得我还有哪些地方需要加强的地方</li><li>您当初选择这家公司的原因是什么呢?</li><li>团队氛围如何，平时几点下班</li></ul><h1 id="面试复盘" tabindex="-1"><a class="header-anchor" href="#面试复盘"><span>面试复盘</span></a></h1><ul><li>遇到不懂或者回答不好的问题，面试结束后要弄懂</li></ul><h1 id="hr面" tabindex="-1"><a class="header-anchor" href="#hr面"><span>hr面</span></a></h1><ul><li><p>人生、对方公司情况和谈薪资，卡涨幅30%</p></li><li><p>压工资，可以说有一个offer，对方给了xxx，但自己更希望来贵公司+理由，希望薪资可以给到</p></li><li><p>谈薪资：</p><ul><li>1薪资结构&amp;发放时间。 <ul><li>薪资结构一般包括无责底薪+绩效+提成+奖金+各种补贴+年终奖+其他福利</li><li>发放时间：最好15号前</li><li>年终奖13、14薪</li><li>税前税后</li><li>调薪制度，一年一般10%</li></ul></li><li>2劳动合同&amp;试用期： <ul><li>注意:劳动法规定劳动合同期限在6个月到一年的，试用期最长不超过30天;</li><li>劳动合同期限在一年以上三年以下的，试用期最长不得超过 60天;</li><li>劳动合同期限在三年以上的，试用期不得超过6个月。试用期最长不得超过六个月，</li><li>试用期工资折扣不得低于正式工资的 80%(一般面试的时候问好)</li></ul></li><li>3福利待遇 福利待遇一般包括房补、话补、交通补贴、餐补等福利</li><li>4五险一金： <ul><li>注意:五险一金包括:养老保险+医疗保险+失业保险+工伤保险+生育保险+住房公积金，缴纳基数和比例</li><li>六险一金：在五险一金的基础上增加、收起.业保险，即大病保险，是一种补充医疗保，缴纳基数和比例</li></ul></li><li>工作时间，双休单休</li><li>年假：已满1年不满10年的，年休假5天;已满10年不满20年的，年休假10天;已满20年的，年休假15天;国家法定休假日、休息日不计入年休假的假期。年假应享与正常工作期间相同的工资收入</li><li>年终</li><li>加班费</li><li>晋升渠道，升职</li><li>打卡</li><li>补贴</li></ul></li><li><p>工作内容</p></li><li><p>优点</p><ul><li>学习方面:学习能力强，能够较快的攻克一些比较难的任务</li><li>生活方面:积极乐观:行动力强;喜欢复盘，对自己有长期规划和短期规划:定好目标就会坚持不懈的走下去，有韧性;比较活泼外向一些，喜欢与人交际，也有很多好朋友。</li></ul></li><li><p>缺点(从另一个角度看就是优点，切记不能说纯缺点)</p><ul><li>有点强迫症，会对任务的细节核对多遍，比如发送重要的邮件，就会把收信人还有邮件内容检查两遍但其他人可能不会检查，我这样子就有点浪费时间了。</li><li>有点钻牛角尖，尤其在学习新的知识时，我有个点不懂就会去找资料，必须把他搞懂，或者至少理解个大概才会放手，这个过程很花时间，但我不这样子做的话就难受。之后我的朋友给我说他们的方法就是把不懂的先放着，等学了别的知识，再返回来看这个知识点就触类旁通了，我目前也在慢慢地对情况进行分类讨论，有的用我之前方法，有的用我朋友给我说的方法，效果也不错。</li></ul></li><li><p>兴趣爱好</p><ul><li>喜欢爬山、徒步这些户外活动。不仅可以亲近大自然，而且可以不断挑战自己体能的极限，我很喜欢这种突破自我带给我的成就感。</li><li>喜欢运动，尤其是一些球类运动，比如羽毛球、乒乓球，我一般周末会叫上好朋友一起，这种竞技活动不仅可以增加朋友间的感情，而且可以释放大量多巴胺，缓解一周的工作压力;</li><li>喜欢阅读，在工作学习之余，喜欢读一些人物传记、散文之类的文学书籍，也喜欢看一些能拓宽视野的纪录片。</li></ul></li></ul><h1 id="其他问题" tabindex="-1"><a class="header-anchor" href="#其他问题"><span>其他问题</span></a></h1><ul><li><p>你有什么缺点?由于我习惯自学，导致有时候很容易陷入误区走不出来。陷入误区的原因一般是这个部分的自身基础不牢靠,或者是公司内部的文档资料不齐全我可能需要花费比较多的时间在自我纠结上。不过我目前也在改善这个问题，以后会好好利用新人多问不会被骂的权利</p></li><li><p>职业规划是什么？希望能够在这个岗位上做到独当一面，负责一些大的、跨组的大事项。当然如果伴随着能力的提升，能够有带人或者带团队的机会我也会去提升其他相关的技能，提升自己的管理能力。</p></li><li><p>对加班怎么看?刚进去公司加班很正常，因为一切都不熟悉，我会为了快速上手业务、迅速融入团队而加班。随着工作熟练度的提升，单位时间内的产出会相对有所增加，在产出符合预期的情况下，预计工作时间应该是有些缩短的。这时候如果遇到紧急的业务需求或者是业务扩张而人手不足的情况，我是能接受加班的直至人手扩充。但如果说加班并不是因为个人产出或者紧急的需求，而是因为一些流程之类的问题，我觉得加班并不是能根本解决问题的方式。</p></li><li><p>怎么处理上级冲突?和上级发生冲突的时候，我首先做的是积极和上级沟通自己的想法，同时列出自己的论据，然后也会去了解上级的想法。最终会保证在以公司利益为前提下达成一致，这个过程中可能会引入其他同事。团队内达成一致才能为一个共同目标去努力。我认为意见冲突是没法避免的，合理的讨论才能聚集团队的智慧，提升团队纠错能力</p></li></ul><h1 id="离职原因" tabindex="-1"><a class="header-anchor" href="#离职原因"><span>离职原因</span></a></h1><p>在原公司所负责的工作内容比较单一且重复性比较高，无法满足我个人的职业发展需求。我想找一个更有挑战性并且有更大成长空间的工作。而贵公司的情况非常符合我的预期:<br> 首先，我很认可贵公司所推崇的人性化管理，非常符合我对工作环境的预期，我也相信在这样的环境中，我能发挥更大的主观能动性。<br> 并且我非常看好贵公司所处的行业和所做的事，如果我能有幸加入贵公司，相信一定能和贵公司一起发展、共同进步。</p><h1 id="_1-what-do-you-know-about-us" tabindex="-1"><a class="header-anchor" href="#_1-what-do-you-know-about-us"><span>1. What Do You Know About Us?</span></a></h1>',19),u={href:"http://1865.lt",target:"_blank",rel:"noopener noreferrer"},o={href:"http://organizations.lt",target:"_blank",rel:"noopener noreferrer"},b=e("br",null,null,-1),m=a(`<h1 id="_2-tell-us-about-yourself" tabindex="-1"><a class="header-anchor" href="#_2-tell-us-about-yourself"><span>2.Tell Us About Yourself</span></a></h1><p>I am an accountant with seven years of experience.l haveworked in several departments, with the recent one beingcredit and loans.l have vast experience with differentaccounting software that will benefit me in this job. Being indifferent teams also means that l can fit well in teamsettings and deliver in collaborative work. l believe that allthe skills l have gathered over time have prepared me forthis job.<br> 我是一名有七年经验的会计。我在好几个部门工作过，最近的一次是信贷部门。我对各种会计软件有丰富的经验，这对我做这份工作很有帮助。作为冷漠的团队也意味着我可以很好地适应团队环境，并在协作工作中交付成果。我相信这些年来我所学到的技能已经为这份工作做好了准备。</p><h1 id="why-do-you-want-to-work-of-us" tabindex="-1"><a class="header-anchor" href="#why-do-you-want-to-work-of-us"><span>Why Do You Want to Work Of Us?</span></a></h1><p>I want a career in banking and feel that this is the bestplace to grow my career and be better at what l do. l havealso had the chance to talk to some of your former andcurrent employees, and they all agree that this is the bestworkplace for anybody who wants to advance. AdditionallyI would be proud to work in a company that has beenfeatured in the Times repeatedly.l will use all my skills,expertise and experiences to succeed in this job<br> 我想在银行工作，我觉得这是我事业发展的最好的地方，也是我做得更好的地方。我也有机会与贵公司的一些前任和现任员工交谈过，他们都认为对于任何想要晋升的人来说，这是最好的工作场所。此外，我很自豪能在一家多次登上《纽约时报》专题报道的公司工作。我将运用我所有的技能、专业知识和经验来做好这份工作</p><h1 id="why-should-we-hire-you" tabindex="-1"><a class="header-anchor" href="#why-should-we-hire-you"><span>Why Should We Hire You?</span></a></h1><p>I am a customer service executive with over ten years nfexperience.lhave strong communication skills that will help me efficiently manage inbound and outbound callsand resolve customer queries. l am also a quick learnerand can work well under pressure.l can electronicallyprocess data and respond to any customer queriestouching on banking transactions across the world<br> 我是一名有十多年经验的客户服务主管。我有很强的沟通技巧，这将帮助我有效地管理呼入和呼出电话，并解决客户的疑问。我学东西很快，能在压力下很好地工作。我可以用电子方式处理数据，并对任何涉及全球银行交易的客户查询作出回应</p><h1 id="_5-some-of-our-positions-have-routinetasks-what-do-you-think-about-such" tabindex="-1"><a class="header-anchor" href="#_5-some-of-our-positions-have-routinetasks-what-do-you-think-about-such"><span>5.Some of Our Positions Have RoutineTasks.What Do You Think about Such?</span></a></h1><p>I believe that i handle routine work quite well from my previous experience.lusually stay in the moment ancremain focused all through, which allows me to satisfycustomer needs.l also maintain high levels of accuracyand timeliness regardless of how repetitive thie jobs are<br> 根据我以前的经验，我相信我能很好地处理日常工作。我通常专注于当下，始终保持专注，这使我能够满足客户的需求。我也要保持高水平的准确性和及时性，不管工作有多重复</p><h2 id="_15-5-例子16" tabindex="-1"><a class="header-anchor" href="#_15-5-例子16"><span>15.5. 例子16</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>package c_019_m;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

/**
 * 面试（淘宝？）
 * 实现一个容器，提供两个方法，add，size
 * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到达5时，线程2给出提示并结束
 */
public class MyContainer3 {

    private List&lt;Object&gt; list = new ArrayList&lt;&gt;();

    public void add(Object ele) {
        list.add(ele);
    }

    public int size() {
        return list.size();
    }

    public static void main(String[] args) {

        MyContainer3 container = new MyContainer3();

        final Object lock = new Object();

        new Thread(() -&gt; {
            synchronized (lock) {
                System.out.println(&quot;t2 启动&quot;);
                if (container.size() != 5) {
                    try {
                        lock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                System.out.println(&quot;监测到容器长度为5，线程2立即退出&quot;);
                lock.notify();
            }
        }, &quot;t2&quot;).start();

        // 先启动t2线程，让t2线程进入等待状态
        try {
            TimeUnit.SECONDS.sleep(2);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        new Thread(() -&gt; {
            synchronized (lock) {
                for (int i = 0; i &lt; 10; i++) {
                    container.add(new Object());
                    System.out.println(&quot;add &quot; + i);
                    // 当长度为5时，通知 t2 进行退出
                    if (container.size() == 5) {
                        lock.notify(); // notify 不会释放锁，即便通知t2，t2也获取不到锁
                        // 可以在wait一下，将锁释放，再让t2通知t1继续执行
						//notify不能唤醒特定线程，由cpu决定的
						//notify会让线程从上次的wait的地方继续执行
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    try {
                        TimeUnit.SECONDS.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        }, &quot;t1&quot;).start();
    }

}

/*
使用wait和notify
wait()与notify() 方法的调用必须在同步代码块中
wait会释放锁，notify不会释放锁，一般不要用
锁定对象a，调用a.wait() 方法，当前线程就会进入等待状态，然后释放锁。
当某线程调用 a.notify() / a.notifyAll()， 叫醒在a对象等待的所有线程
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_15-6-例子17" tabindex="-1"><a class="header-anchor" href="#_15-6-例子17"><span>15.6. 例子17</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>package c_019_m;

import java.sql.Time;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * 面试（淘宝？）
 * 实现一个容器，提供两个方法，add，size
 * 写两个线程，线程1添加10个元素到容器中，线程2实现监控元素的个数，当个数到达5时，线程2给出提示并结束
 */
public class MyContainer5 {

    private volatile List&lt;Object&gt; list = new ArrayList&lt;&gt;();

    public void add(Object ele) {
        list.add(ele);
    }

    public int size() {
        return list.size();
    }

    public static void main(String[] args) {

        MyContainer5 container = new MyContainer5();

        // Count down 往下数  Latch 门闩
        // 门闩不能保证可见性，不是一种同步方式，只是一种线程通信方式，保证不了可见性
        // 门闩的等待，不会持有任何锁
        CountDownLatch latch = new CountDownLatch(1);

        new Thread(() -&gt; {
            System.out.println(&quot;t2 启动&quot;);
            if (container.size() != 5) {
                try {
                    latch.await();
                    // 指定等待时间
                    //latch.await(5000, TimeUnit.MILLISECONDS);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println(&quot;监测到容器长度为5，线程2立即退出&quot;);
        }, &quot;t2&quot;).start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -&gt; {
            System.out.println(&quot;t1 启动&quot;);
            for (int i = 0; i &lt; 10; i++) {
                container.add(new Object());
                System.out.println(&quot;add &quot; + i);
                // 当长度为5时，撤掉一个门闩，此时门闩为0，门会打开，即t2会继续执行
                if (container.size() == 5) {
                    latch.countDown();
                }
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, &quot;t1&quot;).start();
    }

}

/*

使用CountDownLatch实现（最简单的方式）

Latch：门闩


使用Latch替代 wait notify来进行通信
好处是，通信简单，同时也可以指定等待时间
使用await和countDown 方法替代 wait 和 notify
CountDownLatch不涉及锁定，当count值为0时，当前线程继续运行
当不涉及同步，只涉及线程通信的时候，用synchronized + wait + notify 就显得太重了
 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_15-7-例子6" tabindex="-1"><a class="header-anchor" href="#_15-7-例子6"><span>15.7. 例子6</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>package c_021_m;

import java.util.LinkedList;

/**
 * 经典面试：写一个固定容量的容器，拥有put和get方法，以及getCount方法
 * 能够支持2个生产者线程以及10个消费者线程的阻塞调用
 * 
 * 点：生产者消费者模式
 * 
 * 如果调用 get方法时，容器为空，get方法就需要阻塞等待
 * 如果调用 put方法时，容器满了，put方法就需要阻塞等待
 * 
 * 实现方式：
 * 1. wait/notify
 * 2. Condition
 */
public class MyContainer1&lt;T&gt; {
    
    private final LinkedList&lt;T&gt; list = new LinkedList&lt;&gt;();
    private final int MAX = 10;
    private int count = 0;

    public synchronized void put(T t) {
        while (MAX == count) { // 如果容量最大，释放锁等待    ///【这里为什么使用while，而不是使用if？？？】
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 否则 put 
        list.add(t);
        ++count;
        this.notifyAll(); // 通知消费者线程，可以消费了
        // 【这里为什么调用 notifyAll 而不是 notify ？】
    }

    public synchronized T get() {
        while (list.size() == 0) { // 如果容量为空，释放锁等待  
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // 否则获取
        T t = list.removeFirst();
        count--;
        this.notifyAll(); // 通知生产者线程生产
        return t;
    }
}

/*

为什么使用while 而不是使用 if ？？？
在与wait()的配合中，百分之99的程序都是与while而不是if结合使用。
上述代码中，在容器已满的情况下，put方法会wait等待，当容器中的元素被消费者消费了一部分，就会唤醒所有put方法，
put方法会继续向下执行，直接执行list.add(t)，那么多个生产者线程执行list.add() 就有可能出现数据一致性的问题。
如果使用while则会循环判断，就避免了这些问题。

不是有锁吗？为什么会需要循环判断？
wait之后，锁就会失去，再次被唤醒时，并且得到锁之后，**是从list.add()开始执行的**，会无判断直接加入到容器中。


为什么调用 notifyAll 而不是 notify ？
因为notify有可能再次叫醒一个生产者线程


 */
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_15-8-例子7" tabindex="-1"><a class="header-anchor" href="#_15-8-例子7"><span>15.8. 例子7</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>package c_021_m;

import java.util.LinkedList;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 经典面试：写一个固定容量的容器，拥有put和get方法，以及getCount方法
 * 能够支持2个生产者线程以及10个消费者线程的阻塞调用
 * &lt;p&gt;
 * 点：生产者消费者模式
 * &lt;p&gt;
 * 如果调用 get方法时，容器为空，get方法就需要阻塞等待
 * 如果调用 put方法时，容器满了，put方法就需要阻塞等待
 * &lt;p&gt;
 * 实现方式：
 * 1. wait/notify
 * 2. Condition
 * &lt;p&gt;
 * &lt;p&gt;
 * 使用Lock和Condition实现，可以精确唤醒某些线程
 */
public class MyContainer2&lt;T&gt; {

    private final LinkedList&lt;T&gt; list = new LinkedList&lt;&gt;();
    private final int MAX = 10;
    private int count = 0;

    private Lock lock = new ReentrantLock();
    private Condition producer = lock.newCondition();
    private Condition consumer = lock.newCondition();


    public synchronized void put(T t) {
        lock.lock();
        try {
            while (MAX == count) {
                producer.await();
            }
            list.add(t);
            ++count;
            consumer.signalAll();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public synchronized T get() {
        lock.lock();
        try {
            while (list.size() == 0) {
                consumer.await();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
        T t = list.removeFirst();
        count--;
        producer.signalAll();
        return t;
    }

    public static void main(String[] args) {
        MyContainer2&lt;String&gt; c = new MyContainer2&lt;&gt;();
        // 启动消费者线程
        for (int i = 0; i &lt; 10; i++) {
            new Thread(() -&gt; {
                for (int j = 0; j &lt; 5; j++) {
                    System.out.println(c.get());
                }
            }, &quot;c_&quot; + i ).start();
        }

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        for (int i = 0; i &lt; 2; i++) {
            new Thread(()-&gt;{
                for (int j = 0; j &lt; 2; j++) {
                    c.put(Thread.currentThread().getName() + &quot; &quot; + j);
                }
            }, &quot;p_&quot; + i).start();
        }
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_21-vue是如何实现数据双向绑定的" tabindex="-1"><a class="header-anchor" href="#_21-vue是如何实现数据双向绑定的"><span>21. vue是如何实现数据双向绑定的</span></a></h1><h1 id="_22-vue怎么实现对象和数组监听" tabindex="-1"><a class="header-anchor" href="#_22-vue怎么实现对象和数组监听"><span>22. vue怎么实现对象和数组监听</span></a></h1><h1 id="_23-mybatis执行流程顺序排序" tabindex="-1"><a class="header-anchor" href="#_23-mybatis执行流程顺序排序"><span>23. mybatis执行流程顺序排序</span></a></h1><p>(1)读取 MyBatis 配置文件 mybatis-config.xml。mybatis-config.xml作为MyBatis 的全局配置文件，配置了 MyBatis的运行环境等信息，其中主要内容是获取数据库连接。<br> (2)加载映射文件 Mapper.xml。Mapper.xml 文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 mybatis-config.xml 中加载才能执行。mybatis-config.xml可以加载多个配置文件，每个配置文件对应数据库中的一张表。<br> (3)构建会话工厂。通过 MyBatis 的环境等配置信息构建会话工厂SqlSessionFactory。<br> (4)创建SqlSession 对象。由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 的所有方法。<br> (5)在 Executor 接口的执行方法中，包含一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL语句的id、参数等。<br> Mapper.xml文件中一个 SQL 对应一个 MappedStatement对象，SQL的id即是 MappedStatement 的 id。<br> (6)MyBatis底层定义了一个Executor接口来操作数据库,它会根据SqlSession传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。<br> (7)输入参数映射。在执行方法时，MappedStatement 对象会对用户执行 SQL语句的输入参数进行定义(可以定义为 Map、List类型、基本类型和 POJO类型)，Executor 执行器会通过 MappedStatement 对象在执行 SQL 前，将输入的Java 对象映射到 SQL 语句中。这里对输入参数的映射过程就类似于 JDBC编程中对 preparedStatement 对象设置参数的过程。<br> (8)输出结果映射。在数据库中执行完 SQL 语句后，MappedStatement 对象会对 SQL 执行输出的结果进行定义(可以定义为 Map 和 List类型、基本类型、POJO类型)，Executor 执行器会通过 MappedStatement 对象在执行 SQL 语句后，将输出结果映射至 Java 对象中。这种将输出结果映射到 Java 对象的过程就类似于 JDBC编程中对结果的解析处理过程。</p><p>2、关于 mybatis，请找出错误的描述。<br> 1、Configuration:用于描述 JDBC 主配置文件信息，MyBatis 框架在启动完成以后会加载主配置文件，将配置信息转换为 Configuration 对象。<br> 2、SqlSession:面向用户的 API，是 JDBC 与数据库交互的接口。<br> 3、Executor:SQL 执行器,用于和数据库交互.SqlSession 可以理解为 Executor组件的外观，真正执行 SQL 的是 SqlSession 组件。<br> 4、MappedStatement:用于描述SQL配置信息，MyBatis 框架启动时，XML文件或者注解配置的SQL信息会被转换为MappedStatement对象注册到Configuration 组件中。<br> 5、StatementHandler:封装了对JDBC中Statement 对象的操作，包括为Statement 参数占位符设置值，通过 Statement 对象执行 SQL语句<br> 6、TypeHandler:类型处理器，用于Java类型与基础类型之间的转换。<br> 7、ParameterHandler:用于处理 SQL中的参数占位符，为参数占位符设置值。<br> 8、ResultSetHandler:封装了对Set对象的处理逻辑，将结果集转换为Java实体对象</p><p>3、关于 mybatis 流程，请排好下列顺序?<br> 1、加载 mybatis 全局配置文件(数据源、mapper映射文件等)<br> 2、解析配置文件<br> 3、SqlSessionFactoryBuilder 通 过Configuration对象生成SqlSessionFactory<br> 4、MyBatis 基于 XML 配置文件生成 Configuration<br> 5、和一个个 MappedStatement(包括了参数映射配置、动态 SQL 语句、<br> 结果映射配置)，其对应着<code>&lt;select|update|delete|insert&gt;</code>标签项。</p><p>4、Mybatis 中的 SQLSession 流程请排好下列顺序<br> a、用户程序调用 mybatis 接口层 api(即 Mapper 接口中的方法)<br> b、通过 Executor(负责动态 SQL的生成和查询缓存的维护)将MappedStatement 对象进行解析<br> c、使用 Paramterhandler 填充参数，使用 statementHandler绑定参数<br> d、sql 参数转化、动态 sql 拼接，生成 jdbc Statement 对象<br> e、SqlSession 通过调用 api的StatementID 找到对应的 MappedStatement 对象<br> f、JDBC 执行 sql也行数<br> g、使用 ResultSetHandler 将返回结果转化成 HashMap、JavaBean等存储结构并返回<br> h、借助 MappedStatement中的结果映射关系<br> i、关闭 sqlsession 会话</p><p>5、判断关于 springcloud config 配置中心下列说法对错<br> 1、配置服务器:为配置客户端提供其对应的配置信息，配置信息的来源为配置仓库，启动时即拉取配置仓库的信息，缓存到本地仓库中。<br> 2、配置客户端:除了配置服务器之外的应用服务，启动时从配置服务器拉取其对应的配置信息。<br> 3、配置仓库:为配置服务器提供配置源信息，配置仓库的实现可以支持多种方式。</p><p>6、关于 Spring Cloud Config 构建判断下列操作是否正确，如果是错误的，请说明理由<br> 构建 Spring cloud config 配置中心<br> 1、创建一个普通的 Spring Boot 项目<br> 2、在 pom.xml 文件中添加 config-server 依赖<br> 3、在入口类，也就是 main 方法的类上添加注解 @EnableConfigServer<br> 4、在 application.properties 中配置一下 git 仓库信息，此处我们使用<br> GitHub( 也可以使用码云 gitee)。<br> 接口 URL:/{application}/{profile}/{label}<br> 构建 Springcloud config 配置中心仓库<br> 接下来我们需要在 github 上设置好配置中心，首先在本地创建一个文件夹叫wkcto，然后在里面创建一个文件夹叫 config-center，然后在 config-center 中创建四个配置文件。<br> 经过对 wkcto 目录下的文件进行操作后，最终使用 git push 推送到远程仓库，然后启动我们的配置中心，通过/{application}/{profile}/{label}就能访问到我们的配置文件了。</p><p>构建 Spring cloud config 配置中心客户端<br> 1、创建一个普通的 Spring Boot 工程 08-springcloud-config-client，并添加<br> starter-conifd 依赖.<br> 2、创建 bootstrap.properties 文件，用于获取配置信息。<br> name 对应配置文件中的 application 部分，profile 对应了 profile 部分，label<br> 对应了 label 部分，uri 表示配置中心的地址。<br> 然后使用@RefreshScope 进行对配置文件的刷新，接下来就是用 Spring 自带<br> 注解可以获取配置内容。例如@value</p><p>7、关于配置中心执行流程，判断下图的是否正确，如果不正确，请说明理由。<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/f4fe8a438b4fca2f17b6b.png" alt="配置中心执行流程.jpg"></p><p>8、为下列 Eureka 工作流程排序<br> 1、Eureka Server 启动成功，等待服务端注册。在启动过程中如果配置了集群，集群之间定时通过 Replicate 同步注册表,每个 Eureka Server 都存在独立完整的服务注册表信息<br> 2、Eureka Client 启动时根据配置的 Eureka Server 地址去注册中心注册服务<br> 3、Eureka Client 会每 30s 向 Eureka Server 发送一次心跳请求，证明客户端服务正常<br> 4、当 Eureka Server 90s 内没有收到 Eureka Client 的心跳，注册中心则认为该节点失效，会注销该实例<br> 5、单位时间内 Eureka Server 统计到有大量的 Eureka Client 没有上送心跳，则认为可能为网络异常，进入自我保护机制，不再剔除没有上送心跳的客户端流移<br> 6、当 Eureka Client 心跳请求恢复正常之后，Eureka Server 自动退出自我保护模式<br> 7、Eureka Client 定时全量或者增量从注册中心获取服务注册表，并且将获取到的信息缓存到本地<br> 8、服务调用时，Eureka Client 会先从本地缓存找寻调取的服务。如果获取不到，先从注册中心刷新注册表，再同步到本地缓存<br> 9、Eureka Client 获取到目标服务器信息，发起服务调用<br> 10、Eureka Client 程序关闭时向 Eureka Server 发送取消请求，Eureka Server 将实例从注册表中删除</p><p>9、springGateway 的执行流程排序<br> 1、接受请求<br> 2、寻找路由规则<br> 3、WEB 过滤器链<br> 4、请求转发<br> 5、核心过滤器链执行<br> 6、响应回写</p><p>10、补充或者删除 Redis 的基本数据结构类型<br> 1、String<br> 2、Hash<br> 3、ArrayList<br> 4、HashSet<br> 5、zset</p><p>11、关于 redis 使用，判断下列措施是否正确<br> MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis中的数据都是热点数据<br> 位<br> 措施:redis 内存数据集大小上升到一定大小的时候，就施行数据淘汰策略。</p><p>12、Redis 适合的场景正确的有哪些，错误的有哪些<br> (1)会话缓存V<br> (2)队列 V<br> (3)排行榜/计数器V<br> (4)发布/订阅</p><p>13、MongoDB 是否支持数据类型，如果不对请标记出来<br> 1、String<br> 2、Integer<br> 3、Double<br> 4、Boolean<br> 5、Object<br> 6、Object ID<br> 7、Arrays<br> 8、Min/Max Keys<br> 9、Datetime<br> 10、Code<br> 11、Regular Expression 等</p><p>14、请为下列 rabbitmq 生产者发送消息的流程排序 )，<br> 1、生产者连接 RabbitMQ，建立TCP 连接(Connection)，开启信道(Channel)<br> 2、生产者声明一个 Exchange(交换器)，并设置相关属性，比如交换器类型、是否持久化等<br> 3、生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等<br> 4、生产者通过 bindingKey(绑定 Key)将交换器和队列绑定(binding)起来<br> 5、生产者发送消息至 RabbitMQBroker，其中包含routingKey(路由键)、交换器等信息<br> 6、相应的交换器根据接收到的 routingKey 查找相匹配的队列。<br> 7、如果找到，则将从生产者发送过来的消息存入相应的队列中。<br> 8、如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者<br> 9、关闭信道。<br> 10、关闭连接。</p><p>15、请为下列 rabbitmq 消费者接收消息的流程排序<br> 1、消费者连接到 RabbitMQ Broker ，建立一个连接(Connection)，开启一个信道(Channel)。<br> 2、消费者向 RabbitMQ Broker 请求消费相应队列中的消息,可能会设置相应的回调函数，以<br> 及做一些准备工作<br> 3、等待 RabbitMQ Broker 回应并投递相应队列中的消息， 消费者接收消息。<br> 4、消费者确认(ack) 接收到的消息。<br> 5、RabbitMQ 从队列中删除相应己经被确认的消息。<br> 6、关闭信道。<br> 7、关闭连接。</p><h1 id="_17-逻辑题" tabindex="-1"><a class="header-anchor" href="#_17-逻辑题"><span>17. 逻辑题</span></a></h1><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>P先生、Q先生具有足够的推理能力。他们知道桌子的抽屉里有16张扑克牌：
红桃 A Q 4
黑桃 J 8 4 2 7 3
草花 K Q 5 4 6
方块 A 5
约瀚教授从这16张牌中挑出一张牌来，并把这张牌的点数告诉P先生，把这张牌的花色告诉Q先生。约翰教授问P先生和Q先生：你们能从已知的点数或花色中推知这张牌是什么牌吗？
P先生：&quot;我不知道这张牌。&quot;
Q先生：&quot;我知道你不知道这张牌。&quot;
P先生：&quot;现在我知道这张牌了。&quot;
Q先生：&quot;我也知道了。&quot;

请问这张牌是什么牌？
答案：方块5

第一句话表明点数有重复
第二句话表明对应花色中全部都是有重复的点数，所以是红桃或者方块
第三句话，首先排除了A，剩下Q, 4，5
第四句话既然知道花色就能确定只能是方块5了
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>有甲、乙、丙三个学生，一个出生在北京，一个出生在上海，一个出生在武汉；他们中一个学国际金融专业，一个学工商管理专业，一个学外语。其中：I.甲不是学国际金融的，乙不是学外语的。II．学国际金融的不出生在上海。III．学外语的出生在北京。IV．乙不出生在武汉。请根据上述条件，判断甲的专业；（） A．国际金融B．工商管理C．外语D．三种专业都可能

答案： C
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_16-4-计算n的阶乘的末尾有几个0√" tabindex="-1"><a class="header-anchor" href="#_16-4-计算n的阶乘的末尾有几个0√"><span>16.4. 计算n的阶乘的末尾有几个0√</span></a></h2>`,39),p={href:"http://www.99cankao.com/statistics/factorial-calculator.php",target:"_blank",rel:"noopener noreferrer"},h=e("br",null,null,-1),g=a(`<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public static int SelectZero(int n){
    int count=0;
    while(n!=0){
        count+=n/5;
        n=n/5;
    }
    return count;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_16-3-1亿个int类型数字-如何找出重复数字-√" tabindex="-1"><a class="header-anchor" href="#_16-3-1亿个int类型数字-如何找出重复数字-√"><span>16.3. 1亿个int类型数字，如何找出重复数字？√</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public class Test{
    public static void main(String[] args){
        long time=new Date().getTime();
        int[] arr=new int[100000000];//1亿长度
        for(int i=0;i&lt;arr.length;i++){
            arr[i]=i+1;
        }
        arr[99999999]=2020;
        int min=arr[0];
        int max=arr[0];
        for(int i=0;i&lt;arr.length;i++){
            if(arr[i]&lt;min)
                min=arr[i];
            if(arr[i]&gt;max)
                max=arr[i];
        }
        byte[] bucket=new byte[(max-min)/8+1];
        for(int i=0;i&lt;arr.length;i++){
            int num=arr[i];
            int j=(num-min)/8;
            int k=(num-min)%8;
            if(((bucket[j]&gt;&gt;k)&amp;1)&gt;0){//重复了
                System.out.println(&quot;Number of repeats：&quot;+num);
                break;
            }else{
               bucket[j]|=(1&lt;&lt;k);
            }
        }
        long time2=new Date().getTime();
        System.out.println(&quot;millisecond:&quot;+(time2-time));
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_13-7-求以下表达式1-2-3-4-m的值-写出您想到的一种或几种实现方法" tabindex="-1"><a class="header-anchor" href="#_13-7-求以下表达式1-2-3-4-m的值-写出您想到的一种或几种实现方法"><span>13.7. 求以下表达式1-2+3-4+...+m的值，写出您想到的一种或几种实现方法</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public int fun(int m){
	int sum=0;
	for(int i=1;i&lt;m+1;i++){
		if(i%2==0){
			sum=sum-i;
		}else{
			sum=sum+i;
		}
	}
	return sum;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="查看反编译代码" tabindex="-1"><a class="header-anchor" href="#查看反编译代码"><span>查看反编译代码</span></a></h1><ul><li>C:\\Java\\jdk-11.0.8\\bin\\server放入hsdis-amd64.dll</li><li>idea运行添加vm参数</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>-server
-Xcomp
-XX:+UnlockDiagnosticVMOptions
-XX:+PrintAssembly
-XX:CompileCommand=compileonly,*MyTest.fun
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),f={href:"http://stop.sh",target:"_blank",rel:"noopener noreferrer"},y={href:"http://stop.sh",target:"_blank",rel:"noopener noreferrer"},x={href:"http://start.sh",target:"_blank",rel:"noopener noreferrer"},w={href:"http://start.sh",target:"_blank",rel:"noopener noreferrer"};function S(k,_){const n=t("ExternalLinkIcon");return r(),d("div",null,[c,e("p",null,[i("Sir Thomas Sunderland founded HSBC in "),e("a",u,[i("1865.lt"),l(n)]),i(" standsfor Hongkong Shanghai Business Corporation and iscurrently the seventh-largest bank worldwide in terms ofassets.With over 48 million customers in 66 countries.HSBC qualifies as one of the largest banking and financialservices "),e("a",o,[i("organizations.lt"),l(n)]),i(" is listed on the London StockExchange as the Hong Kong Stock Exchange."),b,i(" 托马斯•桑德兰爵士(Sir Thomas Sunderland)于1865年创立了汇丰银行。它代表香港上海商业公司，目前是全球第七大资产银行。在66个国家拥有超过4800万客户。汇丰银行是世界上最大的银行和金融服务机构之一。它在伦敦证券交易所作为香港证券交易所上市。")]),m,e("p",null,[i("在线计算阶乘的地址"),e("a",p,[i("http://www.99cankao.com/statistics/factorial-calculator.php"),l(n)]),h,i(" 尾部的0一共有多少个，就要看这个数包含多少个5的因子")]),g,e("p",null,[i("cd /opt/banzhutest && sh "),e("a",f,[i("stop.sh"),l(n)]),i(" && cd admin && sh "),e("a",y,[i("stop.sh"),l(n)]),i(" && cd && cd code/banzhunewserver && git pull && mvn clean package -Ptest && cp banzhu-api/target/testbanzhu.jar /opt/banzhutest/testbanzhu.jar && cp banzhu-admin/target/admintestbanzhu.jar /opt/banzhutest/admin/admintestbanzhu.jar && cd /opt/banzhutest && sh "),e("a",x,[i("start.sh"),l(n)]),i(" && cd admin && sh "),e("a",w,[i("start.sh"),l(n)]),i(" &")])])}const L=s(v,[["render",S],["__file","interview.html.vue"]]),T=JSON.parse('{"path":"/interview/interview.html","title":"面试","lang":"zh-CN","frontmatter":{"title":"面试","date":"2023-01-01T00:00:00.000Z","tags":"面试","categories":"面试","description":"自我介绍 面试官早上好，我是xxx，来自广东清远，2018年从广东药科大学制药工程专业毕业，目前有5年java开发经验，做过传统医疗项目和互联网社交项目，在项目里面使用过springboot、mybatis框架、redis分布式缓存组件，rabbitmq消息队列，mysql数据库等，在上一份工作中负责核心模块开发，参与过需求评审和数据库设计，有在lin...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/interview/interview.html"}],["meta",{"property":"og:site_name","content":"JavaGuide"}],["meta",{"property":"og:title","content":"面试"}],["meta",{"property":"og:description","content":"自我介绍 面试官早上好，我是xxx，来自广东清远，2018年从广东药科大学制药工程专业毕业，目前有5年java开发经验，做过传统医疗项目和互联网社交项目，在项目里面使用过springboot、mybatis框架、redis分布式缓存组件，rabbitmq消息队列，mysql数据库等，在上一份工作中负责核心模块开发，参与过需求评审和数据库设计，有在lin..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://290ff162.telegraph-image-eg9.pages.dev/file/f4fe8a438b4fca2f17b6b.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-07T01:56:33.000Z"}],["meta",{"property":"article:author","content":"HeChuangJun"}],["meta",{"property":"article:published_time","content":"2023-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-07T01:56:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"面试\\",\\"image\\":[\\"https://290ff162.telegraph-image-eg9.pages.dev/file/f4fe8a438b4fca2f17b6b.png\\"],\\"datePublished\\":\\"2023-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-07T01:56:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeChuangJun\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"15.5. 例子16","slug":"_15-5-例子16","link":"#_15-5-例子16","children":[]},{"level":2,"title":"15.6. 例子17","slug":"_15-6-例子17","link":"#_15-6-例子17","children":[]},{"level":2,"title":"15.7. 例子6","slug":"_15-7-例子6","link":"#_15-7-例子6","children":[]},{"level":2,"title":"15.8. 例子7","slug":"_15-8-例子7","link":"#_15-8-例子7","children":[]},{"level":2,"title":"16.4. 计算n的阶乘的末尾有几个0√","slug":"_16-4-计算n的阶乘的末尾有几个0√","link":"#_16-4-计算n的阶乘的末尾有几个0√","children":[]},{"level":2,"title":"16.3. 1亿个int类型数字，如何找出重复数字？√","slug":"_16-3-1亿个int类型数字-如何找出重复数字-√","link":"#_16-3-1亿个int类型数字-如何找出重复数字-√","children":[]},{"level":2,"title":"13.7. 求以下表达式1-2+3-4+...+m的值，写出您想到的一种或几种实现方法","slug":"_13-7-求以下表达式1-2-3-4-m的值-写出您想到的一种或几种实现方法","link":"#_13-7-求以下表达式1-2-3-4-m的值-写出您想到的一种或几种实现方法","children":[]}],"git":{"createdTime":1733536593000,"updatedTime":1733536593000,"contributors":[{"name":"HeChuangJun","email":"1105128664@qq.com","commits":1}]},"readingTime":{"minutes":27.9,"words":8369},"filePathRelative":"interview/interview.md","localizedDate":"2023年1月1日","excerpt":"<!-- TOC -->\\n<h1>自我介绍</h1>\\n<ul>\\n<li>\\n<p>面试官早上好，我是xxx，来自广东清远，2018年从广东药科大学制药工程专业毕业，目前有5年java开发经验，做过传统医疗项目和互联网社交项目，在项目里面使用过springboot、mybatis框架、redis分布式缓存组件，rabbitmq消息队列，mysql数据库等，在上一份工作中负责核心模块开发，参与过需求评审和数据库设计，有在linux上排查线上问题的经验。希望能加入贵公司担任java开发工程师，谢谢</p>\\n</li>\\n<li>\\n<p>Good morning, interviewer, My name is xxx,I come from Qingyuan,a city in Guangdong Province. I was graduated from Guangdong Pharmaceutical University in 2018, majoring in pharmaceutical engineering. l have been working as a java development engineer for 5 years, and have done traditional medical projects and Internet social projects, in which I have used springboot, mybatis framework and redis distributed cache component. rabbitmq message queue, mysql database, etc. In my last job, I was responsible for core module development, participated in requirement review and database design, and had experience in troubleshooting online problems on linux. I hope I can make a good performance today. That’s  all. Thank you for giving me the chance.</p>\\n</li>\\n<li>\\n<p>面试官早上好，我是xxx，广东清远人，18年广东药科大学毕业，制药工程专业，目前住在天河梅花园，是一个i人，平时喜欢看书跑步，与陌生人熟悉后就会变成e人，乐观开朗</p>\\n</li>\\n</ul>","autoDesc":true}');export{L as comp,T as data};
