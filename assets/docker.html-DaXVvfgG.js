import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as r,c as a,a as e,b as l,d as s,e as i}from"./app-7KT7HDzT.js";const c={},d=i('<p>docker</p><h2 id="docker概述-场景-优点" tabindex="-1"><a class="header-anchor" href="#docker概述-场景-优点"><span>Docker概述？场景？优点？</span></a></h2><p>开源的应用容器引擎，基于 Go 语言<br> 通过容器实现快速打包，测试和部署程序、管理基础架构(快速交付)<br> 容器安全、轻量、可移植、松耦合、可扩展直接在内核运行(同一硬件上可运行多个容器)</p><p>Web应用的自动化打包和发布。√<br> 自动化测试和持续集成、发布。√<br> 在服务型环境中部署和调整数据库或其他的后台应用。</p><p>快速，一致地交付您的应用程序<br> 响应式部署和扩展<br> 在同一硬件上运行更多工作负载</p><h2 id="docker架构-组件" tabindex="-1"><a class="header-anchor" href="#docker架构-组件"><span>Docker架构？组件？</span></a></h2><figure><img src="https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMwfd2c5c7d4bb799eaeb7e9adbba3e3694.png" alt="1.png" tabindex="0"><figcaption>1.png</figcaption></figure><p>工作流程<br> 构建镜像：使用 Dockerfile 创建镜像。<br> 推送镜像到注册表：将镜像上传到 Docker Hub 或私有注册表中。<br> 拉取镜像：通过 docker pull 从注册表中拉取镜像。<br> 运行容器：使用镜像创建并启动容器。<br> 管理容器：使用 Docker 客户端命令管理正在运行的容器（例如查看日志、停止容器、查看资源使用情况等）。<br> 网络与存储：容器之间通过 Docker 网络连接，数据通过 Docker 卷或绑定挂载进行持久化。</p>',8),u=i("<li>Docker客户端（Docker Client）：用户与Docker守护进程交互的命令行界面（CLI）。用户通过Docker CLI发送命令到Docker守护进程执行相应的操作。<br> 功能：允许用户使用命令与 Docker 守护进程通信，如创建容器、构建镜像、查看容器状态等。<br> 交互方式：Docker客户端与Docker守护进程通过REST API或Unix套接字通信<br> 常用命令：<br> docker run：运行容器。<br> docker ps：列出正在运行的容器。<br> docker build：构建 Docker 镜像。<br> docker exec：在容器中执行命令。</li><li>Docker 守护进程（Docker Daemon）：负责管理容器生命周期、构建镜像、分发镜像等任务。监听来自Docker客户端的请求，并且通过Docker API执行请求<br> 启动和停止容器。<br> 构建、拉取和推送镜像。<br> 管理容器的网络和存储。<br> 启动、停止、查看容器日志等。<br> 与 Docker 注册表进行通信，管理镜像的存储与分发。<br> 启动 Docker 守护进程（通常是自动启动的）：sudo systemctl start docker</li>",2),p=e("br",null,null,-1),m=e("br",null,null,-1),k=e("br",null,null,-1),b=e("br",null,null,-1),v={href:"http://localhost/version",target:"_blank",rel:"noopener noreferrer"},h=i("<li>Docker 容器（Docker Containers）<br> 执行环境，轻量级、独立且可执行的软件包。容器是从Docker镜像启动的，包含了运行某个应用程序所需的一切——从操作系统库到应用程序代码。容器在运行时与其他容器和宿主机共享操作系统内核，但容器之间的文件系统和进程是隔离的。<br> 功能：<br> 提供独立的运行环境，确保应用程序在不同的环境中具有一致的行为。<br> 容器是临时的，通常在任务完成后被销毁。<br> 容器的生命周期是由 Docker 守护进程管理的。容器可以在任何地方运行，因为它们不依赖于底层操作系统的配置，所有的运行时依赖已经封装在镜像中。<br> 启动容器：docker run -d ubuntu</li><li>Docker 镜像（Docker Images）：容器的只读模板。包含了应用程序运行所需的操作系统、运行时、库、环境变量和应用代码等。镜像是静态的，用户可以根据镜像启动容器。<br> 功能：<br> 构建容器<br> 镜像是只读的，不同容器使用同一个镜像时，容器中的文件系统层是独立的。<br> Docker 镜像可以通过 docker pull 从 Docker Hub 或私有注册表拉取，也可以通过 docker build 从 Dockerfile 构建。<br> 拉取 Ubuntu 镜像：docker pull ubuntu</li><li>Docker 仓库（Docker Registries）：存储 Docker 镜像，公共仓库Docker Hub。Docker Hub下载上传镜像也可以部署自己的私有 Docker 仓库来管理企业内部的镜像。<br> 功能：<br> 存储 Docker 镜像。<br> 提供镜像的上传和下载功能。<br> Docker Hub 提供了大量官方和社区维护的镜像，如 Ubuntu、Nginx、MySQL 等。<br> 推送镜像到 Docker Hub：docker push username/image_name</li><li>Docker Compose：定义和运行多容器Docker应用的工具。用一个 docker-compose.yml 配置文件定义多个容器（服务），并可以通过一个命令启动这些容器。用于开发、测试和部署多容器的应用。<br> 功能：<br> 定义和运行多个容器组成的应用。<br> 通过 YAML 文件来配置应用的服务、网络和卷等。</li><li>Docker Swarm：集群管理和调度工具。将多个 Docker 主机（节点）组织成集群，并通过Swarm 集群管理工具来调度和管理容器。可以实现容器的负载均衡、高可用性和自动扩展等功能。<br> 功能：<br> 管理多节点 Docker 集群。<br> 通过调度器管理容器的部署和扩展。</li><li>Docker 网络（Docker Networks）：并与外部世界进行连接<br> 功能：<br> 管理容器间的网络通信。<br> 支持不同的网络模式，以适应不同场景下的需求。<br> 创建一个自定义网络并将容器连接到该网络：</li><li>Docker 卷（Docker Volumes）：数据持久化机制，适用于数据库等需要持久存储的应用。<br> 功能：<br> 允许容器间共享数据。<br> 保证数据持久化，独立于容器的生命周期。与容器文件系统不同，卷的内容不会随着容器销毁而丢失</li>",7),g=i(`<h2 id="docker安装" tabindex="-1"><a class="header-anchor" href="#docker安装"><span>Docker安装</span></a></h2><ul><li>手动安装</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>
# 更改centos源
curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
yum -y remove docker docker-client docker-client-latest docker-common docker-latest docker-latest-logrotate docker-logrotate docker-engine
# 更新yum。防止找不到docker
yum update -y
# yum clean all
# yum makecache
#安装一些必备工具 java-11-openjdk-headless java-11-openjdk java-11-openjdk-devel
yum -y install lrzsz net-tools wget vim python3 keyutils unzip lvm2 yum-utils
# 安装docker
yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
#yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
yum -y install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

systemctl start docker
systemctl enable docker
---------------------centos7 安装docker-compose---------
#curl -L &quot;https://github.com/docker/compose/releases/download/2.17.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose
curl -L https://get.daocloud.io/docker/compose/releases/download/1.29.4/docker-compose-\`uname -s\`-\`uname -m\` &gt; /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),q=e("br",null,null,-1),D=e("img",{src:"https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMw5e690bcefd7a7b4f720d026068a1aed2.png",alt:"dockercomposeerror.png"},null,-1),_=e("br",null,null,-1),f=e("br",null,null,-1),N={href:"https://github.com/docker/compose/releases/tag/v2.18.1",target:"_blank",rel:"noopener noreferrer"},y=e("br",null,null,-1),E=e("img",{src:"https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMw76789c859fa3a2b2512994beba0bd0ad.png",alt:"dockercomposeerrorsolve.png"},null,-1),x=e("br",null,null,-1),R=e("br",null,null,-1),T=e("br",null,null,-1),I=e("code",null,"sudo chmod +x /usr/local/bin/docker-compose",-1),O=e("br",null,null,-1),A=i(`<ul><li>(推荐)官方源安装（带docker-compose-plugin、从20.10.0版本开始将Compose功能内置为插件，通过docker compose使用（注意空格））</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code># centos 9+
curl https://get.docker.com -o install-docker.sh
sudo sh install-docker.sh

systemctl start docker
systemctl enable docker
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="代理" tabindex="-1"><a class="header-anchor" href="#代理"><span>代理</span></a></h2><ul><li>(一定要开，尽管linux能连外网)</li><li>宿主机开通192.168.0.0/24的子网防火墙</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>mkdir -p /etc/systemd/system/docker.service.d
cat &gt; /etc/systemd/system/docker.service.d/http-proxy.conf &lt;&lt;&quot;EOF&quot;
[Service]
Environment=&quot;HTTP_PROXY=http://192.168.1.141:7890/&quot;
Environment=&quot;HTTPS_PROXY=http://192.168.1.141:7890/&quot;
Environment=&quot;ALL_PROXY=http://192.168.1.141:7890/&quot;
Environment=&quot;NO_PROXY=localhost,127.0.0.1,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,169.254.0.0/16&quot;
EOF

systemctl daemon-reload
systemctl restart docker
docker search mysql
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>虚拟机开启共享网络<br><img src="https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMw25cd520d2c83614914e25eb185fb497a.png" alt="network.png"></li></ul><h2 id="镜像源-仓库" tabindex="-1"><a class="header-anchor" href="#镜像源-仓库"><span>镜像源/仓库</span></a></h2>`,7),P=e("li",null,[e("p",null,"仓库（Repository）是集中存放镜像的地方，官方维护公共仓库Docker Hub")],-1),w=e("li",null,[e("p",null,"查找官方仓库中的镜像docker search REPOSITORY")],-1),S=e("li",null,[e("p",null,"将官方镜像下载到本地docker pull REPOSITORY")],-1),C=e("p",null,"提交到远程仓库docker hub",-1),M={href:"https://hub.docker.com",target:"_blank",rel:"noopener noreferrer"},Y=e("li",null,"登录docker login（- 退出docker logout）",-1),H=e("li",null,"将镜像指定为要提交到的dockerID/REGISTRYHOST(名字必须一样)：docker tag IMAGE:TAG dockerID/REGISTRYHOST[:TAG]",-1),L=e("li",null,"将指定REGISTRYHOST提交到远程仓库：docker push dockerID/REGISTRYHOST[:TAG]",-1),U=e("li",null,[e("p",null,"配置")],-1),G=i(`<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>mkdir -p /etc/docker
cat &gt;/etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;
{
  &quot;registry-mirrors&quot;: [
    &quot;https://registry.docker-cn.com&quot;,
    &quot;https://hub.geekery.cn&quot;,
    &quot;https://hub.littlediary.cn&quot;,
    &quot;https://docker.rainbond.cc&quot;,
    &quot;https://docker.unsee.tech&quot;,
    &quot;https://docker.m.daocloud.io&quot;,
    &quot;https://hub.crdz.gq&quot;,
    &quot;https://docker.nastool.de&quot;,
    &quot;https://hub.firefly.store&quot;,
    &quot;https://registry.dockermirror.com&quot;,
    &quot;https://docker.1panelproxy.com&quot;,
    &quot;https://hub.rat.dev&quot;,
    &quot;https://docker.udayun.com&quot;,
    &quot;https://docker.kejilion.pro&quot;,
    &quot;https://dhub.kubesre.xyz&quot;,
    &quot;https://docker.1panel.live&quot;,
    &quot;https://dockerpull.org&quot;,
    &quot;https://docker.hlmirror.com&quot;,
    &quot;https://docker.imgdb.de&quot;,
    &quot;https://docker.m.daocloud.io&quot;, 
    &quot;https://noohub.ru&quot;, 
    &quot;https://huecker.io&quot;,
    &quot;https://dockerhub.timeweb.cloud&quot;,
    &quot;https://0c105db5188026850f80c001def654a0.mirror.swr.myhuaweicloud.com&quot;,
    &quot;https://5tqw56kt.mirror.aliyuncs.com&quot;,
    &quot;https://docker.1panel.live&quot;,
    &quot;http://mirrors.ustc.edu.cn/&quot;,
    &quot;http://mirror.azure.cn/&quot;,
    &quot;https://hub.rat.dev/&quot;,
    &quot;https://docker.ckyl.me/&quot;,
    &quot;https://docker.chenby.cn&quot;,
    &quot;https://docker.hpcloud.cloud&quot;,
    &quot;https://docker.m.daocloud.io&quot;,
    &quot;https://hub-mirror.c.163.com&quot;,
    &quot;https://registry.aliyuncs.com&quot;,
    &quot;https://docker.mirrors.ustc.edu.cn&quot;
  ]
}
EOF
systemctl daemon-reload
systemctl restart docker
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="docker镜像" tabindex="-1"><a class="header-anchor" href="#docker镜像"><span>Docker镜像</span></a></h2><ul><li>从私有REPOSITORY/docker hub载入镜像：docker pull 镜像名（仓库源:TAG）</li><li>查询本地镜像列表：docker images<br> REPOSITORY：镜像的仓库源、TAG：标签、IMAGE ID：ID、CREATED：创建时间、SIZE：大小。同一仓库源可以有多个TAG，代表仓库源不同个版本</li><li>在docker hub查询docker镜像：docker search 镜像名（仓库源:TAG）</li><li>创建镜像<br> 从已经创建的容器中更新镜像，并且提交这个镜像docker commit -m=&quot;update message&quot; -a=&quot;jun&quot; CONTAINERID/NAME 镜像名[:TAG]（-m: 提交的描述信息、-a: 指定镜像作者、e218edb10161：容器ID、runoob/ubuntu:v2: 要创建的镜像名）<br> 用Dockerfile指令来创建一个新的镜像 docker build [OPTIONS] PATH | URL | .<br> --build-arg=[] :设置镜像创建时的变量<br> --cpu-shares：cpu使用权重<br> --cpu-period：限制CPU CFS周期<br> --cpu-quota：限制CPU CFS配额<br> --cpuset-cpus：指定使用的CPU id<br> --cpuset-mems：指定使用的内存 id<br> --disable-content-trust：忽略校验，默认开启<br> -f：指定Dockerfile路径<br> --force-rm：设置镜像过程中删除中间容器<br> --isolation：使用容器隔离技术<br> --label=[]：设置镜像使用的元数据<br> -m：设置内存最大值<br> --memory-swap :设置Swap的最大值为内存+swap，&quot;-1&quot;表示不限swap<br> --no-cache :创建镜像的过程不使用缓存<br> --pull :尝试去更新镜像的新版本；<br> --quiet, -q :安静模式，成功后只输出镜像 ID；<br> --rm :设置镜像成功后删除中间容器；<br> --shm-size :设置/dev/shm的大小，默认值是64M；<br> --ulimit :Ulimit配置。<br> --squash :将 Dockerfile 中所有的操作压缩为一层。<br> --tag, -t: 镜像的名字及标签，通常name:tag或者name格式；可以一次构建设置多个标签√<br> --network: 默认 default。在构建期间设置RUN指令的网络模式√<br> .：构建镜像时的应用上下文路径，要被打包到镜像中的宿主机路径，必须包括Dockerfile文件，&quot;.&quot;表示打包当前目录下的docker file和其他文件作为应用上下文√</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>runoob@runoob:~$ <span class="token function">cat</span> Dockerfile 
FROM    centos:6.7
MAINTAINER      Fisher <span class="token string">&quot;fisher@sudops.com&quot;</span>

RUN     /bin/echo <span class="token string">&#39;root:123456&#39;</span> <span class="token operator">|</span>chpasswd
RUN     <span class="token function">useradd</span> runoob
RUN     /bin/echo <span class="token string">&#39;runoob:123456&#39;</span> <span class="token operator">|</span>chpasswd
RUN     /bin/echo <span class="token parameter variable">-e</span> <span class="token string">&quot;LANG=<span class="token entity" title="\\&quot;">\\&quot;</span>en_US.UTF-8<span class="token entity" title="\\&quot;">\\&quot;</span>&quot;</span> <span class="token operator">&gt;</span>/etc/default/local
EXPOSE  <span class="token number">22</span>
EXPOSE  <span class="token number">80</span>
CMD     /usr/sbin/sshd <span class="token parameter variable">-D</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。<br> FROM指定使用哪个镜像源<br> RUN在镜像内执行命令，安装了什么。。。</p><ul><li>删除镜像docker rmi 镜像名（仓库源:TAG）</li><li>设置镜像标签docker tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG]</li></ul><h2 id="docker容器" tabindex="-1"><a class="header-anchor" href="#docker容器"><span>Docker容器</span></a></h2>`,7),z=i("<li>--name指定名称，用于引用容器</li><li>-t 在新容器内指定一个伪终端或终端。与i同时使用，exit或CTRL+D退出</li><li>-i 给容器输入命令。与t同时用，exit或CTRL+D退出</li><li>-d detach 后台运行容器（没有则前台）</li><li>-p publish指定容器端口绑定到主机端口、网络地址（如127.0.0.1）、或udp</li><li>-P 容器端口随机映射主机端口</li><li>--network NETNAME容器连接网络<br> -- docker连接系统将多个容器连接在一起，共享连接信息。创建一个父子关系，其中父容器可以看到子容器的信息 <ul><li>查看网络列表docker network ls</li><li>新建网络：docker network create -d bridge NETNAME（d：指定网络类型，有bridge、overlay（用于Swarm mode））</li><li>有多个容器之间需要互相连接，推荐使用 Docker Compose</li></ul></li><li>--rm 容器退出时自动清理容器内部的文件系统。不能与-d同时使用，自动清理foreground容器，匿名data volumes，但不能自动清理detached容器</li><li>-h或者--hostname 设定容器的主机名，它会被写到容器内的/etc/hostname和/etc/hosts。</li><li>dns=xxx 添加DNS服务器到容器的/etc/resolv.conf(容器dns配置)中，让容器用这个服务器来解析所有不在/etc/hosts中的主机名</li>",10),j={href:"http://xn--host-ue6fu62ihv0b1j5a.example.com",target:"_blank",rel:"noopener noreferrer"},X=e("li",null,"如果在容器启动时没有指定dns和dns-search，Docker会默认用宿主主机上的 /etc/resolv.conf 来配置容器的",-1),K=e("li",null,"REPOSITORY[:TAG] 指定运行的镜像，如果本地主机不存在，Docker就会从镜像仓库Docker Hub下载公共镜像",-1),F=e("li",null,[l("[COMMAND] [ARG...] 镜像名后的命令，在启动的容器里执行的命令 "),e("ul",null,[e("li",null,'如/bin/sh -c "while true; do echo hello world; sleep 1; done"'),e("li",null,'如/bin/echo "Hello world"')])],-1),V=i("<li>启动容器，参数为以命令行模式进入该容器：docker run -itd ubuntu /bin/bash</li><li>docker attach CONTAINERID/NAME 进入容器终端：exit停止容器</li><li>docker exec -it CONTAINERID/NAME 进入容器终端：exit不停止容器√</li><li>[强行]删除正在运行的容器docker rm [--force] CONTAINERID/NAME</li><li>列出正在运行[所有]容器：docker ps [--all]</li><li>查看最后一次创建的容器docker ps -l</li><li>停止/重启/启动正在运行的容器docker stop/restart/start CONTAINERID/NAME</li><li>查看容器内部的进程docker top CONTAINERID/NAME</li><li>[滚动]查看容器日志docker logs [-f] CONTAINERID/NAME</li><li>查看容器在属主机的端口docker port CONTAINERID/NAME</li><li>查看docker底层信息docker inspect CONTAINERID/NAME</li><li>指定路径导出容器：docker export CONTAINERID/NAME &gt; 相对/绝对路径文件名</li><li>指定路径导入容器：docker import 相对/绝对路径文件名/URL [REPOSITORY][:TAG]</li><li>配置全部容器的DNS：主机的/etc/docker/daemon.json文件并重启docker</li>",14),Z=i(`<div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>{
    &quot;dns&quot; : [
    &quot;114.114.114.114&quot;,
    &quot;8.8.8.8&quot;
    ]
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="docker-volume" tabindex="-1"><a class="header-anchor" href="#docker-volume"><span>Docker volume</span></a></h2><p>列出出所有卷：docker volume ls</p><h2 id="docker-network" tabindex="-1"><a class="header-anchor" href="#docker-network"><span>Docker network</span></a></h2><p>Docker默认创建三种网络</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># docker network ls</span>
NETWORK ID     NAME      DRIVER    SCOPE
e9d8cefda384   bridge    bridge    <span class="token builtin class-name">local</span>
b8f4b14a4b57   <span class="token function">host</span>      <span class="token function">host</span>      <span class="token builtin class-name">local</span>
c42e6828f27c   none      null      <span class="token builtin class-name">local</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>网络模式</th><th>简介</th></tr></thead><tbody><tr><td>Docker默认创建三种网络</td><td></td></tr><tr><td>Host</td><td>容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</td></tr><tr><td>Bridge（默认）</td><td>为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信，容器可以访问外网，宿主机需要通过NAT转换端口映射或者iptables才可以访问，外网需要端口映射，容器共享宿主机MAC地址</td></tr><tr><td>None</td><td>关闭了容器的网络功能。</td></tr><tr><td>Container</td><td>创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。</td></tr><tr><td>Macvlan</td><td>容器直接获取物理网络IP，不需要NAT，每个容器有独立MAC，外网不需要端口映射可直接访问，宿主机无法访问要macvlan bridge</td></tr></tbody></table><p>Docker使用了Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。一个Docker容器一般会分配一个独立的Network Namespace。但如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。</p><p>Container模式：指定新容器和已经存在的一个容器共享一个Network Namespace（IP、端口范围等）</p><p>None模式：将容器放置在自己的网络栈中，并不进行任何配置。关闭了容器的网络功能，容器并不需要网络（例如只需要写磁盘卷的批处理任务）时有用</p><p>Bridge模式：相当于Vmware中的NAT模式，容器使用独立network Namespace，设置IP等。并连接到docker0虚拟网卡（默认模式）</p><p>Docker server启动时会在主机上创建一个名为docker0的虚拟网桥，Docker容器会连接到这个虚拟网桥（工作方式和物理交换机类似），这样主机上的所有容器就通过交换机连在了一个二层网络中。Docker会从RFC1918所定义的私有IP网段中，选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从这个子网中选择一个未占用的IP使用。如172.17.0.0/16网段，并将172.17.0.1/16分配给docker0网桥（在主机上使用ifconfig命令是可以看到docker0，可认为是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）。</p><p>Docker完成以上网络配置的过程：</p><ul><li>在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。</li><li>Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令查看。</li></ul><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code>brctl show
bridge name     bridge <span class="token function">id</span>               STP enabled     interfaces
docker0        <span class="token number">8000</span>.02425f21c208          no
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。docker network inspect bridge查看连接在docker0的容器</p></li><li><p>bridge模式下，连在同一网桥上的容器可以相互通信（禁止通信则在DOCKER_OPTS变量中设置--icc=false，只有用--link才能使两个容器通信）。可通过--ip_forward和--iptables两个选项控制容器间、容器和外部世界的通信。</p></li></ul><p>容器可以与外部通信，主机上的Iptable规则</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>将源地址为172.17.0.0/16的包（从Docker容器产生的包），并且不是从docker0网卡发出的，源地址转换成主机网卡的地址。</p><p>假设主机网卡为eth0，IP地址为10.10.101.105/24，网关为10.10.101.254。从主机上IP为172.17.0.1/16的容器中ping百度（180.76.3.151）。IP包首先从容器发往默认网关docker0，包到达docker0后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的eth0发往主机的网关10.10.105.254/24。接着包会转发给eth0发出去（主机的ip_forward转发应该已经打开）。这时Iptable规则对包做SNAT转换，将源地址换为eth0的地址。在外界看来包是从10.10.101.105上发出来的，Docker容器对外是不可见的。</p><p>外面的机器是如何访问Docker容器的服务呢？</p><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span><span class="token operator">=</span>nginx_bridge <span class="token parameter variable">--net</span><span class="token operator">=</span>bridge <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-d</span> nginx
<span class="token comment"># 查看Iptable规则多了一条规则：</span>
<span class="token parameter variable">-A</span> DOCKER <span class="token operator">!</span> <span class="token parameter variable">-i</span> docker0 <span class="token parameter variable">-p</span> tcp <span class="token parameter variable">-m</span> tcp <span class="token parameter variable">--dport</span> <span class="token number">80</span> <span class="token parameter variable">-j</span> DNAT --to-destination <span class="token number">172.17</span>.0.2:80
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对主机eth0收到的目的端口为80的tcp流量进行DNAT转换，将流量发往172.17.0.2:80的Docker容器。所以，外界只需访问10.10.101.105:80就可以访问到容器中的服务</p><p>还可以自定义Docker使用的IP地址、DNS、网桥</p><h2 id="dockerfile" tabindex="-1"><a class="header-anchor" href="#dockerfile"><span>Dockerfile</span></a></h2>`,25),B=e("li",null,[l("用来"),e("strong",null,"构建镜像的文本文件"),l("，包含构建镜像所需的指令和说明。")],-1),J=e("strong",null,"指令每次执行都会新建一层。过多无意义的层会造成镜像膨胀过大。使用&&符号连接命令执行后只会创建1层镜像",-1),W=e("br",null,null,-1),$={href:"http://download.redis.io/releases/redis-5.0.3.tar.gz",target:"_blank",rel:"noopener noreferrer"},Q=i("<li>dockerfile指令 <ul><li>FROM：定制的镜像基于FROM的镜像</li><li>RUN：用于执行命令行命令，在docker build时运行 <ul><li>RUN &lt;命令行命令&gt; #shell格式 等同于在终端操作的shell命令</li><li>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;] #exec 格式 RUN [&quot;./test.php&quot;, &quot;dev&quot;, &quot;offline&quot;] 等价于 RUN ./test.php dev offline</li></ul></li><li>CMD：用于运行程序（可以被覆盖），在docker run时运行 <ul><li><code>CMD [&quot;&lt;可执行文件或命令&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...] </code> # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数</li><li>为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。可被docker run命令行参数中指定要运行的程序所覆盖</li><li>如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效</li></ul></li><li>ENTRYPOINT：类似CMD，设置容器创建时的主要命令。不会被docker run的命令行参数指定的指令所覆盖.而且这些命令行参数会被当作参数送给ENTRYPOINT指令指定的程序.如果docker run时用--entrypoint选项参数可当作要运行的程序覆盖ENTRYPOINT指令指定的程序 <ul><li><code>ENTRYPOINT [&quot;&lt;executeable&gt;&quot;,&quot;&lt;param1&gt;&quot;,&quot;&lt;param2&gt;&quot;,...]</code></li><li>如果存在多个ENTRYPOINT指令，仅最后一个生效</li></ul></li><li>LABEL：添加镜像的元数据，使用键值对的形式。<code>LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</code></li><li>COPY：从上下文目录中复制文件或者目录到容器里指定路径 <ul><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] &lt;源路径1&gt;... &lt;目标路径&gt;</code></li><li><code>COPY [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</code></li><li><code>[--chown=&lt;user&gt;:&lt;group&gt;]</code>：可选参数，用户改变复制到容器内文件的拥有者和属组。</li><li>&lt;源路径&gt;：源文件或者源目录，可以是通配符表达式(规则要满足Go的filepath.Match规则)</li><li>&lt;目标路径&gt;：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建</li></ul></li><li>ADD：和COPY的使用格式一致（官方推荐用COPY） <ul><li>优点：在执行&lt;源文件&gt;为tar压缩文件，格式为gzip, bzip2以及xz情况下，会自动复制并解压到 &lt;目标路径&gt;</li><li>缺点：在不解压的前提下无法复制tar压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。</li></ul></li><li>ENV <ul><li>设置环境变量，指令可通过$key使用</li><li><code>ENV &lt;key&gt; &lt;value&gt;</code></li><li><code>ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</code></li></ul></li><li>ARG <ul><li>设置环境变量，只有docker build过程中有效，构建好的镜像内不存在此环境变量</li><li>docker build可以用--build-arg &lt;参数名&gt;=&lt;值&gt;覆盖</li><li><code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code></li></ul></li><li>VOLUME <ul><li>定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷</li><li>避免重要的数据，因容器重启而丢失。避免容器不断变大</li><li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code></li><li><code>VOLUME &lt;路径&gt;</code></li></ul></li><li>EXPOSE 配置映射端口 <ul><li>docker run -P时会随机映射EXPOSE端口</li><li><code>EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</code></li></ul></li><li>WORKDIR <ul><li>指定工作目录。在构建镜像的每一层中都存在。WORKDIR自动创建</li><li>docker build构建镜像过程中的，每一个RUN命令都是新建的一层。只有通过WORKDIR创建的目录才会一直存在</li><li>WORKDIR &lt;工作目录路径&gt;</li></ul></li><li>USER <ul><li>用于指定执行后续命令的用户和用户组，切换后续命令执行的用户（用户和用户组必须存在）</li><li><code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></li></ul></li><li>HEALTHCHECK <ul><li>指定某个程序或者指令来监控 docker 容器服务的运行状态。</li><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li><li><code>HEALTHCHECK [选项] CMD &lt;命令&gt; </code>: CMD后面跟随的命令使用，参考CMD</li></ul></li><li>ONBUILD <ul><li>当该镜像被用作另一个构建过程的基础时，添加触发器。</li><li>ONBUILD &lt;其它指令&gt;</li></ul></li><li>STOPSIGNAL 设置发送给容器以退出的系统调用信号。</li><li>HEALTHCHECK 定义周期性检查容器健康状态的命令。</li><li>SHELL 覆盖Docker中默认的shell，用于RUN、CMD和ENTRYPOINT指令。</li></ul></li>",1),ee=e("h2",{id:"docker-compose",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#docker-compose"},[e("span",null,"docker Compose")])],-1),le=i("<li>用于<strong>定义和运行多容器</strong>Docker应用程序的工具。用命令从YML文件配置中创建并启动所有服务</li><li>Compose使用： <ul><li>使用 Dockerfile 定义应用程序的环境</li><li>使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。</li><li>执行 docker-compose up [-d]命令来启动并[后台]运行整个应用程序</li><li>停止并删除由docker-compose启动的容器、网络等：docker-compose down</li></ul></li><li>yml配置 <ul><li>version 指定本 yml 依从的 compose 哪个版本制定的。</li><li>service <ul><li>webapp webapp服务 <ul><li>build 指定为构建镜像上下文路径 <ul><li>context：构建镜像时的应用上下文路径，需要被打包到Docker镜像中的宿主机路径</li><li>dockerfile：构建镜像的Dockerfile文件名。</li><li>args：添加构建参数，只能在构建过程中访问的环境变量。</li><li>labels：构建镜像的标签。</li><li>target：多层构建，可以指定构建哪一层</li></ul></li></ul></li></ul></li><li>cap_add，cap_drop添加或删除容器拥有的宿主机的内核功能ALL全部权限 SYS_PTRACE：ptrace权限</li><li>cgroup_parent 为容器指定父 cgroup 组，限制继承该组的资源</li><li>command 覆盖容器启动的默认命令</li><li>container_name 指定自定义容器名称，而不是生成的默认名称</li><li>depends_on 设置依赖关系。 <ul><li>docker-compose up ：以依赖性顺序启动服务。先启动depends_on指定的service再启动该service</li><li>docker-compose up SERVICE ：自动包含 SERVICE 的依赖项。</li><li>docker-compose stop ：按依赖关系顺序停止服务。</li></ul></li><li>deploy 指定与服务的部署和运行有关的配置。只在 swarm 模式下才有用。 <ul><li>endpoint_mode: vip # Docker集群服务一个对外的虚拟ip。所有的请求都会通过这个虚拟ip到达集群服务内部的机器</li><li>endpoint_mode: dnsrr # DNS 轮询（DNSRR）。所有的请求会自动轮询获取到集群ip列表中的一个ip地址</li></ul></li><li>labels：在服务上设置标签。可以用容器上的labels（跟 deploy 同级的配置） 覆盖 deploy 下的 labels。</li><li>mode：指定服务提供的模式。 <ul><li>replicated：复制服务，复制指定服务到集群的机器上。</li><li>global：全局服务，服务将部署至集群的每个节点。</li></ul></li><li>replicas：mode 为 replicated 时配置具体运行的节点数量。</li><li>resources：配置限制使用服务器资源</li><li>restart_policy：配置如何在退出容器时重新启动容器。 <ul><li>condition：可选 none，on-failure 或者 any（默认）</li><li>delay：设置多久之后重启（默认0）。</li><li>max_attempts：尝试重新启动容器的次数，超出次数则不再尝试（默认一直重试）。</li><li>window：设置容器重启超时时间（默认0）</li></ul></li><li>rollback_config：配置在更新失败的情况下应如何回滚服务。 <ul><li>parallelism：一次要回滚的容器数。如果设置为0，则所有容器将同时回滚。</li><li>delay：每个容器组回滚之间等待的时间（默认为0s）。</li><li>failure_action：如果回滚失败，该怎么办。其中一个 continue 或者 pause（默认pause）。</li><li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li><li>max_failure_ratio：在回滚期间可以容忍的故障率（默认为0）。</li><li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认 stop-first ）。</li></ul></li><li>update_config：配置应如何更新服务，对于配置滚动更新很有用。 <ul><li>parallelism：一次更新的容器数。</li><li>delay：在更新一组容器之间等待的时间。</li><li>failure_action：如果更新失败，该怎么办。其中一个 continue，rollback 或者pause （默认：pause）。</li><li>monitor：每个容器更新后，持续观察是否失败了的时间 (ns|us|ms|s|m|h)（默认为0s）。</li><li>max_failure_ratio：在更新过程中可以容忍的故障率。</li><li>order：回滚期间的操作顺序。其中一个 stop-first（串行回滚），或者 start-first（并行回滚）（默认stop-first）。</li></ul></li><li>devices 指定设备映射列表。</li><li>dns自定义 DNS 服务器，可以是单个值或列表的多个值。</li><li>dns_search自定义 DNS 搜索域。可以是单个值或列表。</li><li>entrypoint覆盖容器默认的 entrypoint。</li><li>env_file从文件添加环境变量。可以是单个值或列表的多个值。</li><li>environment添加环境变量。可用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False。</li><li>expose暴露端口，但不映射到宿主机，只被连接的服务访问。</li><li>extra_hosts添加主机名映射。类似 docker client --add-host。会在此服务的内部容器中 /etc/hosts 创建一个具有 ip 地址和主机名的映射关系</li><li>healthcheck用于检测 docker 服务是否健康运行。</li><li>image指定容器运行的镜像。</li><li>logging服务的日志记录配置。driver：指定服务容器的日志记录驱动程序，默认值为json-file。 <ul><li>driver: &quot;json-file&quot;</li><li>driver: &quot;syslog&quot;</li><li>driver: &quot;none&quot;</li></ul></li><li>network_mode设置网络模式。 <ul><li>networks配置容器连接的网络</li><li>aliases ：同一网络上的其他容器可以使用服务名称或此别名来连接到对应容器的服务。</li><li>restart <ul><li>no：是默认的重启策略，在任何情况下都不会重启容器。</li><li>always：容器总是重新启动。</li><li>on-failure：在容器非正常退出时（退出状态非0），才会重启容器。</li><li>unless-stopped：在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li><li>swarm 集群模式，请改用 restart_policy。</li></ul></li></ul></li><li>secrets存储敏感数据，例如密码：</li><li>security_opt修改容器默认的 schema 标签。</li><li>stop_grace_period指定在容器无法处理 SIGTERM (或者任何 stop_signal 的信号)，等待多久后发送 SIGKILL 信号关闭容器。默认的等待时间是 10 秒。</li><li>stop_signal设置停止容器的替代信号。默认情况下使用 SIGTERM 。</li><li>sysctls设置容器中的内核参数，可以使用数组或字典格式。</li><li>tmpfs在容器内安装一个临时文件系统。可以是单个值或列表的多个值。</li><li>ulimits覆盖容器默认的 ulimit。</li><li>volumes将主机的数据卷或着文件挂载到容器里。</li></ul></li>",3),ie={href:"https://docs.docker.com/compose/compose-file/",target:"_blank",rel:"noopener noreferrer"},ne=i(`<h2 id="docker-其他" tabindex="-1"><a class="header-anchor" href="#docker-其他"><span>Docker 其他</span></a></h2><ul><li>查看docker客户端的所有命令COMMAND选项：docker</li><li>查看docker指定命令的使用方法：docker COMMAND --help</li><li>检查docker的版本：docker -v</li><li>关闭docker：systemctl stop docker</li><li>查看docker状态：systemctl status docker</li><li>强制重启并修复状态：systemctl reset-failed docker.service</li><li>显示 Docker 系统的详细信息 docker info</li></ul><h2 id="docker-swarm-被k8s代替" tabindex="-1"><a class="header-anchor" href="#docker-swarm-被k8s代替"><span>Docker Swarm（被k8s代替）</span></a></h2><p>Docker 的集群管理工具。将主机池转变为单个虚拟主机。所有任何与Docker守护程序通信的工具都轻松地扩展到多个主机<br> swarm集群构成。<br> swarm mananger节点：负责整个集群的管理工作包括集群配置、服务管理等所有跟集群有关的工作。<br> work node节点：负责运行相应的服务来执行任务（task）。</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code># 管理节点初始化swarm集群并得到加入命令
docker swarm init --advertise-addr $swarm_ip
# 工作节点执行加入命令加入集群
docker swarm join --token SWMTKN-1-4oogo9qziq768dma0uh3j0z0m5twlm10iynvz7ixza96k6jh9p-ajkb6w7qd06y1e33yrgko64sk 192.168.99.107:2377
# 查看当前集群的信息：swarm：active，Managers：1，Nodes：1
docker info
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="docker问题" tabindex="-1"><a class="header-anchor" href="#docker问题"><span>Docker问题</span></a></h2><ul><li>the input device is not a TTY. If you are using mintty, try prefixing the command with &#39;winpty&#39;</li><li>windows cmd权限不足，以管理员运行即可</li></ul><h2 id="docker部署带有docker的容器" tabindex="-1"><a class="header-anchor" href="#docker部署带有docker的容器"><span>docker部署带有docker的容器</span></a></h2><div class="language-bash line-numbers-mode" data-ext="sh" data-title="sh"><pre class="language-bash"><code><span class="token comment"># 创建Dockerfile</span>
<span class="token function">cat</span> <span class="token operator">&gt;</span>Dockerfile<span class="token operator">&lt;&lt;-</span><span class="token string">&#39;EOF&#39;
FROM centos:8

# 替换为阿里云源，并安装必要的软件
RUN sed -i &#39;s|mirrorlist=|#mirrorlist=|g&#39; /etc/yum.repos.d/CentOS-* &amp;&amp; \\
    sed -i &#39;s|#baseurl=http://mirror.centos.org|baseurl=http://mirrors.aliyun.com|g&#39; /etc/yum.repos.d/CentOS-* &amp;&amp; \\
    yum install -y yum-utils openssh-server passwd wget tar vim &amp;&amp; \\
    yum clean all &amp;&amp; \\
    rm -rf /var/cache/yum &amp;&amp; \\
    mkdir /var/run/sshd &amp;&amp; \\
    ssh-keygen -A

# 设置 root 密码为 &quot;root&quot;
RUN echo &quot;root:root&quot; | chpasswd

# 下载并安装 JDK，删除临时文件以减少镜像大小
RUN wget --no-check-certificate https://manongbiji.oss-cn-beijing.aliyuncs.com/ittailkshow/devops/download/jdk-8u341-linux-x64.tar.gz &amp;&amp; \\
    tar -zxvf jdk-8u341-linux-x64.tar.gz -C /usr/local &amp;&amp; \\
    mv /usr/local/jdk1.8.0_341 /usr/local/jdk &amp;&amp; \\
    rm -f jdk-8u341-linux-x64.tar.gz

# 配置 JDK 环境变量并写入 /etc/profile
RUN echo &quot;export JAVA_HOME=/usr/local/jdk&quot; &gt;&gt; /etc/profile &amp;&amp; \\
    echo &quot;export PATH=\\$JAVA_HOME/bin:\\$PATH&quot; &gt;&gt; /etc/profile

# 安装 Docker 并删除临时文件
RUN yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo &amp;&amp; \\
    yum install -y docker-ce docker-ce-cli containerd.io &amp;&amp; \\
    yum clean all &amp;&amp; \\
    rm -rf /var/cache/yum

# 配置 JDK 环境变量并写入 /etc/profile
RUN echo &quot;export DOCKER_TLS_CERTDIR=&quot;&quot;&quot; &gt;&gt; /etc/profile &amp;&amp; \\
    echo &quot;export HTTP_PROXY=http://192.168.1.141:7890/&quot; &gt;&gt; /etc/profile &amp;&amp; \\
    echo &quot;export HTTPS_PROXY=http://192.168.1.141:7890/&quot; &gt;&gt; /etc/profile &amp;&amp; \\
    echo &quot;export NO_PROXY=localhost,127.0.0.1,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,169.254.0.0/16&quot; &gt;&gt; /etc/profile &amp;&amp; \\
    mkdir /var/lib/docker &amp;&amp; \\
    mkdir -p /etc/systemd/system/docker.service.d &amp;&amp; \\
    touch /etc/systemd/system/docker.service.d/http-proxy.conf &amp;&amp; \\
    echo &quot;[Service]&quot; &gt;&gt; /etc/systemd/system/docker.service.d/http-proxy.conf &amp;&amp; \\
    echo &quot;Environment=\\&quot;HTTP_PROXY=http://192.168.1.141:7890/\\&quot;&quot; &gt;&gt; /etc/systemd/system/docker.service.d/http-proxy.conf &amp;&amp; \\
    echo &quot;Environment=\\&quot;HTTPS_PROXY=http://192.168.1.141:7890/\\&quot;&quot; &gt;&gt; /etc/systemd/system/docker.service.d/http-proxy.conf &amp;&amp; \\
    echo &quot;Environment=\\&quot;NO_PROXY=localhost,127.0.0.1,10.0.0.0/8,172.16.0.0/12,192.168.0.0/16,169.254.0.0/16\\&quot;&quot; &gt;&gt; /etc/systemd/system/docker.service.d/http-proxy.conf &amp;&amp; \\
    mkdir -p /etc/docker &amp;&amp; \\
    touch /etc/docker/daemon.json &amp;&amp; \\
    echo &quot;{\\&quot;registry-mirrors\\&quot;: [],\\&quot;insecure-registries\\&quot;: [\\&quot;192.168.1.5:8080\\&quot;]}&quot; &gt;&gt; /etc/docker/daemon.json

# 暴露 Docker 和 SSH 的端口
EXPOSE 22 2375

# 设置启动命令，确保容器前台运行
CMD [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;\\
    /usr/sbin/sshd &amp;&amp; \\
    HTTP_PROXY=http://192.168.1.141:7890 \\
    HTTPS_PROXY=http://192.168.1.141:7890 \\
    NO_PROXY=localhost,127.0.0.1 \\
    dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 &amp; \\
    sleep 5 &amp;&amp; \\
    tail -f /dev/null&quot;]
EOF</span>

<span class="token comment"># 构建镜像</span>
<span class="token function">docker</span> build <span class="token parameter variable">-t</span> centos7-root-ssh <span class="token builtin class-name">.</span>

<span class="token comment"># 创建容器</span>
<span class="token function">docker</span> stop centos7-macvlan
<span class="token function">docker</span> <span class="token function">rm</span> centos7-macvlan
<span class="token function">docker</span> run <span class="token parameter variable">-dit</span> <span class="token parameter variable">--privileged</span> <span class="token parameter variable">--name</span> centos7-macvlan <span class="token parameter variable">--network</span> macvlan31 <span class="token parameter variable">--ip</span><span class="token operator">=</span><span class="token number">192.168</span>.1.4 centos7-root-ssh

<span class="token comment"># 查看centos的ip</span>
<span class="token function">docker</span> network inspect macvlan31
<span class="token string">&quot;ee7669e51c31926b7d91f0ce8809a7d7f7a3a0300d7e711549ed4ff9efb2d149&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>
    <span class="token string">&quot;Name&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;centos7-macvlan&quot;</span>,
    <span class="token string">&quot;EndpointID&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;94c356d7ba81b0a7afbc95b2d636e4c04c166cf66079a0cd8ecaba3482beabf3&quot;</span>,
    <span class="token string">&quot;MacAddress&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;02:42:c0:a8:01:04&quot;</span>,
    <span class="token string">&quot;IPv4Address&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;192.168.1.4/24&quot;</span>,
    <span class="token string">&quot;IPv6Address&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;&quot;</span>
<span class="token punctuation">}</span>

<span class="token comment"># docker里面启动docker</span>
dockerd <span class="token operator">&amp;</span>
<span class="token comment"># 关闭docker</span>
<span class="token function">pkill</span> dockerd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,9);function se(oe,te){const n=t("ExternalLinkIcon");return r(),a("div",null,[d,e("ul",null,[u,e("li",null,[l("Docker 引擎 API（Docker Engine API）：Docker提供的RESTful接口，允许客户端与Docker守护进程通信。通过这个API，用户可以执行各种操作，支持跨平台调用。"),p,l(" 功能：向 Docker 守护进程发送 HTTP 请求，实现容器、镜像的管理。"),m,l(" 提供 RESTful 接口，允许通过编程与 Docker 进行交互。"),k,l(" 通过 curl 或其他 HTTP 客户端访问 Docker 引擎 API"),b,l(" 查询当前 Docker 守护进程的版本：curl --unix-socket /var/run/docker.sock "),e("a",v,[l("http://localhost/version"),s(n)])]),h]),g,e("p",null,[l("如果docker-compose的出现异常"),q,D,_,l(" 直接在release中下载对应的linux发行版【docker-compose-linux-x86_64】"),f,e("a",N,[l("https://github.com/docker/compose/releases/tag/v2.18.1"),s(n)]),y,E,x,l(" 下载完后将软件上传至 Linux的【/usr/local/bin】目录下"),R,l(" 重命名：sudo mv docker-compose-linux-x86_64 docker-compose"),T,l(" 将可执行权限应用于二进制文件："),I,O,l(" 创建软链：sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose")]),A,e("ul",null,[P,w,S,e("li",null,[C,e("ul",null,[e("li",null,[l("在 "),e("a",M,[l("https://hub.docker.com"),s(n)]),l(" 免费注册一个 Docker 账号docker id")]),Y,H,L])]),U]),G,e("ul",null,[e("li",null,[l("基于镜像创建/启动容器：docker run [OPTIONS] REPOSITORY[:TAG] [COMMAND] [ARG...] "),e("ul",null,[e("li",null,[l("[OPTIONS] "),e("ul",null,[z,e("li",null,[l("dns-search=xxx 设定容器的搜索域，当设定搜索域为.example.com时，在搜索一个名为host的主机时，DNS不仅搜索 host，"),e("a",j,[l("还会搜索host.example.com"),s(n)])]),X])]),K,F])]),V]),Z,e("ul",null,[B,e("li",null,[J,l("（推荐RUN yum -y install wget "),W,l(' && wget -O redis.tar.gz "'),e("a",$,[l("http://download.redis.io/releases/redis-5.0.3.tar.gz"),s(n)]),l('" \\）')]),Q]),ee,e("ul",null,[le,e("li",null,[e("a",ie,[l("https://docs.docker.com/compose/compose-file/"),s(n)])])]),ne])}const ce=o(c,[["render",se],["__file","docker.html.vue"]]),de=JSON.parse('{"path":"/backend/containerservice/docker.html","title":"Docker","lang":"zh-CN","frontmatter":{"title":"Docker","date":"2023-01-01T00:00:00.000Z","tags":"Docker","categories":"运维","description":"docker Docker概述？场景？优点？ 开源的应用容器引擎，基于 Go 语言 通过容器实现快速打包，测试和部署程序、管理基础架构(快速交付) 容器安全、轻量、可移植、松耦合、可扩展直接在内核运行(同一硬件上可运行多个容器) Web应用的自动化打包和发布。√ 自动化测试和持续集成、发布。√ 在服务型环境中部署和调整数据库或其他的后台应用。 快速，一...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/backend/containerservice/docker.html"}],["meta",{"property":"og:site_name","content":"JavaGuide"}],["meta",{"property":"og:title","content":"Docker"}],["meta",{"property":"og:description","content":"docker Docker概述？场景？优点？ 开源的应用容器引擎，基于 Go 语言 通过容器实现快速打包，测试和部署程序、管理基础架构(快速交付) 容器安全、轻量、可移植、松耦合、可扩展直接在内核运行(同一硬件上可运行多个容器) Web应用的自动化打包和发布。√ 自动化测试和持续集成、发布。√ 在服务型环境中部署和调整数据库或其他的后台应用。 快速，一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMwfd2c5c7d4bb799eaeb7e9adbba3e3694.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-07T01:56:33.000Z"}],["meta",{"property":"article:author","content":"HeChuangJun"}],["meta",{"property":"article:published_time","content":"2023-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-07T01:56:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker\\",\\"image\\":[\\"https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMwfd2c5c7d4bb799eaeb7e9adbba3e3694.png\\",\\"https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMw5e690bcefd7a7b4f720d026068a1aed2.png\\",\\"https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMw76789c859fa3a2b2512994beba0bd0ad.png\\",\\"https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMw25cd520d2c83614914e25eb185fb497a.png\\"],\\"datePublished\\":\\"2023-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-07T01:56:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeChuangJun\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"Docker概述？场景？优点？","slug":"docker概述-场景-优点","link":"#docker概述-场景-优点","children":[]},{"level":2,"title":"Docker架构？组件？","slug":"docker架构-组件","link":"#docker架构-组件","children":[]},{"level":2,"title":"Docker安装","slug":"docker安装","link":"#docker安装","children":[]},{"level":2,"title":"代理","slug":"代理","link":"#代理","children":[]},{"level":2,"title":"镜像源/仓库","slug":"镜像源-仓库","link":"#镜像源-仓库","children":[]},{"level":2,"title":"Docker镜像","slug":"docker镜像","link":"#docker镜像","children":[]},{"level":2,"title":"Docker容器","slug":"docker容器","link":"#docker容器","children":[]},{"level":2,"title":"Docker volume","slug":"docker-volume","link":"#docker-volume","children":[]},{"level":2,"title":"Docker network","slug":"docker-network","link":"#docker-network","children":[]},{"level":2,"title":"Dockerfile","slug":"dockerfile","link":"#dockerfile","children":[]},{"level":2,"title":"docker Compose","slug":"docker-compose","link":"#docker-compose","children":[]},{"level":2,"title":"Docker 其他","slug":"docker-其他","link":"#docker-其他","children":[]},{"level":2,"title":"Docker Swarm（被k8s代替）","slug":"docker-swarm-被k8s代替","link":"#docker-swarm-被k8s代替","children":[]},{"level":2,"title":"Docker问题","slug":"docker问题","link":"#docker问题","children":[]},{"level":2,"title":"docker部署带有docker的容器","slug":"docker部署带有docker的容器","link":"#docker部署带有docker的容器","children":[]}],"git":{"createdTime":1733536593000,"updatedTime":1733536593000,"contributors":[{"name":"HeChuangJun","email":"1105128664@qq.com","commits":1}]},"readingTime":{"minutes":27.33,"words":8199},"filePathRelative":"backend/containerservice/docker.md","localizedDate":"2023年1月1日","excerpt":"<p>docker</p>\\n<!--more-->\\n<h2>Docker概述？场景？优点？</h2>\\n<p>开源的应用容器引擎，基于 Go 语言<br>\\n通过容器实现快速打包，测试和部署程序、管理基础架构(快速交付)<br>\\n容器安全、轻量、可移植、松耦合、可扩展直接在内核运行(同一硬件上可运行多个容器)</p>\\n<p>Web应用的自动化打包和发布。√<br>\\n自动化测试和持续集成、发布。√<br>\\n在服务型环境中部署和调整数据库或其他的后台应用。</p>\\n<p>快速，一致地交付您的应用程序<br>\\n响应式部署和扩展<br>\\n在同一硬件上运行更多工作负载</p>\\n<h2>Docker架构？组件？</h2>","autoDesc":true}');export{ce as comp,de as data};
