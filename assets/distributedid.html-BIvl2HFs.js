import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as i,e as r}from"./app-7KT7HDzT.js";const n={},o=r('<h2 id="如何设计分布式id-生成方法-√" tabindex="-1"><a class="header-anchor" href="#如何设计分布式id-生成方法-√"><span>如何设计分布式ID？生成方法？√</span></a></h2><p>全局唯一<br> 高性能：低延时，响应要快，否则反倒会成为业务瓶颈<br> 高可用<br> 好接入：使用方便<br> 趋势递增（可选）</p><p><strong>UUID</strong><br><strong>雪花算法</strong>：twitter开源：用64bit的long型数字作为全局唯一id<br> 1个bit：符号位。0表示正数，1表示负数。<br> 41个bit：时间戳。单位毫秒。最多表示2^41-1毫秒，约等于69年(1970开始)<br> 5个bit：机房id，最多表示2^5个机房<br> 5个bit：机器id。~<br> 12个bit：序号<br> 高性能，高可用，内存生成，不依赖数据库，容量大：一毫秒内最多生成4096(2^12-1)个id。自增，因为时间自增<br> 系统时间被回调或者改变可能造成id重复。通过记录最后一个生成id的时间戳或生成id前比较当前服务器时钟是否被回拨，避免生成重复id</p><p><strong>redis集群的incr方法</strong>：注意持久化避免宕机后ID重复<br><strong>百度uid-generator</strong><br><strong>美团Leaf</strong></p><p>前端<br> UUID（推荐）：简单易用<br> 时间戳 + 随机数：对全局唯一性要求不高的场景。<br> 设备信息 + 时间戳：适合某些特定环境下生成唯一ID，但实现复杂<br> 哈希算法：适合基于输入数据生成唯一ID，例如基于消息内容生成ID。</p>',5),d=[o];function a(s,b){return e(),i("div",null,d)}const l=t(n,[["render",a],["__file","distributedid.html.vue"]]),g=JSON.parse('{"path":"/interview/distributed/distributedid.html","title":"分布式ID","lang":"zh-CN","frontmatter":{"title":"分布式ID","date":"2023-01-01T00:00:00.000Z","tags":"面试","categories":"面试","description":"如何设计分布式ID？生成方法？√ 全局唯一 高性能：低延时，响应要快，否则反倒会成为业务瓶颈 高可用 好接入：使用方便 趋势递增（可选） UUID 雪花算法：twitter开源：用64bit的long型数字作为全局唯一id 1个bit：符号位。0表示正数，1表示负数。 41个bit：时间戳。单位毫秒。最多表示2^41-1毫秒，约等于69年(1970开始...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/interview/distributed/distributedid.html"}],["meta",{"property":"og:site_name","content":"JavaGuide"}],["meta",{"property":"og:title","content":"分布式ID"}],["meta",{"property":"og:description","content":"如何设计分布式ID？生成方法？√ 全局唯一 高性能：低延时，响应要快，否则反倒会成为业务瓶颈 高可用 好接入：使用方便 趋势递增（可选） UUID 雪花算法：twitter开源：用64bit的long型数字作为全局唯一id 1个bit：符号位。0表示正数，1表示负数。 41个bit：时间戳。单位毫秒。最多表示2^41-1毫秒，约等于69年(1970开始..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"HeChuangJun"}],["meta",{"property":"article:published_time","content":"2023-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式ID\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeChuangJun\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"如何设计分布式ID？生成方法？√","slug":"如何设计分布式id-生成方法-√","link":"#如何设计分布式id-生成方法-√","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":1.24,"words":371},"filePathRelative":"interview/distributed/distributedid.md","localizedDate":"2023年1月1日","excerpt":"<h2>如何设计分布式ID？生成方法？√</h2>\\n<p>全局唯一<br>\\n高性能：低延时，响应要快，否则反倒会成为业务瓶颈<br>\\n高可用<br>\\n好接入：使用方便<br>\\n趋势递增（可选）</p>\\n<p><strong>UUID</strong><br>\\n<strong>雪花算法</strong>：twitter开源：用64bit的long型数字作为全局唯一id<br>\\n1个bit：符号位。0表示正数，1表示负数。<br>\\n41个bit：时间戳。单位毫秒。最多表示2^41-1毫秒，约等于69年(1970开始)<br>\\n5个bit：机房id，最多表示2^5个机房<br>\\n5个bit：机器id。~<br>\\n12个bit：序号<br>\\n高性能，高可用，内存生成，不依赖数据库，容量大：一毫秒内最多生成4096(2^12-1)个id。自增，因为时间自增<br>\\n系统时间被回调或者改变可能造成id重复。通过记录最后一个生成id的时间戳或生成id前比较当前服务器时钟是否被回拨，避免生成重复id</p>","autoDesc":true}');export{l as comp,g as data};
