import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as l,c as r,e as t}from"./app-7KT7HDzT.js";const i={},a=t('<h1 id="_1-谈谈你对-mvc-模式的理解-√" tabindex="-1"><a class="header-anchor" href="#_1-谈谈你对-mvc-模式的理解-√"><span>1. 谈谈你对 MVC 模式的理解？√</span></a></h1><ul><li>MVC是Model—View—Controller简称，它是一种架构模式，它分离了表现与交互。它被分为三个核心部件：模型、视图、控制器</li><li>Model（模型）：指javaBean 是程序的主体部分，主要包含业务数据和逻辑。在模型层，还会涉及到用户发布的服务，在服务中会根据不同的业务需求，更新业务模型中的数据。</li><li>View（视图）：指JSP或者HTML 是程序呈现给用户的部分，是用户和程序交互的接口，用户会根据具体的业务需求，在View视图层输入自己特定的业务数据，并通过界面的事件交互，将对应的输入参数提交给后台控制器进行处理</li><li>Controller（控制器）：指servlet或者Filter Controller用来处理用户输入数据，以及更新业务模型的部分。控制器中接收了用户与界面交互时传递过来的数据，并根据数据业务逻辑来执行服务的调用和更新业务模型的数据和状态</li></ul><h1 id="_3-springmvc执行流程-√springmvc-的核心组件有哪些-handleradapter作用-√" tabindex="-1"><a class="header-anchor" href="#_3-springmvc执行流程-√springmvc-的核心组件有哪些-handleradapter作用-√"><span>3. springMVC执行流程？√SpringMVC 的核心组件有哪些？HandlerAdapter作用？√</span></a></h1><ul><li>架构流程 <ul><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)以 HandlerExecutionChain 对象的形式返回给DispatcherServlet</li><li>DispatcherServlet调用HandlerAdapter处理器适配器调用处理器。中途调用拦截器的preHandle和postHandle方法，HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器ViewReslover解析后返回具体View</li><li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</li><li>DispatcherServlet响应用户</li></ul></li><li>组件说明 <ul><li>DispatcherServlet：前端控制器，相当于mvc模式中的c，流程控制中心，由它调用其它组件处理用户的请求，降低了组件之间的耦合性。</li><li>HandlerMapping：处理器映射器。负责根据用户请求url找到Handler即处理器，提供配置文件方式，实现接口方式，注解方式等映射方式</li><li>Handler：处理器，后端控制器，具体的用户请求进行处理。涉及到具体的用户业务请求，需要程序员根据业务需求开发Handler</li><li>HandlAdapter：处理器适配器，适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。DispatcherServlet会根据controller对应的controller类型来调用相应的HandlerAdapter来进行处理，负责表单数据的验证、数据类型的转换、将表单数据封装到 JavaBean 等</li><li>ViewResolver：视图解析器。首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户</li><li>ModelAndView：装载了模型数据和视图信息，作为Handler处理结果返回给DispatcherServlet。</li><li>View：支持View视图类型：jstlView、freemarkerView、pdfView等</li><li>HandlerInterceptor：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</li><li>HandlerExecutionChain：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor（系统会有一个默认的 HandlerInterceptor，如果需要额外设置拦截，可以添加拦截器）。</li></ul></li><li>三大组件：处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。需要用户开发的组件有handler、view<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/4e64fa261b3306be5d57d.png" alt="springmvcexecutionflow.png"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/a4dbc7ba97069479b942b.jpg" alt="springmvcexecutionflow2.png"></li></ul><h1 id="springmvc-restful风格的接口的流程是什么样的呢" tabindex="-1"><a class="header-anchor" href="#springmvc-restful风格的接口的流程是什么样的呢"><span>SpringMVC Restful风格的接口的流程是什么样的呢？</span></a></h1><ul><li>客户端向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet</li><li>DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理</li><li>DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller</li><li>Controller被封装成了ServletInvocableHandlerMethod，HandlerAdapter处理器适配器去执行invokeAndHandle方法，完成对Controller的请求处理</li><li>HandlerAdapter执行完对Controller的请求，会调用HandlerMethodReturnValueHandler去处理返回值，主要的过程： <ul><li>调用RequestResponseBodyMethodProcessor，创建ServletServerHttpResponse（Spring对原生ServerHttpResponse的封装）实例</li><li>使用HttpMessageConverter的write方法，将返回值写入ServletServerHttpResponse的OutputStream输出流中</li><li>在写入的过程中，会使用JsonGenerator（默认使用Jackson框架）对返回值进行Json序列化</li></ul></li><li>执行完请求后，返回的ModealAndView为null，ServletServerHttpResponse里也已经写入了响应，所以不用关心View的处理<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/0630239e8e2b0b062ba02.png" alt="springmvcrestful.png"></li></ul><h1 id="_4-简述springmvc中使用的设计模式以及在springmvc中的应用场景-1-2个" tabindex="-1"><a class="header-anchor" href="#_4-简述springmvc中使用的设计模式以及在springmvc中的应用场景-1-2个"><span>4. 简述SpringMVC中使用的设计模式以及在SpringMVC中的应用场景(1-2个)</span></a></h1><ul><li>单例模式：springmvc的controller默认是单例的</li><li>代理模式：springmvc的controller是通过代理产生的</li></ul><h1 id="_5-springmvc-常用的注解有哪些" tabindex="-1"><a class="header-anchor" href="#_5-springmvc-常用的注解有哪些"><span>5. SpringMVC 常用的注解有哪些？</span></a></h1><ul><li>@RequestMapping：用于处理请求url映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径；方法上则映射url和http请求方法</li><li>@RequestBody：注解实现接收 HTTP 请求的 json 数据，将 json 转换为 Java 对象；</li><li>@ResponseBody：注解实现将 Controller 方法返回对象转化为 json 对象响应给客户。需要配合相应的支持 JSON 格式化的 HttpMessageConverter 实现类</li><li>@Controller，它将一个类标记为 Spring Web MVC 控制器 Controller</li><li>@RestController，在 @Controller 基础上，增加了 @ResponseBody，提供Restful API ，返回例如 JSON 数据格式。当然，返回什么样的数据格式，根据客户端的 &quot;ACCEPT&quot; 请求头决定。</li><li>@PathVariable从 URI 读取值，比如查询参数</li></ul><h1 id="_6-requestmapping-和-getmapping-注解的不同之处在哪里" tabindex="-1"><a class="header-anchor" href="#_6-requestmapping-和-getmapping-注解的不同之处在哪里"><span>6. @RequestMapping 和 @GetMapping 注解的不同之处在哪里？</span></a></h1><ul><li>@RequestMapping可注解在类和方法上；@GetMapping 仅可注册在方法上</li><li>@RequestMapping可进行GET、POST、PUT、DELETE等请求方法；@GetMapping是@RequestMapping的GET请求方法的特例</li></ul><h1 id="_7-如何解决post、get请求中文乱码问题" tabindex="-1"><a class="header-anchor" href="#_7-如何解决post、get请求中文乱码问题"><span>7. 如何解决POST、GET请求中文乱码问题？</span></a></h1><ul><li>POST：web.xml中配置一个 CharacterEncodingFilter 过滤器，设置成 utf-8；</li><li>GET： <ul><li>方法1：修改tomcat配置文件添加编码与工程编码一致，&lt;ConnectorURIEncoding=&quot;utf-8&quot; connectionTimeout=&quot;20000&quot; port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; redirectPort&gt;</li><li>方法2：对参数进行重新编码：String userName = new String(request.getParamter(&quot;userName&quot;).getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;)</li></ul></li></ul><h1 id="_8-springmvc异常处理" tabindex="-1"><a class="header-anchor" href="#_8-springmvc异常处理"><span>8. springmvc异常处理</span></a></h1><ul><li>Spring MVC提供了异常解析器HandlerExceptionResolver接口，将处理器(handler)执行时发生的异常，解析(转换)成对应的ModelAndView结果</li></ul><h1 id="_9-spring-mvc-拦截器有哪些方法-作用" tabindex="-1"><a class="header-anchor" href="#_9-spring-mvc-拦截器有哪些方法-作用"><span>9. Spring MVC 拦截器有哪些方法？作用？</span></a></h1><ul><li>preHandle方法，调用Controller方法前执行。按拦截器定义顺序调用。若任一拦截器返回false ，则Controller方法不再调用。</li><li>postHandle方法，调用Controller方法后执行。按拦截器定义逆序调用</li><li>afterCompletion方法，处理完Controller方法返回结果后执行.按拦截器定义逆序调用.只要preHandle方法返回true时就会执行.无视异常</li><li>记录访问日志。记录异常日志。需要登陆的请求操作，拦截未登陆的用户。</li></ul><h1 id="_10-spring-mvc-的拦截器和-filter-过滤器有什么差别" tabindex="-1"><a class="header-anchor" href="#_10-spring-mvc-的拦截器和-filter-过滤器有什么差别"><span>10. Spring MVC 的拦截器和 Filter 过滤器有什么差别？</span></a></h1><ul><li>功能相同：拦截器和 Filter都能实现相应的功能，谁也不比谁强。</li><li>容器不同：拦截器构建在 Spring MVC 体系中；Filter 构建在 Servlet 容器之上。</li><li>使用便利性不同：拦截器提供了三个方法，分别在不同的时机执行；过滤器仅提供一个方法，当然也能实现拦截器的执行时机的效果，就是麻烦一些。</li></ul><h1 id="_11-什么是安全的rest操作" tabindex="-1"><a class="header-anchor" href="#_11-什么是安全的rest操作"><span>11. 什么是安全的REST操作?</span></a></h1><ul><li>REST接口是否安全的界限，在于是否修改服务端的资源。因此GET和HEAD是安全的，PUT,POST 和 DELETE是不安全的</li></ul><h1 id="_12-什么是幂等操作-为什么幂等操作如此重要" tabindex="-1"><a class="header-anchor" href="#_12-什么是幂等操作-为什么幂等操作如此重要"><span>12. 什么是幂等操作? 为什么幂等操作如此重要?</span></a></h1><ul><li>用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。</li><li>POST方法不是幂等操作 ，因为如果发送多个 POST 请求，它将在服务端创建不同的资源。但是PUT更新资源是幂等操作。甚至多个PUT请求被用来更新服务端资源，将得到相同的结果。</li></ul><h1 id="_13-rest-用哪种-http-方法呢" tabindex="-1"><a class="header-anchor" href="#_13-rest-用哪种-http-方法呢"><span>13. REST 用哪种 HTTP 方法呢?</span></a></h1><ul><li>GET检索服务端资源</li><li>POST创建服务端资源</li><li>PUT更新服务端资源</li><li>DELETE删除服务端资源</li></ul><h1 id="_14-rest-api是无状态的吗" tabindex="-1"><a class="header-anchor" href="#_14-rest-api是无状态的吗"><span>14. REST API是无状态的吗?</span></a></h1><ul><li>REST API是无状态的，因为基于HTTP也是无状态。</li><li>REST API请求应该包含处理它所需的所有细节。它不应该依赖于以前或下一个请求或服务器端维护的一些数据，例如会话。</li></ul><h1 id="_15-如何创建-httpmessageconverter-的自定义实现来支持一种新的请求-响应" tabindex="-1"><a class="header-anchor" href="#_15-如何创建-httpmessageconverter-的自定义实现来支持一种新的请求-响应"><span>15. 如何创建 HttpMessageConverter 的自定义实现来支持一种新的请求/响应？</span></a></h1><ul><li>自定义的AbstractHttpMessageConverter实现，并使用WebMvcConfigurerAdapter的#extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) 方法注册</li></ul>',30),n=[a];function p(s,o){return l(),r("div",null,n)}const h=e(i,[["render",p],["__file","springmvc.html.vue"]]),g=JSON.parse('{"path":"/interview/springmvc.html","title":"springmvc","lang":"zh-CN","frontmatter":{"title":"springmvc","date":"2023-01-01T00:00:00.000Z","tags":"java","categories":"面试","description":"1. 谈谈你对 MVC 模式的理解？√ MVC是Model—View—Controller简称，它是一种架构模式，它分离了表现与交互。它被分为三个核心部件：模型、视图、控制器 Model（模型）：指javaBean 是程序的主体部分，主要包含业务数据和逻辑。在模型层，还会涉及到用户发布的服务，在服务中会根据不同的业务需求，更新业务模型中的数据。 Vie...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/interview/springmvc.html"}],["meta",{"property":"og:site_name","content":"JavaGuide"}],["meta",{"property":"og:title","content":"springmvc"}],["meta",{"property":"og:description","content":"1. 谈谈你对 MVC 模式的理解？√ MVC是Model—View—Controller简称，它是一种架构模式，它分离了表现与交互。它被分为三个核心部件：模型、视图、控制器 Model（模型）：指javaBean 是程序的主体部分，主要包含业务数据和逻辑。在模型层，还会涉及到用户发布的服务，在服务中会根据不同的业务需求，更新业务模型中的数据。 Vie..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://290ff162.telegraph-image-eg9.pages.dev/file/4e64fa261b3306be5d57d.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-07T01:56:33.000Z"}],["meta",{"property":"article:author","content":"HeChuangJun"}],["meta",{"property":"article:published_time","content":"2023-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-07T01:56:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"springmvc\\",\\"image\\":[\\"https://290ff162.telegraph-image-eg9.pages.dev/file/4e64fa261b3306be5d57d.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/a4dbc7ba97069479b942b.jpg\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/0630239e8e2b0b062ba02.png\\"],\\"datePublished\\":\\"2023-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-07T01:56:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeChuangJun\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[],"git":{"createdTime":1733536593000,"updatedTime":1733536593000,"contributors":[{"name":"HeChuangJun","email":"1105128664@qq.com","commits":1}]},"readingTime":{"minutes":7.54,"words":2262},"filePathRelative":"interview/springmvc.md","localizedDate":"2023年1月1日","excerpt":"<!-- TOC -->\\n<!-- /TOC -->\\n<h1>1. 谈谈你对 MVC 模式的理解？√</h1>\\n<ul>\\n<li>MVC是Model—View—Controller简称，它是一种架构模式，它分离了表现与交互。它被分为三个核心部件：模型、视图、控制器</li>\\n<li>Model（模型）：指javaBean 是程序的主体部分，主要包含业务数据和逻辑。在模型层，还会涉及到用户发布的服务，在服务中会根据不同的业务需求，更新业务模型中的数据。</li>\\n<li>View（视图）：指JSP或者HTML 是程序呈现给用户的部分，是用户和程序交互的接口，用户会根据具体的业务需求，在View视图层输入自己特定的业务数据，并通过界面的事件交互，将对应的输入参数提交给后台控制器进行处理</li>\\n<li>Controller（控制器）：指servlet或者Filter Controller用来处理用户输入数据，以及更新业务模型的部分。控制器中接收了用户与界面交互时传递过来的数据，并根据数据业务逻辑来执行服务的调用和更新业务模型的数据和状态</li>\\n</ul>","autoDesc":true}');export{h as comp,g as data};
