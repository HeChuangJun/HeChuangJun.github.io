import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r,o as s,c as o,a as i,b as e,d as a,e as l}from"./app-7KT7HDzT.js";const c={},d=l(`<h1 id="_1-spring是什么-特性" tabindex="-1"><a class="header-anchor" href="#_1-spring是什么-特性"><span>1. Spring是什么？特性？</span></a></h1><ul><li>Spring是一个轻量级、非入侵式的控制反转(IoC)和面向切面(AOP)的框架。</li><li>IoC和DI的支持:管理对象生命周期和依赖关系</li><li>AOP编程的支持：面向切面编程可以实现对程序进行权限拦截、运行监控等切面功能。</li><li>声明式事务的支持：支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式。</li><li>快捷测试的支持：支持Junit注解测试Spring程序。</li><li>快速集成功能：方便集成各种优秀框架</li><li>复杂API模板封装：对JDBC、JavaMail等提供了模板化的封装，降低应用难度</li></ul><h1 id="_2-spring有哪些模块" tabindex="-1"><a class="header-anchor" href="#_2-spring有哪些模块"><span>2. Spring有哪些模块？</span></a></h1><ul><li>Spring Core：Spring 核心，它是框架最基础的部分，提供 IoC 和依赖注入 DI 特性。</li><li>Spring Context：Spring 上下文容器，它是 BeanFactory 功能加强的一个子接口。</li><li>Spring Web：它提供 Web 应用开发的支持。</li><li>Spring MVC：它针对 Web 应用中 MVC 思想的实现。</li><li>Spring DAO：提供对 JDBC 抽象层，简化了 JDBC 编码，同时，编码更具有健壮性。</li><li>Spring ORM：它支持用于流行的 ORM 框架的整合，比如：Spring + Hibernate、Spring + iBatis、Spring + JDO 的整合等</li><li>Spring AOP：即面向切面编程，它提供了与 AOP 联盟兼容的编程实现。</li></ul><h1 id="_3-spring常用注解" tabindex="-1"><a class="header-anchor" href="#_3-spring常用注解"><span>3. Spring常用注解？</span></a></h1><ul><li>Web: <ul><li>@Controller：组合注解（组合了@Component注解），应用在MVC层（控制层）。</li><li>@RestController：@Controller和@ResponseBody的组合注解，注解在类上则该Controller的所有方法都默认加上了@ResponseBody。</li><li>@RequestMapping：用于映射Web请求，包括访问路径和参数。Restful接口根据请求类型使用不同的注解：@GetMapping、@PostMapping、@PutMapping、@DeleteMapping</li><li>@ResponseBody：将返回值放在response内，通常返回json数据。</li><li>@RequestBody：将request的参数放在request体中</li><li>@PathVariable：用于接收路径参数，比如@RequestMapping(“/hello/{name}”)申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</li></ul></li><li>容器: <ul><li>@Component：将类变为Spring管理的Bean。</li><li>@Service：组合注解（组合了@Component注解），应用在service层（业务逻辑层）。</li><li>@Repository：组合注解（组合了@Component注解），应用在dao层（数据访问层）。</li><li>@Autowired：Spring提供的工具（由Spring的依赖注入工具（BeanPostProcessor、BeanFactoryPostProcessor）自动注入）。</li><li>@Qualifier：用于区分两个以上相同类型的Bean</li><li>@Configuration：声明当前类是一个配置类（相当于一个Spring配置的xml文件）</li><li>@Value：可用在字段，构造器参数跟方法参数指定默认值，支持#{}跟\${}方式。一般将SpringbBoot中的application.properties配置的属性值赋值给变量。</li><li>@Bean：注解在方法上，声明当前方法的返回值为一个Bean。返回的Bean对应的类中可以定义init()方法和destroy()方法，然后在@Bean(initMethod=”init”,destroyMethod=”destroy”)定义，在构造之后执行init，在销毁之前执行destroy。</li><li>@Scope:定义采用什么模式创建Bean（方法上，得有@Bean）包括：Singleton、Prototype、Request、Session、GlobalSession。</li></ul></li><li>AOP: <ul><li>@Aspect:声明一个切面（类上）使用@After、@Before、@Around定义建言（advice），可直接将拦截规则（切点）作为参数。 <ul><li>@After：在方法执行之后执行（方法上）。</li><li>@Before：在方法执行之前执行（方法上）。</li><li>@Around：在方法执行之前与之后执行（方法上）。</li><li>@PointCut：声明切点在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持（类上）。</li></ul></li></ul></li><li>事务：@Transactional：在要开启事务的方法上使用，即可声明式开启事务。</li></ul><h1 id="_5-spring中都用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#_5-spring中都用到了哪些设计模式"><span>5. Spring中都用到了哪些设计模式？</span></a></h1><ul><li>工厂模式—使用工厂模式通过BeanFactory、ApplicationContext创建bean对象。</li><li>代理模式—SpringAOP功能功能就是通过代理模式来实现的，分为动态代理和静态代理。</li><li>单例模式—Spring中定义的Bean默认为单例模式。</li><li>模板方法—解决代码重复的问题。比如RestTemplate、JmsTemplate、JdbcTemplate。</li><li>观察者模式:Spring事件驱动模型就是观察者模式很经典的一个应用。</li><li>适配器模式:SpringAOP的增强或通知(Advice)使用到了适配器模式、SpringMVC中也是用到了适配器模式适配Controller。</li><li>策略模式：Spring中有一个Resource接口，它的不同实现类，会根据不同的策略去访问资源。</li><li>前端控制器—Spring提供了DispatcherServlet来对请求进行分发。</li><li>视图帮助(ViewHelper)—Spring提供了一系列的JSP标签，高效宏来辅助将分散的代码整合在视图里。</li><li>依赖注入—贯穿于BeanFactory/ApplicationContext接口的核心理念。</li></ul><h1 id="_12-什么是ioc控制反转-好处" tabindex="-1"><a class="header-anchor" href="#_12-什么是ioc控制反转-好处"><span>12. 什么是ioc控制反转?好处？</span></a></h1><ul><li>Inverse Of Control反转控制：将对象的生命周期交给spring容器管理</li><li>它将最小化应用程序中的代码量</li><li>它以最小的影响和最少的侵入机制促进松耦合</li><li>支持即时的实例化和延迟加载Bean对象</li><li>易于测试，因为不需要单元测试用例中的任何单例或JNDI查找机制。</li></ul><h1 id="_16-spring的di" tabindex="-1"><a class="header-anchor" href="#_16-spring的di"><span>16. spring的di</span></a></h1><ul><li>dependency Injection依赖注入,是ioc的实现方式 <ul><li>注入方式：set/属性方法注入、构造方法注入、字段注入</li><li>注入类型：值类型注入（8大基本数据类型）、引用类型注入 将依赖对象注入</li></ul></li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>set方法注入
&lt;bean  name=&quot;user&quot; class=&quot;cn.itcast.bean.User&quot; &gt;
	&lt;!--值类型注入: 为User对象中名为name的属性注入tom作为值 --&gt;
	&lt;property name=&quot;name&quot; value=&quot;tom&quot; &gt;&lt;/property&gt;
	&lt;!-- 引用类型注入: 为car属性注入下方配置的car对象 --&gt;
	&lt;property name=&quot;car&quot;  ref=&quot;car&quot; &gt;&lt;/property&gt;
	&lt;!--数组类型注入: 如果数组中只准备类一个值（对象），直接使用value|ref--&gt;
	&lt;property name=&quot;arr&quot; value=&quot;tom&quot;&gt;&lt;/property&gt;
	&lt;property name=&quot;arr&quot;&gt;
		&lt;array&gt;
			&lt;value&gt;tom&lt;/value&gt;
			&lt;ref bean=&quot;user&quot;/&gt;
		&lt;array&gt;
	&lt;/property&gt;
	&lt;!-- List类型注入：如果list中只准备类一个值（对象），直接使用value|ref--&gt;
	&lt;property name=&quot;list&quot; value=&quot;jack&quot;&gt;&lt;/property&gt;
	&lt;property name=&quot;list&quot;&gt;
		&lt;list&gt;
			&lt;value&gt;jack&lt;/value&gt;
			&lt;ref bean=&quot;user&quot;/&gt;
		&lt;list&gt;
	&lt;/property&gt;
	&lt;!-- Properties类型注入 --&gt;
	&lt;property name=&quot;prop&quot;&gt;
		&lt;props&gt;
			&lt;prop key=&quot;driverClass&quot;&gt;com.jdbc.mysql.Driver&lt;/prop&gt;
		&lt;props&gt;
	&lt;/property&gt;
	&lt;!-- Map类型注入 --&gt;
	&lt;property name=&quot;map&quot;&gt;
		&lt;map&gt;
			&lt;entry key=&quot;url&quot; value=&quot;jdbc:mysql:///crm&quot;&gt;&lt;/entry&gt;
		&lt;map&gt;
	&lt;/property&gt;
&lt;/bean&gt;
&lt;!-- 将car对象配置到容器中 --&gt;
&lt;bean name=&quot;car&quot; class=&quot;cn.itcast.bean.Car&quot; &gt;
	&lt;property name=&quot;name&quot; value=&quot;兰博基尼&quot; &gt;&lt;/property&gt;
&lt;/bean&gt;


构造函数注入
&lt;bean name=&quot;user2&quot; class=&quot;cn.itcast.bean.User&quot; &gt;
	&lt;!-- name属性: 构造函数的参数名  index属性: 
	构造函数的参数索引 type属性: 构造函数的参数类型--&gt;
	&lt;constructor-arg name=&quot;name&quot; index=&quot;0&quot; type=&quot;java.lang.Integer&quot; value=&quot;999&quot;&gt;&lt;/constructor-arg&gt;
	&lt;constructor-arg name=&quot;car&quot; index=&quot;1&quot; ref=&quot;car&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_14-简述spring-ioc的实现机制" tabindex="-1"><a class="header-anchor" href="#_14-简述spring-ioc的实现机制"><span>14. 简述Spring IoC的实现机制？</span></a></h1><ul><li>原理：工厂模式加反射机制</li><li>a. 加载配置文件，解析成BeanDefinition放在Map里</li><li>b. BeanFactory调用getBean的时候，从BeanDefinition所属的Map里，拿出Class对象进行实例化，如果有依赖关系，将递归调用getBean方法 —— 完成依赖注入。</li></ul><h1 id="_13-说说applicationcontext-beanfactory" tabindex="-1"><a class="header-anchor" href="#_13-说说applicationcontext-beanfactory"><span>13. 说说applicationContext&amp;BeanFactory</span></a></h1><ul><li>BeanFactory接口：创建并管理各种类的对象。每次在获得对象时才会创建对象.最常用的是XmlBeanFactory，根据XML文件中内容创建相应Bean</li><li>ApplicationContext建立在BeanFactoty基础上。每次容器启动时就会创建容器中配置的所有对象.并提供更多功能 <ul><li>1、ClassPathXmlApplicationContext ：从 ClassPath 的 XML 配置文件中读取上下文，并生成上下文定义。应用程序上下文从程序环境变量中取得。</li><li>2、FileSystemXmlApplicationContext ：由文件系统中的XML配置文件读取上下文</li><li>3、XmlWebApplicationContext ：由Web应用的XML文件读取上下文。在 Spring MVC 使用</li><li>4、Spring Boot 的ConfigServletWebServerApplicationContext</li></ul></li></ul><h1 id="_17-spring容器启动阶段会干什么" tabindex="-1"><a class="header-anchor" href="#_17-spring容器启动阶段会干什么"><span>17. Spring容器启动阶段会干什么？</span></a></h1><ul><li>IoC容器工作的过程可以划分两个阶段</li><li>容器启动阶段：加载配置，分析配置信息，装配到BeanDefinition，其他后处理</li><li>Bean实例化阶段：实例化对象，装配依赖， 生命周期回调， 对象其他处理， 注册回调接口</li></ul><h1 id="_18-spring-bean在容器的生命周期是什么样的" tabindex="-1"><a class="header-anchor" href="#_18-spring-bean在容器的生命周期是什么样的"><span>18. Spring Bean在容器的生命周期是什么样的？</span></a></h1>`,20),p=i("li",null,[e("实例化Bean对象: "),i("ul",null,[i("li",null,"根据配置中Bean Definition中实例化Bean对象（通过XML，Java注解或Java Config代码提供）")])],-1),u=i("li",null,[e("属性赋值：Aware相关的属性，注入到Bean对象 "),i("ul",null,[i("li",null,"如果Bean实现BeanNameAware接口，则工厂通过传递Bean的beanName调用setBeanName(String name)方法"),i("li",null,"如果Bean实现BeanFactoryAware接口，工厂通过传递自身的实例来调用setBeanFactory(BeanFactory beanFactory)方法")])],-1),v=i("li",null,"@PostConstruct",-1),g=i("li",null,"如果存在与Bean关联的任何BeanPostProcessor，则调用#preProcessBeforeInitialization(Object bean, String beanName) 方法。",-1),b=i("li",null,"如果Bean实现InitializingBean接口，则会调用#afterPropertiesSet() 方法。",-1),m=i("li",null,"如果存在与Bean关联的任何 BeanPostProcessor，则调用#postProcessAfterInitialization(Object bean, String beanName) 方法。",-1),h=i("li",null,"@PreDestroy",-1),A=i("li",null,"如果Bean实现DisposableBean接口，当 spring 容器关闭时，会调用 #destroy() 方法。",-1),P=i("br",null,null,-1),B=i("img",{src:"https://290ff162.telegraph-image-eg9.pages.dev/file/9d7d1e010e6a298683def.jpg",alt:"beanlife.png"},null,-1),f=l(`<h1 id="_15-spring有哪些自动装配的方式" tabindex="-1"><a class="header-anchor" href="#_15-spring有哪些自动装配的方式"><span>15. Spring有哪些自动装配的方式?</span></a></h1><ul><li>byName根据名称进行自动匹配</li><li>byType根据类型进行自动匹配</li><li>constructor spring根据bean构造函数入参类型自动装配</li><li>autodetect 如果Bean提供了默认的构造函数，则采用byType，否则采用constructor。</li></ul><h1 id="_4-spring中的bean作用域scope类型√" tabindex="-1"><a class="header-anchor" href="#_4-spring中的bean作用域scope类型√"><span>4. spring中的bean作用域scope类型√</span></a></h1><ul><li>singleton(默认):被标识为单例的对象，在spring容器中只存在一个实例</li><li>prototype:被标识为多例的对象,每次获取都会创建新对象</li><li>request:web环境下.对象与request生命周期一致.</li><li>session:web环境下,对象与session生命周期一致.</li><li>Application:对象与Web Application生命周期一致，只能在同一个webapplication中获取</li></ul><h1 id="_8-spring框架中的单例bean是线程安全的吗-√" tabindex="-1"><a class="header-anchor" href="#_8-spring框架中的单例bean是线程安全的吗-√"><span>8. spring框架中的单例bean是线程安全的吗？√</span></a></h1><ul><li>如果单例Bean是无状态的，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。</li><li>如果bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。解决办法就是将多态bean的作用域由“singleton”变更为“prototype”或者将变量放入ThreadLocal中</li></ul><h1 id="_6-如何解决spring-bean中的循环依赖-√为何使用三级缓存解决循环依赖而不是二级缓存" tabindex="-1"><a class="header-anchor" href="#_6-如何解决spring-bean中的循环依赖-√为何使用三级缓存解决循环依赖而不是二级缓存"><span>6. 如何解决spring bean中的循环依赖？√为何使用三级缓存解决循环依赖而不是二级缓存?</span></a></h1><ul><li>单例模式下Spring可以解决哪些情况的循环依赖 <ul><li>多例模式不支持，无限创建对象</li><li>AB均采用构造器注入，不支持。直接抛出BeanCurrentlylnCreationException异常。</li><li>AB均采用setter注入，支持</li><li>AB均采用属性自动注入，支持</li><li>A中注入的B为setter注入，B中注入的A为构造器注入，支持</li><li>B中注入的A为setter注入，A中注入的B为构造器注入，不支持</li><li>第四种可以，第五种不可以的原因是Spring在创建Bean时默认会根据自然排序进行创建，所以A会先于B进行创建。</li></ul></li><li>spring通过三级缓存解决循环依赖， <ul><li>singletonObjects 一级缓存。保存实例化、属性赋值、初始化完成的bean实例</li><li>earlySingletonObjects 二级缓存 。保存实例化完成的bean实例</li><li>singletonFactories 三级缓存，用于保存bean创建工厂，以便后面有机会创建代理对象</li></ul></li><li>实例化过程 <ul><li>A实例化并把A的ObjectFactory加入第三级缓存 <ul><li>A填充属性需要注入B -&gt; B实例化并把B的ObjectFactory加入第三级缓存</li><li>B填充属性需要注入A -&gt; 从第三级缓存移除A对象，A代理对象加入第二级缓存（此时A还是半成品，B注入的是A代理对象）</li><li>B属性注入完成，创建B代理对象（此时B是完成品） -&gt; 从第三级缓存移除B对象，B代理对象加入第一级缓存</li><li>A填充属性注入B代理对象，从第二级缓存移除A代理对象，A代理对象加入第一级缓存</li></ul></li></ul></li><li>如果没有AOP的话确实可以两级缓存就可以解决循环依赖的问题，如果加上AOP，两级缓存是无法解决的，不可能每次执行singleFactory.getObject()方法都给我产生一个新的代理对象，所以还要借助另外一个缓存来保存产生的代理对象</li></ul><h1 id="_7-autowired-的实现原理" tabindex="-1"><a class="header-anchor" href="#_7-autowired-的实现原理"><span>7. @Autowired 的实现原理？</span></a></h1><ul><li>在Bean的初始化阶段，会通过Bean后置处理器来进行前置和后置的处理。@Autowired功能是通过后置处理器<br> AutowiredAnnotationBeanPostProcessor来完成的</li><li>Spring在创建bean的过程中，最终会调用到doCreateBean()方法，在doCreateBean()方法中会调用populateBean()方法，来为bean进行属性填充，完成自动装配等工作。</li><li>在populateBean()方法中一共调用了两次后置处理器，第一次是为了判断是否需要属性填充，如果不需要进行属性填充，那么就会直接进行return，如果需要进行属性填充，那么方法就会继续向下执行，后面会进行第二次后置处理器的调用，这个时候，就会调用到AutowiredAnnotationBeanPostProcessor的postProcessPropertyValues()方法，在该方法中就会进行@Autowired注解的解析，然后实现自动装配</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>//属性赋值
protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
          //…………
          if (hasInstAwareBpps) {
              if (pvs == null) {
                  pvs = mbd.getPropertyValues();
              }

              PropertyValues pvsToUse;
              for(Iterator var9 = this.getBeanPostProcessorCache().instantiationAware.iterator(); var9.hasNext(); pvs = pvsToUse) {
                  InstantiationAwareBeanPostProcessor bp = (InstantiationAwareBeanPostProcessor)var9.next();
                  pvsToUse = bp.postProcessProperties((PropertyValues)pvs, bw.getWrappedInstance(), beanName);
                  if (pvsToUse == null) {
                      if (filteredPds == null) {
                          filteredPds = this.filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
                      }
                      //执行后处理器，填充属性，完成自动装配
                      //调用InstantiationAwareBeanPostProcessor的postProcessPropertyValues()方法
                      pvsToUse = bp.postProcessPropertyValues((PropertyValues)pvs, filteredPds, bw.getWrappedInstance(), beanName);
                      if (pvsToUse == null) {
                          return;
                      }
                  }
              }
          }
         //…………
  }

//先调用 findAutowiringMetadata()方法解析出 bean 中带有@Autowired 注解、@Inject 和@Value 注解的属性和方法。然后调用 metadata.inject()方法，进行属性填充。
  public PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
      //@Autowired注解、@Inject和@Value注解的属性和方法
      InjectionMetadata metadata = this.findAutowiringMetadata(beanName, bean.getClass(), pvs);

      try {
          //属性填充
          metadata.inject(bean, beanName, pvs);
          return pvs;
      } catch (BeanCreationException var6) {
          throw var6;
      } catch (Throwable var7) {
          throw new BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;, var7);
      }
  }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_19-spring的aop以及实现方式-通知类型" tabindex="-1"><a class="header-anchor" href="#_19-spring的aop以及实现方式-通知类型"><span>19. spring的AOP以及实现方式,通知类型</span></a></h1><ul><li>AOP(Aspect-Oriented Programming)，面向切面编程:通过动态代理将通知织入目标对象.把一些业务逻辑中的相同代码抽取到一个独立的模块中，提高代码的可重用性。</li><li>实现方式 <ul><li>动态代理(优先):基于接口，被代理对象必须要实现接口,才能产生代理对象.</li><li>cglib代理：基于继承，对目标对象进行继承代理.目标对象不被final修饰。通过ASM读取目标类的字节码，然后修改字节码生成新的类</li></ul></li><li>应用：用于增强方法，权限认证、日志、事务、参数校验</li><li>常用术语 <ul><li>Joinpoint(连接点)：目标对象中，被拦截到的方法</li><li>Poincut(切入点)：目标对象，已经增强的方法。pointcut 的作用就是提供一组规则(使用 AspectJ pointcut expression language 来描述) 来匹配joinpoint, 给满足规则的 joinpoint 添加 Advice</li><li>Advice(通知/增强)：指拦截到连接点之后要执行的增强代码 <ul><li>前置通知（Before advice）：在某连接点（JoinPoint）之前执行的通知，但这个通知不能阻止连接点前的执行。ApplicationContext 中在 &lt; aop:aspect &gt; 里面使用 &lt; aop:before &gt; 元素进行声明；</li><li>后置通知（After advice）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。ApplicationContext 中在 &lt; aop:aspect &gt; 里面使用 &lt; aop:after &gt; 元素进行声明。</li><li>返回后通知（After return advice ：在某连接点正常完成后执行的通知，不包括抛出异常的情况。ApplicationContext 中在 &lt; aop:aspect &gt; 里面使用 &lt;&lt; after-returning &gt;&gt; 元素进行声明。</li><li>环绕通知（Around advice）：在 join point 前和 joint point 退出后都执行的 advice。ApplicationContext 中在 &lt; aop:aspect &gt; 里面使用 &lt; aop:around &gt; 元素进行声明。</li><li>抛出异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。ApplicationContext 中在 &lt; aop:aspect &gt; 里面使用 &lt; aop:after-throwing &gt; 元素进行声明。</li></ul></li><li>Target(目标对象)：被代理的对象</li><li>Weaving(织入)：将 aspect 和其他对象连接起来, 并创建 adviced object 的过程.</li><li>Proxy(代理)：将通知织入到目标对象之后，形成代理对象 Advice + Target Object = Advised Object = Proxy 。</li><li>aspect(切面)：切入点+通知 可以简单地认为, 使用 @Aspect 注解的类就是切面。</li></ul></li></ul><h1 id="_22-spring事务配置-处理方式" tabindex="-1"><a class="header-anchor" href="#_22-spring事务配置-处理方式"><span>22. spring事务配置，处理方式？</span></a></h1><ul><li>声明式事务：基于AOP，通过使用注解@Transactional或基于XML的配置事务，从而事务管理与业务代码分离。但无法用到代码块级别</li><li>编程式事务：通过TransactionTemplate和PlatformTransactionManager编码的方式实现事务管理，需要在代码中显式的调用事务的获得、提交、回滚。灵活性高，但维护困难</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public class AccountService {
    private TransactionTemplate transactionTemplate;

    public void setTransactionTemplate(TransactionTemplate transactionTemplate) {
        this.transactionTemplate = transactionTemplate;
    }

    public void transfer(final String out, final String in, final Double money) {
        transactionTemplate.execute(new TransactionCallbackWithoutResult() {
            @Override
            protected void doInTransactionWithoutResult(TransactionStatus status) {
                // 转出
                accountDao.outMoney(out, money);
                // 转入
                accountDao.inMoney(in, money);
            }
        });
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="_24-spring-的事务隔离级别" tabindex="-1"><a class="header-anchor" href="#_24-spring-的事务隔离级别"><span>24. Spring 的事务隔离级别？</span></a></h1><ul><li>Spring的接口TransactionDefinition中定义了表示隔离级别的常量，当然其实主要还是对应数据库的事务隔离级别：</li><li>ISOLATION_DEFAULT：使用后端数据库默认的隔离界别，MySQL 默认可重复读，Oracle 默认读已提交。</li><li>ISOLATION_READ_UNCOMMITTED：读未提交</li><li>ISOLATION_READ_COMMITTED：读已提交</li><li>ISOLATION_REPEATABLE_READ：可重复读</li><li>ISOLATION_SERIALIZABLE：串行化</li></ul><h1 id="_27-事务传播行为-有什么用-√" tabindex="-1"><a class="header-anchor" href="#_27-事务传播行为-有什么用-√"><span>27. 事务传播行为？有什么用？√</span></a></h1><ul><li>事务的传播行为propagation（service方法调用另外一个service方法的时候，仅限于不同类方法间相互调用）</li><li>事务的传播机制是指在一个事务中，对于多个事务性操作之间的关系和协调的处理方式。它决定了在一个事务方法中调用其他事务方法时，事务的范围和属性等。</li><li>支持当前事务 <ul><li>PROPAGATION_REQUIRED如果当前存在事务，则使用该事务。如果当前没有事务，就新建一个(默认)！！！</li><li>PROPAGATION_SUPPORTS如果当前存在事务，则使用该事务。如果当前没有事务，就不使用事务</li><li>PROPAGATION_MANDATORY如果当前存在事务，则使用该事务。如果当前没有事务，抛出异常</li></ul></li><li>不支持当前事务的情况 <ul><li>PROPAGATION_REQUIRES_NEW创建一个新的事务，如果有事务存在，挂起当前事务，</li><li>PROPAGATION_NOT_SUPPORTED以非事务方式运行，如果有事务存在，挂起当前事务</li><li>PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常</li><li>PROPAGATION_NESTED如果当前事务存在，则创建一个事务作为当前事务的嵌套事务来运行，如果当前没有事务，则等价PROPAGATION_REQUIRED</li><li>以 PROPAGATION_NESTED 启动的事务内嵌于外部事务中（如果存在外部事务的话），此时，内嵌事务并不是一个独立的事务，它依赖于外部事务的存在，只有通过外部的事务提交，才能引起内部事务的提交，嵌套的子事务不能单独提交。其实嵌套的子事务就是保存点的一个应用，一个事务中可以包括多个保存点，每一个嵌套子事务。另外，外部事务的回滚也会导致嵌套子事务的回滚。</li></ul></li><li>事务传播机制是使用 ThreadLocal 实现的，所以，如果调用的方法是在新线程中的，事务传播会失效。</li><li>在 Spring 中，只有通过 Spring 容器的 AOP 代理调用的公开方法（public method）上的@Transactional注解才会生效。Spring 默认使用基于 JDK 的动态代理（当接口存在时）或基于 CGLIB 的代理（当只有类时）来实现事务。这两种代理机制都只能代理公开的方法。</li></ul><h1 id="_28-声明式事务实现原理了解吗" tabindex="-1"><a class="header-anchor" href="#_28-声明式事务实现原理了解吗"><span>28. 声明式事务实现原理了解吗？</span></a></h1><ul><li>Spring的声明式事务管理是通过AOP（面向切面编程）和代理机制实现的。</li><li>第一步，在Bean初始化阶段创建代理对象： <ul><li>Spring容器在初始化单例Bean的时候，会遍历所有的BeanPostProcessor实现类，并执行其postProcessAfterInitialization方法。</li><li>在执行postProcessAfterInitialization方法时会遍历容器中所有的切面，查找与当前Bean匹配的切面，这里会获取事务的属性切面，也就是@Transactional注解及其属性值。</li><li>然后根据得到的切面创建一个代理对象，默认使用JDK动态代理创建代理，如果目标类是接口，则使用JDK动态代理，否则使用Cglib。</li></ul></li><li>第二步，在执行目标方法时进行事务增强操作： <ul><li>当通过代理对象调用Bean方法的时候，会触发对应的AOP增强拦截器，声明式事务是一种环绕增强，对应接口为MethodInterceptor，事务增强对该接口的实现为TransactionInterceptor</li><li>事务拦截器TransactionInterceptor在invoke方法中，通过调用父类TransactionAspectSupport的invokeWithinTransaction方法进行事务处理，包括开启事务、事务提交、异常回滚等。</li></ul></li></ul><h1 id="_29-声明式事务在哪些情况下会失效" tabindex="-1"><a class="header-anchor" href="#_29-声明式事务在哪些情况下会失效"><span>29. 声明式事务在哪些情况下会失效？</span></a></h1><ul><li>@Transactional应用在非public修饰的方法上。因为在SpringAOP代理时，TransactionInterceptor（事务拦截器）在目标方法执行前后进行拦截，DynamicAdvisedInterceptor（CglibAopProxy的内部类）的intercept方法或JdkDynamicAopProxy的invoke方法会间接调用AbstractFallbackTransactionAttributeSource的computeTransactionAttribute方法，获取Transactional注解的事务配置信息。</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>protectedTransactionAttributecomputeTransactionAttribute(Methodmethod,Class&lt;?&gt;targetClass){
  //Don&#39;tallowno-publicmethodsasrequired.
  if(allowPublicMethodsOnly()&amp;&amp;!Modifier.isPublic(method.getModifiers())){
    return null;
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>@Transactional注解属性propagation设置错误 <ul><li>TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行；错误使用场景：在业务逻辑必须运行在事务环境下以确保数据一致性的情况下使用SUPPORTS。</li><li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：总是以非事务方式执行，如果当前存在事务，则挂起该事务。错误使用场景：在需要事务支持的操作中使用NOT_SUPPORTED。</li><li>TransactionDefinition.PROPAGATION_NEVER：总是以非事务方式执行，如果当前存在事务，则抛出异常。错误使用场景：在应该在事务环境下执行的操作中使用NEVER。</li></ul></li><li>@Transactional注解属性rollbackFor设置错误 <ul><li>rollbackFor用来指定能够触发事务回滚的异常类型。Spring默认抛出未检查unchecked异常（继承自RuntimeException的异常）或者Error才回滚事务，其他异常不会触发回滚事务。</li></ul></li><li>同一个类中方法调用，导致@Transactional失效 <ul><li>由SpringAOP代理造成的，因为只有事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。</li></ul></li></ul><h1 id="_9-spring注册bean的几种方式" tabindex="-1"><a class="header-anchor" href="#_9-spring注册bean的几种方式"><span>9. spring注册bean的几种方式</span></a></h1><ul><li>直接编码</li><li>配置文件 xml的bean标签</li><li>注解 <ul><li>@Component、@Service、@Controller</li><li>@Bean</li></ul></li><li>java config</li></ul><h1 id="_10-spring中的-required、-autowired、-qualifier注解的作用" tabindex="-1"><a class="header-anchor" href="#_10-spring中的-required、-autowired、-qualifier注解的作用"><span>10. spring中的@Required、@Autowired、@Qualifier注解的作用？</span></a></h1><ul><li>@Required注解，应用于Bean属性setter方法。表示属性必须注入否则抛出 BeanInitializationException 异常。</li><li>@Autowired用于在setter方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 Bean</li><li>@Qualifier指定id自动装配哪个bean</li></ul><h1 id="_11-解释什么叫延迟加载" tabindex="-1"><a class="header-anchor" href="#_11-解释什么叫延迟加载"><span>11. 解释什么叫延迟加载？</span></a></h1><ul><li>容器启动之后默认会创建所有作用域为单例的Bean，但是有的业务场景不需要提前创建。此时设置lazy-init=&quot;true&quot;。容器启动之后不会默认创建作用域为单例的Bean，而是在获得该Bean时才创建</li></ul><h1 id="_20-java热部署" tabindex="-1"><a class="header-anchor" href="#_20-java热部署"><span>20. java热部署</span></a></h1><ul><li>spring-boot-devtools、Spring Loaded实现原理，nio的WatchService监听文件夹变化，同时实现classLoader的findclass方法重新将class加载进内存</li></ul><h1 id="_21-spring容器创建过程" tabindex="-1"><a class="header-anchor" href="#_21-spring容器创建过程"><span>21. Spring容器创建过程</span></a></h1><p>AbstractApplicationContext调用refresh()方法通过调用obtainFreshBeanFactory()方法创建Bean工厂AnnotatedBeanDefinitionReader扫描注解doScan方法和XmlBeanDefinitionReader的doLoadBeanDefinitions方法sax方式解析xml将其封装成document对象，使用BeanDefinitionReaderUtils.registerBeanDefinition并注册到BeanDefinitionRegistry缓存中<br> 然后调用postProcessBeanFactory调用子类的BeanFactory的后置处理器，然后调用invokeBeanFactoryPostProcessors()执行后置处理器<br> 第三注册BeanPostProcessors()到BeanFactory中<br> 第四注册监听器<br> 第五实例化所有的Bean放到singletonObjects单例池里面</p><h1 id="_23-transactional-注解有哪些属性-如何使用" tabindex="-1"><a class="header-anchor" href="#_23-transactional-注解有哪些属性-如何使用"><span>23. @Transactional 注解有哪些属性？如何使用？</span></a></h1><ul><li>属性：propagation事务传播行为，isolation事务隔离级别、rollbackFor导致事务回滚的异常类数组、timeout事务超时回滚、readonly读写或只读事务</li><li>@Transactional 可用在接口、接口方法、类、类方法上。只被应用到 public 方法上，方法级别注解覆盖类级别的注解。</li></ul><h1 id="_25-spring-事务如何和不同的数据持久层框架-spring-jdbc、hibernate、spring-jpa、mybatis-做集成" tabindex="-1"><a class="header-anchor" href="#_25-spring-事务如何和不同的数据持久层框架-spring-jdbc、hibernate、spring-jpa、mybatis-做集成"><span>25. Spring 事务如何和不同的数据持久层框架(Spring JDBC、Hibernate、Spring JPA、MyBatis)做集成？</span></a></h1><ul><li>Spring通过org.springframework.transaction.PlatformTransactionManager进行事务管理管理</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>public interface PlatformTransactionManager {
  // 根据事务定义 TransactionDefinition ，获得 TransactionStatus 。 
  //为什么不是创建事务呢？因为如果当前如果已经有事务，则不会进行创建，一般来说会跟当前线程进行绑定。
  //为什么返回TransactionStatus对象？因为TransactionStatus 中包含事务属性和事务的其它信息，例如是否只读、是否为新创建的事务等等
  TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException;
  //为什么根据 TransactionStatus 情况，进行提交？例如说，带@Transactional注解的A方法，会调用 @Transactional 注解的B方法
  //在B方法结束调用后，会执行PlatformTransactionManager#commit(TransactionStatus status) 方法，此处事务是不能、也不会提交的
  //而是在A方法结束调用后，执行PlatformTransactionManager#commit(TransactionStatus status) 方法，提交事务
  void commit(TransactionStatus status) throws TransactionException;
  // 为什么根据 TransactionStatus 情况，进行回滚？原因同上
  void rollback(TransactionStatus status) throws TransactionException;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>不同的数据持久层框架，会有其对应的PlatformTransactionManager实现类，都基于AbstractPlatformTransactionManager这个骨架类。 <ul><li>HibernateTransactionManager，和Hibernate5事务管理做集成。</li><li>DataSourceTransactionManager，和JDBC事务管理做集成。也适用于MyBatis、Spring JDBC等等</li><li>JpaTransactionManager，和JPA事务管理做集成。</li></ul></li></ul><h1 id="_26-为什么在spring事务中不能切换数据源" tabindex="-1"><a class="header-anchor" href="#_26-为什么在spring事务中不能切换数据源"><span>26. 为什么在Spring事务中不能切换数据源？</span></a></h1><ul><li>在Spring的事务管理中，数据库连接会和当前线程所绑定，即使设置了另外一个数据源，使用的还是当前的数据源连接。</li><li>而且多个数据源且需要事务的场景会带来多事务一致性的问题</li><li>推荐除非了读写分离所带来的多数据源，其它情况下，建议只有一个数据源</li></ul><h1 id="_30-拦截器与过滤器区别√" tabindex="-1"><a class="header-anchor" href="#_30-拦截器与过滤器区别√"><span>30. 拦截器与过滤器区别√</span></a></h1><ul><li>拦截器是基于java的反射机制的，而过滤器是基于函数回调。</li><li>拦截器不依赖与servlet容器，过滤器依赖servlet容器。</li><li>拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。</li><li>拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。</li><li>在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。</li><li>拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。</li></ul><h1 id="_31-spring区分环境" tabindex="-1"><a class="header-anchor" href="#_31-spring区分环境"><span>31. spring区分环境</span></a></h1><ul><li>spring.profiles.active=dev----application-dev.properties</li></ul>`,48);function T(_,S){const n=r("bean");return s(),o("div",null,[d,i("ul",null,[p,u,i("li",null,[e("初始化 "),i("ul",null,[v,g,b,i("li",null,[e("如果Bean指定init方法（例如 "),a(n),e(" 的 init-method 属性），那么将调用该方法。")]),m])]),i("li",null,[e("销毁： "),i("ul",null,[h,A,i("li",null,[e("如果bean指定destroy方法（例如 "),a(n),e(" 的 destroy-method 属性），那么将调用该方法。"),P,B])])])]),f])}const O=t(c,[["render",T],["__file","spring.html.vue"]]),q=JSON.parse('{"path":"/interview/spring.html","title":"spring","lang":"zh-CN","frontmatter":{"title":"spring","date":"2023-01-01T00:00:00.000Z","tags":"java","categories":"面试","description":"1. Spring是什么？特性？ Spring是一个轻量级、非入侵式的控制反转(IoC)和面向切面(AOP)的框架。 IoC和DI的支持:管理对象生命周期和依赖关系 AOP编程的支持：面向切面编程可以实现对程序进行权限拦截、运行监控等切面功能。 声明式事务的支持：支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式。 快捷测试的支持：支持Juni...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/interview/spring.html"}],["meta",{"property":"og:site_name","content":"JavaGuide"}],["meta",{"property":"og:title","content":"spring"}],["meta",{"property":"og:description","content":"1. Spring是什么？特性？ Spring是一个轻量级、非入侵式的控制反转(IoC)和面向切面(AOP)的框架。 IoC和DI的支持:管理对象生命周期和依赖关系 AOP编程的支持：面向切面编程可以实现对程序进行权限拦截、运行监控等切面功能。 声明式事务的支持：支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式。 快捷测试的支持：支持Juni..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://290ff162.telegraph-image-eg9.pages.dev/file/9d7d1e010e6a298683def.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-07T01:56:33.000Z"}],["meta",{"property":"article:author","content":"HeChuangJun"}],["meta",{"property":"article:published_time","content":"2023-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-07T01:56:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"spring\\",\\"image\\":[\\"https://290ff162.telegraph-image-eg9.pages.dev/file/9d7d1e010e6a298683def.jpg\\"],\\"datePublished\\":\\"2023-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-07T01:56:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeChuangJun\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[],"git":{"createdTime":1733536593000,"updatedTime":1733536593000,"contributors":[{"name":"HeChuangJun","email":"1105128664@qq.com","commits":1}]},"readingTime":{"minutes":22.47,"words":6741},"filePathRelative":"interview/spring.md","localizedDate":"2023年1月1日","excerpt":"\\n<ul>\\n<li>Spring是一个轻量级、非入侵式的控制反转(IoC)和面向切面(AOP)的框架。</li>\\n<li>IoC和DI的支持:管理对象生命周期和依赖关系</li>\\n<li>AOP编程的支持：面向切面编程可以实现对程序进行权限拦截、运行监控等切面功能。</li>\\n<li>声明式事务的支持：支持通过配置就来完成对事务的管理，而不需要通过硬编码的方式。</li>\\n<li>快捷测试的支持：支持Junit注解测试Spring程序。</li>\\n<li>快速集成功能：方便集成各种优秀框架</li>\\n<li>复杂API模板封装：对JDBC、JavaMail等提供了模板化的封装，降低应用难度</li>\\n</ul>","autoDesc":true}');export{O as comp,q as data};
