import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e as t}from"./app-7KT7HDzT.js";const p={},e=t(`<h2 id="分库分表-为什么分库、分表-问题及解决-实现方式-中间件选择" tabindex="-1"><a class="header-anchor" href="#分库分表-为什么分库、分表-问题及解决-实现方式-中间件选择"><span>分库分表？为什么分库、分表？问题及解决？实现方式？中间件选择？</span></a></h2><p>解决单一数据库和数据表在高并发和大数据量场景下的性能瓶颈问题。</p><p>单库性能瓶颈，磁盘容量不足，并发连接数不足<br> 单表查询效率低，大量并发避免表锁竞争</p><p>分库<br> 跨库事务问题：分布式事务<br> 跨库无法JOIN问题：<br> 分多次查询，业务代码中关联<br> 字段冗余。避免关联操作。<br> 通过binlog同步到ES中查询。<br> 每个库中都保存所有模块都依赖到的全局表<br> 借助ETL工具定时将关联表表做数据同步到聚合表</p><p>分表<br> 跨节点的count，order by，group by等聚合函数问题：分多次查询，业务代码中聚合<br> 数据迁移，容量规划，是否再次扩容等问题：<br> ID问题：<br> 自增设置不同步长。比如3张表，步长为3，3张表的ID增长是1、4、7；2、5、8；3、6、9，不重复<br> UUID，简单，但不连续的主键插入导致页分裂，性能差<br> 分布式ID<br> 分页问题<br> 全局视野法：分多次查询，业务代码中分页。数据比较准确；缺点是并发度低，查询慢<br> 业务折衷法：禁止跳页查询，只有上一页和下一页，查询第一页时跟全局视野法一样。下一页则每个节点都查询大于上一页最大创建时间或者id的数据然后汇总，内存排序返回</p><p>Client模式、Proxy 模式</p><p><strong>Sharding-JDBC</strong>：当当开源 client模式<br> cobar：阿里 Proxy方式 必须将拆分后的表分别放入不同的库<br><strong>MyCat</strong>：开源 Proxy模式<br> TDDL（淘宝）：Client模式<br> vitess：谷歌 集群基于Zookeeper管理，通过RPC方式处理数据，可支撑高流量<br><strong>Sharding Sphere</strong>推荐，提供三种模式<br> Sharding-JDBC Client模式，不用部署，运维成本低，不需要代理层的二次转发请求，性能高，但是需要各个系统都重新升级版本再发布，都要耦合sharding-jdbc的依赖<br> Sharding-Proxy Proxy模式，跨语言<br> Sharding-Sidecar模式</p><h2 id="垂直分库-表-、水平分库-表-区别-怎么分库分表-√如何选择分表键-分表策略-水平分表的路由方式-非分表键如何查询-查询条件不带分片键怎么办-如何避免热点问题数据倾斜" tabindex="-1"><a class="header-anchor" href="#垂直分库-表-、水平分库-表-区别-怎么分库分表-√如何选择分表键-分表策略-水平分表的路由方式-非分表键如何查询-查询条件不带分片键怎么办-如何避免热点问题数据倾斜"><span>垂直分库（表）、水平分库（表）区别？怎么分库分表？√如何选择分表键？分表策略？水平分表的路由方式？非分表键如何查询/查询条件不带分片键怎么办？如何避免热点问题数据倾斜？</span></a></h2><p>水平分库（表）：以字段为依据，按照一定策略（hash、range等），将一个库（表）中的数据拆分到多个库（表）中。每个库（表）的结构都一样，数据不一样，没有交集 id 1-1000<br> 垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。每个库的表结构、数据都不一样，没有交集。按照用户、商品、订单分到不同的库中。<br> 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。每个表的结构、数据都不一样，每个表的字段至少有一列交集（主键）用于关联数据</p><p>主键ID：用户表<br> 时间戳create_time：日志、订单表</p><p>路由：数据应该分到哪一张表。<br> 根据范围：根据分片键的取值范围划分。同一年或者1-1000<br> 优点：扩容简单。只需增加新表，不修改原数据<br> 缺点：分段太小导致表数量多维护难；太大导致单表依然存在性能问题，建议100-2000w；数据分布不均匀（表数量大小不一）和热点问题（高频查询数量大的表）<br> 使用范围+hash哈希取模结合的分表策略解决，分库用范围，比如id在0~4000、4000~8000万分到订单库1和2，扩容时id在8000万~1.2亿的数据分到订单库3。然后订单库内用hash取模划分不同表</p><p>根据Hash取模：选取某个列或者某几个列组合的值进行Hash运算后对数据库数取余分到不同数据库表<br> 表数量多维护难，太少导致单表依然存在性能问题<br> 优点：表分布均匀，不存在明显热点问题。<br> 缺点：规划不好要扩容迁移需要二次分表，表数量增加导致重新计算位置并移动数据</p><p>一致性Hash：解决了扩容迁移需要二次分表问题<br> 将哈希值空间组织成环，节点映射到环上。数据项映射到顺时针的第一个节点上。扩缩容只影响哈希环中相邻节点，减少数据迁移。但节点分布不均匀和节点故障数据迁移导致负载不均匀<br> Guava //bucket范围在0 ~ buckets之间int bucket = Hashing.consistentHash(id, buckets)</p><details><summary>demo</summary><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token comment">//真实节点</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> serverIpArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">&quot;192.168.1.100&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;47.100.61.70&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//虚拟节点</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> virtualNodeMap<span class="token punctuation">;</span>
 
    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        virtualNodeMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//默认为每个真实节点生成3个虚拟节点</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> realIp <span class="token operator">:</span> serverIpArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//加上随机数使得虚拟节点的hash值更加分散，实际情况中，虚拟节点的hash值需要固定</span>
                <span class="token class-name">String</span> virtualIp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;#&quot;</span> <span class="token operator">+</span> realIp<span class="token punctuation">;</span>
                virtualNodeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token function">getHash</span><span class="token punctuation">(</span>virtualIp<span class="token punctuation">)</span><span class="token punctuation">,</span> realIp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">//获取ip的哈希值,可以有多种算法实现</span>
    <span class="token comment">//尽量避免ip相近,hash相近的情况</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getHash</span><span class="token punctuation">(</span><span class="token class-name">String</span> ip<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> hashCode <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>ip<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>ip <span class="token operator">+</span> <span class="token string">&quot;:&quot;</span> <span class="token operator">+</span> hashCode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> hashCode<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">//由客户端获取最近的虚拟节点，返回虚拟节点对应的真实节点</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">getRealServerIp</span><span class="token punctuation">(</span><span class="token class-name">String</span> client<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> clientHash <span class="token operator">=</span> <span class="token function">getHash</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> higherKey <span class="token operator">=</span> virtualNodeMap<span class="token punctuation">.</span><span class="token function">higherKey</span><span class="token punctuation">(</span>clientHash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>higherKey <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//返回hash环中的第一个虚拟ip</span>
            <span class="token keyword">return</span> virtualNodeMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>virtualNodeMap<span class="token punctuation">.</span><span class="token function">firstKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//返回比客户端的哈希值稍微大一点的虚拟ip</span>
        <span class="token keyword">return</span> virtualNodeMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>higherKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> clientIpArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token string">&quot;电脑&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;平板&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;手机&quot;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> client <span class="token operator">:</span> clientIpArray<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> realIp <span class="token operator">=</span> <span class="token function">getRealServerIp</span><span class="token punctuation">(</span>client<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>client <span class="token operator">+</span> <span class="token string">&quot;连接到了&quot;</span> <span class="token operator">+</span> realIp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></details><p>假设用户表根据userId做分表。但是用户根据手机号来登陆，而手机号是非分表键。<br> 将用户信息冗余同步到ES查询（推荐）<br> 基因法：非分表键解析出分表键，如订单号包含客户号。手机号似乎不适合冗余userId。<br> 映射关系：创建映射表，只有分表键、非分表键两列字段。查询时先从映射表获得非分表键对应的分表键，然后再使用非分表键+分表键去查询对应的表。映射表可以改成缓存到Redis中</p><h2 id="如何迁移到分库分表-不停机扩容-怎么验数据一致性-评估分库数量" tabindex="-1"><a class="header-anchor" href="#如何迁移到分库分表-不停机扩容-怎么验数据一致性-评估分库数量"><span>如何迁移到分库分表？/不停机扩容？怎么验数据一致性？评估分库数量？</span></a></h2><p>停止部署法。凌晨停机，写迁移程序读旧数据库数据，通过中间件写入到分库分表中，结束后校验迁移前后一致性，没问题就迁移业务到新库</p><p>双写部署法，基于业务层/binlog<br> 根据主键或者创建时间大小将表数据区分为历史数据和增量数据<br> 读操作保持不变，将写操作写入到消息队列（新库）中和旧库中，<br> 写迁移程序(1.查出最大id 2.每次取id&gt;? and id &lt;?+step步长的数据写入到新库)将表历史数据迁移到新库<br> 写程序订阅消息队列/binlog中的数据通过中间件写入新库<br> 使用定时任务检查新老库数据一致性，把差异补齐<br> 没问题后读操作切换到新库<br> 没问题后去除双写代码，将写操作指向新库<br> 过段时间，确定旧库没有请求之后下线老库</p><p>先验数量，因为比较快。<br> 验关键性的几个字段是否一致。如一次取50条,然后拼在一起用md5进行加密得到新字符串。比较新库两个字符串值是否一致。一致则继续比较下50条数据。不一致则用二分法确定不一致的数据在0-25条，还是26条-50条。以此类推找出不一致的数据并记录</p><p>MySQL单库不超过5千万条。分4~10个库</p>`,20),o=[e];function c(i,l){return s(),a("div",null,o)}const k=n(p,[["render",c],["__file","databasesharding.html.vue"]]),d=JSON.parse('{"path":"/interview/distributed/databasesharding.html","title":"分库分表","lang":"zh-CN","frontmatter":{"title":"分库分表","date":"2023-01-01T00:00:00.000Z","tags":"面试","categories":"面试","description":"分库分表？为什么分库、分表？问题及解决？实现方式？中间件选择？ 解决单一数据库和数据表在高并发和大数据量场景下的性能瓶颈问题。 单库性能瓶颈，磁盘容量不足，并发连接数不足 单表查询效率低，大量并发避免表锁竞争 分库 跨库事务问题：分布式事务 跨库无法JOIN问题： 分多次查询，业务代码中关联 字段冗余。避免关联操作。 通过binlog同步到ES中查询。...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/interview/distributed/databasesharding.html"}],["meta",{"property":"og:site_name","content":"JavaGuide"}],["meta",{"property":"og:title","content":"分库分表"}],["meta",{"property":"og:description","content":"分库分表？为什么分库、分表？问题及解决？实现方式？中间件选择？ 解决单一数据库和数据表在高并发和大数据量场景下的性能瓶颈问题。 单库性能瓶颈，磁盘容量不足，并发连接数不足 单表查询效率低，大量并发避免表锁竞争 分库 跨库事务问题：分布式事务 跨库无法JOIN问题： 分多次查询，业务代码中关联 字段冗余。避免关联操作。 通过binlog同步到ES中查询。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"HeChuangJun"}],["meta",{"property":"article:published_time","content":"2023-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分库分表\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeChuangJun\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"分库分表？为什么分库、分表？问题及解决？实现方式？中间件选择？","slug":"分库分表-为什么分库、分表-问题及解决-实现方式-中间件选择","link":"#分库分表-为什么分库、分表-问题及解决-实现方式-中间件选择","children":[]},{"level":2,"title":"垂直分库（表）、水平分库（表）区别？怎么分库分表？√如何选择分表键？分表策略？水平分表的路由方式？非分表键如何查询/查询条件不带分片键怎么办？如何避免热点问题数据倾斜？","slug":"垂直分库-表-、水平分库-表-区别-怎么分库分表-√如何选择分表键-分表策略-水平分表的路由方式-非分表键如何查询-查询条件不带分片键怎么办-如何避免热点问题数据倾斜","link":"#垂直分库-表-、水平分库-表-区别-怎么分库分表-√如何选择分表键-分表策略-水平分表的路由方式-非分表键如何查询-查询条件不带分片键怎么办-如何避免热点问题数据倾斜","children":[]},{"level":2,"title":"如何迁移到分库分表？/不停机扩容？怎么验数据一致性？评估分库数量？","slug":"如何迁移到分库分表-不停机扩容-怎么验数据一致性-评估分库数量","link":"#如何迁移到分库分表-不停机扩容-怎么验数据一致性-评估分库数量","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":6.99,"words":2096},"filePathRelative":"interview/distributed/databasesharding.md","localizedDate":"2023年1月1日","excerpt":"<!-- more -->\\n<h2>分库分表？为什么分库、分表？问题及解决？实现方式？中间件选择？</h2>\\n<p>解决单一数据库和数据表在高并发和大数据量场景下的性能瓶颈问题。</p>\\n<p>单库性能瓶颈，磁盘容量不足，并发连接数不足<br>\\n单表查询效率低，大量并发避免表锁竞争</p>\\n<p>分库<br>\\n跨库事务问题：分布式事务<br>\\n跨库无法JOIN问题：<br>\\n分多次查询，业务代码中关联<br>\\n字段冗余。避免关联操作。<br>\\n通过binlog同步到ES中查询。<br>\\n每个库中都保存所有模块都依赖到的全局表<br>\\n借助ETL工具定时将关联表表做数据同步到聚合表</p>\\n<p>分表<br>\\n跨节点的count，order by，group by等聚合函数问题：分多次查询，业务代码中聚合<br>\\n数据迁移，容量规划，是否再次扩容等问题：<br>\\nID问题：<br>\\n自增设置不同步长。比如3张表，步长为3，3张表的ID增长是1、4、7；2、5、8；3、6、9，不重复<br>\\nUUID，简单，但不连续的主键插入导致页分裂，性能差<br>\\n分布式ID<br>\\n分页问题<br>\\n全局视野法：分多次查询，业务代码中分页。数据比较准确；缺点是并发度低，查询慢<br>\\n业务折衷法：禁止跳页查询，只有上一页和下一页，查询第一页时跟全局视野法一样。下一页则每个节点都查询大于上一页最大创建时间或者id的数据然后汇总，内存排序返回</p>","autoDesc":true}');export{k as comp,d as data};
