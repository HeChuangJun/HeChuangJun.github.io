import{_ as r}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as o,o as s,c,a as e,d as t,w as l,b as a,e as n}from"./app-7KT7HDzT.js";const u={},p=n('<h1 id="_1-什么是消息队列" tabindex="-1"><a class="header-anchor" href="#_1-什么是消息队列"><span>1. 什么是消息队列？</span></a></h1><ul><li>mq：消息队列是一种先进先出的数据结构.</li></ul><h1 id="_2-为什么使用消息队列-消息队列优缺点" tabindex="-1"><a class="header-anchor" href="#_2-为什么使用消息队列-消息队列优缺点"><span>2. 为什么使用消息队列？消息队列优缺点？</span></a></h1><ul><li>解耦：假设A系统要发送数据到B,C,D系统，如果E系统需要数据然后，D系统不需要了，此时A系统需要维护下游系统的调用，耦合性太高，引入消息队列后可以减少A系统维护成本</li><li>异步：同步很花费并且业务时效性不大的操作，可以使用异步来提升效果，比如发送微信通知</li><li>削峰、限流：解决高并发情况</li><li>系统可用性降低</li><li>系统复杂度提高</li><li>一致性问题</li></ul><h1 id="_3-消息队列协议" tabindex="-1"><a class="header-anchor" href="#_3-消息队列协议"><span>3. 消息队列协议</span></a></h1><ul><li>AMQP、MQTT、STOMP、XMPP协议</li></ul><h1 id="_4-消息队列有几种消费语义" tabindex="-1"><a class="header-anchor" href="#_4-消息队列有几种消费语义"><span>4. 消息队列有几种消费语义？</span></a></h1><ul><li>消息至多被消费一次（At most once）：消息可能会丢失，但绝不重传。</li><li>消息至少被消费一次（At least once）：消息可以重传，但绝不丢失。</li><li>消息仅被消费一次（Exactly once）：每一条消息只被传递一次。</li></ul><h1 id="_5-kafka、activemq、rabbitmq、rocketmq-有什么优缺点" tabindex="-1"><a class="header-anchor" href="#_5-kafka、activemq、rabbitmq、rocketmq-有什么优缺点"><span>5. Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</span></a></h1><figure><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/523ea7439c3ef3a12016b.png" alt="mq.png" tabindex="0"><figcaption>mq.png</figcaption></figure><ul><li>中小型公司，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；大型公司，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li><li>如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li><li>RabbitMQ延时最低，消息可靠性高，高可用，但扩展性较差。</li></ul><h1 id="_6-如何保证消息的不被重复消费-幂等性" tabindex="-1"><a class="header-anchor" href="#_6-如何保证消息的不被重复消费-幂等性"><span>6. 如何保证消息的不被重复消费/幂等性？</span></a></h1><ul><li>框架层统一封装：由 Producer 生成唯一标识。使用关系型数据库，增加一个排重表，使用消息编号作为唯一主键。需要让插入记录和业务逻辑在同一个事务</li><li>业务层实现：先查询数据库，判断数据是否已经被更新过。如果是，则直接返回消费完成，否则执行消费。</li></ul><h1 id="_7-如何防止消息丢失-可靠性传输" tabindex="-1"><a class="header-anchor" href="#_7-如何防止消息丢失-可靠性传输"><span>7. 如何防止消息丢失/可靠性传输</span></a></h1>',14),m=e("h1",{id:"_8-如何保证消息的顺序性",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_8-如何保证消息的顺序性"},[e("span",null,"8. 如何保证消息的顺序性？")])],-1),d=e("h1",{id:"_9-如何保证消息队列的高可用",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_9-如何保证消息队列的高可用"},[e("span",null,"9. 如何保证消息队列的高可用？")])],-1),h=n('<h1 id="_10-消息积压如何解决" tabindex="-1"><a class="header-anchor" href="#_10-消息积压如何解决"><span>10. 消息积压如何解决</span></a></h1><ul><li>临时紧急扩容，具体操作步骤和思路如下： <ul><li>先修复consumer的问题，确保其恢复消费速度</li><li>新建一个topic，partition是原来的10倍，临时建立好原先10倍或者20倍的queue数量</li><li>然后写一个临时的分发数据的consumer程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的10倍数量的queue</li><li>接着临时征用10倍的机器来部署consumer，每一批consumer消费一个临时queue的数据</li><li>这种做法相当于是临时将queue资源和consumer资源扩大10倍，以正常的10倍速度来消费数据</li><li>等快速消费完积压数据之后，得恢复原先部署架构，重新用原先的consumer机器来消费消息</li></ul></li></ul><h1 id="_11-为什么kafka最高吞吐量" tabindex="-1"><a class="header-anchor" href="#_11-为什么kafka最高吞吐量"><span>11. 为什么kafka最高吞吐量</span></a></h1><ul><li>kafka采用顺序读写磁盘，写时分文件顺序写，读时按offset顺序读</li><li>Kafka利用了操作系统本身的Page Cache而不是JVM空间内存</li><li>Kafka 的生产和消费两个过程都使用了零拷贝（zero copy）： <ul><li>网络数据持久化到磁盘(Producer 到 Broker使用了mmap)</li><li>磁盘文件通过网络发送(Broker 到 Consumer使用了sendfile+DMA采集)</li></ul></li><li>数据压缩 <ul><li>Kafka使用了批量压缩，即将多个消息一起压缩而不是单个消息压缩。（如果每个消息都压缩，压缩率相对较低。）</li><li>Kafka允许使用递归的消息集合，批量的消息可通过压缩的形式传输并且在日志中也可保持压缩格式，直到被消费者解压缩</li><li>Kafka支持多种压缩协议，包括Gzip、Snappy、LZ4</li></ul></li><li>批量传输 <ul><li>在向Kafka发送数据时，可以启用批次发送，这样可以避免在网络上频繁传输单个消息带来的延迟和带宽开销。假设网络带宽为10MB/S，一次性传输10MB的消息比传输1KB的消息10000万次显然要快得多。</li></ul></li><li>并行 <ul><li>由于不同 Partition 可位于不同机器，因此可以充分利用集群优势，实现机器间的并行处理。</li><li>由于 Partition 在物理上对应一个文件夹，即使多个 Partition 位于同一个节点，也可通过配置让同一节点上的不同 Partition 置于不同的磁盘上，从而实现磁盘间的并行处理，充分发挥多磁盘的优势。</li></ul></li></ul>',4);function f(_,A){const i=o("RouteLink");return s(),c("div",null,[p,e("p",null,[t(i,{to:"/interview/rabbitmq.md/#2-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%EF%BC%9F%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%EF%BC%9F"},{default:l(()=>[a("rabbitmq如何防止消息丢失？可靠性传输？")]),_:1}),a("√")]),e("p",null,[t(i,{to:"/interview/rocketmq.md/#9-%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E6%B6%88%E6%81%AF%E4%B8%A2%E5%A4%B1%EF%BC%9F%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E8%BE%93%EF%BC%9F"},{default:l(()=>[a("rocketmq如何防止消息丢失？可靠性传输？")]),_:1})]),m,e("p",null,[t(i,{to:"/interview/rabbitmq.md/#3-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"},{default:l(()=>[a("rabbitmq顺序消息")]),_:1}),a("√")]),e("p",null,[t(i,{to:"/interview/rocketmq.md/#8-%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"},{default:l(()=>[a("rocketmq顺序消息")]),_:1})]),d,e("p",null,[t(i,{to:"/interview/rabbitmq.md/#4-%E9%AB%98%E5%8F%AF%E7%94%A8"},{default:l(()=>[a("rabbitmq高可用")]),_:1}),a("√")]),e("p",null,[t(i,{to:"/interview/rocketmq.md/#10-%E9%AB%98%E5%8F%AF%E7%94%A8"},{default:l(()=>[a("rocketmq高可用")]),_:1})]),h])}const b=r(u,[["render",f],["__file","messagequeue.html.vue"]]),B=JSON.parse('{"path":"/interview/messagequeue.html","title":"消息队列","lang":"zh-CN","frontmatter":{"title":"消息队列","date":"2023-01-01T00:00:00.000Z","tags":"面试","categories":"面试","description":"1. 什么是消息队列？ mq：消息队列是一种先进先出的数据结构. 2. 为什么使用消息队列？消息队列优缺点？ 解耦：假设A系统要发送数据到B,C,D系统，如果E系统需要数据然后，D系统不需要了，此时A系统需要维护下游系统的调用，耦合性太高，引入消息队列后可以减少A系统维护成本 异步：同步很花费并且业务时效性不大的操作，可以使用异步来提升效果，比如发送微...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/interview/messagequeue.html"}],["meta",{"property":"og:site_name","content":"JavaGuide"}],["meta",{"property":"og:title","content":"消息队列"}],["meta",{"property":"og:description","content":"1. 什么是消息队列？ mq：消息队列是一种先进先出的数据结构. 2. 为什么使用消息队列？消息队列优缺点？ 解耦：假设A系统要发送数据到B,C,D系统，如果E系统需要数据然后，D系统不需要了，此时A系统需要维护下游系统的调用，耦合性太高，引入消息队列后可以减少A系统维护成本 异步：同步很花费并且业务时效性不大的操作，可以使用异步来提升效果，比如发送微..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://290ff162.telegraph-image-eg9.pages.dev/file/523ea7439c3ef3a12016b.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-07T01:56:33.000Z"}],["meta",{"property":"article:author","content":"HeChuangJun"}],["meta",{"property":"article:published_time","content":"2023-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-07T01:56:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"消息队列\\",\\"image\\":[\\"https://290ff162.telegraph-image-eg9.pages.dev/file/523ea7439c3ef3a12016b.png\\"],\\"datePublished\\":\\"2023-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-07T01:56:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeChuangJun\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[],"git":{"createdTime":1733536593000,"updatedTime":1733536593000,"contributors":[{"name":"HeChuangJun","email":"1105128664@qq.com","commits":1}]},"readingTime":{"minutes":4.5,"words":1350},"filePathRelative":"interview/messagequeue.md","localizedDate":"2023年1月1日","excerpt":"<!-- TOC -->\\n<!-- /TOC -->\\n<h1>1. 什么是消息队列？</h1>\\n<ul>\\n<li>mq：消息队列是一种先进先出的数据结构.</li>\\n</ul>\\n<h1>2. 为什么使用消息队列？消息队列优缺点？</h1>\\n<ul>\\n<li>解耦：假设A系统要发送数据到B,C,D系统，如果E系统需要数据然后，D系统不需要了，此时A系统需要维护下游系统的调用，耦合性太高，引入消息队列后可以减少A系统维护成本</li>\\n<li>异步：同步很花费并且业务时效性不大的操作，可以使用异步来提升效果，比如发送微信通知</li>\\n<li>削峰、限流：解决高并发情况</li>\\n<li>系统可用性降低</li>\\n<li>系统复杂度提高</li>\\n<li>一致性问题</li>\\n</ul>","autoDesc":true}');export{b as comp,B as data};
