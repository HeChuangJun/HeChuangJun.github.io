import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as t,c as a,e as r}from"./app-7KT7HDzT.js";const o={},n=r('<h2 id="数据一致性算法-分类" tabindex="-1"><a class="header-anchor" href="#数据一致性算法-分类"><span>数据一致性算法？分类？</span></a></h2><p>确保多个节点之间的数据一致的机制或协议。</p><p>ZAB协议：Zookeeper中使用，通过选举一个leader来协调多个follower之间的数据更新。<br> 2PC协议：通过预提交和提交两个阶段来保证一致性<br> 3PC协议：在2PC协议的基础上增加超时机制和准备阶段的“可以提交”状态<br> Gossip协议：基于随机化，通过节点之间的随机通讯来传播数据和状态信息<br><img src="https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQcb84de943d8003674ea1176bfa23e30c.png" alt="type.png"></p><h2 id="paxos算法角色-工作流程-缺点-优化" tabindex="-1"><a class="header-anchor" href="#paxos算法角色-工作流程-缺点-优化"><span>Paxos算法角色？工作流程？缺点？优化？</span></a></h2><p>基于消息传递</p><p>节点能同时充当不同角色<br> Proposer提议者：提出Proposal提案=编号（唯一，递增）+value，表示为[M,V]<br> Accecptor接受者：投票提案，并接受达成共识的提案<br> Learner学习者：被告知投票的结果，接受达成共识的提案。</p><p>Basic Paxos算法（单提议者）流程<br> 准备阶段Prepare Phase<br> 提议者生成编号N（大于其先前提案的编号）的提案，向超过半数的（子集）接受者发送包含提案的prepare请求，接受者Accecptor会给与提议者：<br> 两个承诺：忽略提案号小于或等于N的Prepare请求；忽略提案号小于N的Accept请求<br> 一个应答：回复已经接受的最大提案号的提案的提案号Nmax和值Nvalue，如果值没有接受提案则返回空值<br> 接受阶段Accept Phase<br> 提议者收到半数以上的接受者对于它发出的编号为N的prepare请求的响应，然后给提案设置收到的响应中编号最大的提案的值value，如果响应中不包含任何提案则随机。提议者会向超过半数的（子集）接受者发出已经设置值编号为N的Accept请求<br> 如果N大于接受者之前返回承诺则接受者接受并向提议者和所有学习者发送Accepted消息，否则忽略<br> 当多个提议者发送冲突的Prepare请求，或者提议者没有接收到超过半数承诺或者Accepted消息，都会使提议者发起编号更大的提案;</p><p>有多个提议者互相竞争（即多个提案编号不断增大）时可能导致提案失败并反复重试，效率低下<br> Multi-Paxos算法在选出一个Leader领导者作为唯一的提议者解决<br><img src="https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQ38aa2945a06a8e67e4602a0551837e60.png" alt="paxos.png"></p><h2 id="raft算法角色-工作流程" tabindex="-1"><a class="header-anchor" href="#raft算法角色-工作流程"><span>Raft算法角色？工作流程？</span></a></h2><p>节点只能处于三种状态中的一种<br> Leader领导者：处理客户端请求并将数据复制到所有节点，管理集群状态。与Follower保持heartBeat<br> Follower跟随者：响应Leader日志同步请求、Candidate请求，把Client请求到Follower的事务转发给Leader<br> Candidate候选人：发起选举投票<br><img src="https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMw11167e156cb341ff4f514b73cc7b1c88.png" alt="raft.terms.png"></p><p>工作流程分为<br><strong>领导选举Leader election</strong><br> 每轮选举是一个Term任期（递增）只产生一个Leader，选举失败则没有Leader。节点的Term正常时一致<br> Term递增，开始新任期选举条件<br> 启动时<br> 任期内没有收到足够的投票选举出Leader<br> Leader当选后出现异常，然后其他Follower转为Candidate<br> Leader或Candidate发现Term比Follower小，将转为Follower<br> Follower的Term比别的Term小，更新Term保持一致</p><p>启动时所有节点状态为Follower，Term为1，都设置了随机的超时时间150-300ms。其中一个Follower的超时后没有收到Leader的hearbeat转换为Candidate发起Leader选举向其他节点发起Leader Request Vote请求。Term变2，当某节点收到的请求中Term比当前Term小时则拒绝。如果Candidate收到n/2+1个节点（过半数）的投票则转换为Leader开启任期Term并向其他节点发送heartBeat。避免其他节点认为没有Leader发起选举</p><p>分裂选举：一个任期内节点只能投票一次，所以多个Candidate会出现收到的投票数都不过半问题，但定时器的时间都是随机的，相同时间概率小，所以不会存在多次多个Candidate同时发起投票的问题</p><p><strong>日志复制Log Replication</strong>：Leader日志被复制到大多数节点后变为committed状态，应用到状态机并响应客户端。如果有异常会重试直到日志都复制到所有节点（日志连续，不能有失败引起的空洞）。每个日志条目中包含可执行的指令、任期号、位置index</p><p>日志特性：<br> 两个日志条目的index和term相同则指令相同<br> 不同的日志中有两个日志条目index和term相同，则之前的所有日志都相同</p><p><strong>安全性Safety</strong>：保证每个节点都执行相同序列的安全机制，Leader一定包含前几个任期committed Log的机制（当某个Follower在当前Leader commit Log时变得不可用，稍后可能被选举为Leader，可能会用新Log覆盖旧committed Log导致节点执行不同序列）当请求投票的该Candidate的Term较大或Term相同Index更大则投票，否则拒绝该请求，保证Leader日志完整性Leader Completeness</p>',16),c=[n];function p(d,i){return t(),a("div",null,c)}const m=e(o,[["render",p],["__file","dataconsistencyalgorithm.html.vue"]]),b=JSON.parse('{"path":"/interview/distributed/dataconsistencyalgorithm.html","title":"数据一致性算法","lang":"zh-CN","frontmatter":{"title":"数据一致性算法","date":"2023-01-01T00:00:00.000Z","tags":"面试","categories":"面试","description":"数据一致性算法？分类？ 确保多个节点之间的数据一致的机制或协议。 ZAB协议：Zookeeper中使用，通过选举一个leader来协调多个follower之间的数据更新。 2PC协议：通过预提交和提交两个阶段来保证一致性 3PC协议：在2PC协议的基础上增加超时机制和准备阶段的“可以提交”状态 Gossip协议：基于随机化，通过节点之间的随机通讯来传播...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/interview/distributed/dataconsistencyalgorithm.html"}],["meta",{"property":"og:site_name","content":"JavaGuide"}],["meta",{"property":"og:title","content":"数据一致性算法"}],["meta",{"property":"og:description","content":"数据一致性算法？分类？ 确保多个节点之间的数据一致的机制或协议。 ZAB协议：Zookeeper中使用，通过选举一个leader来协调多个follower之间的数据更新。 2PC协议：通过预提交和提交两个阶段来保证一致性 3PC协议：在2PC协议的基础上增加超时机制和准备阶段的“可以提交”状态 Gossip协议：基于随机化，通过节点之间的随机通讯来传播..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQcb84de943d8003674ea1176bfa23e30c.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"HeChuangJun"}],["meta",{"property":"article:published_time","content":"2023-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据一致性算法\\",\\"image\\":[\\"https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQcb84de943d8003674ea1176bfa23e30c.png\\",\\"https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQ38aa2945a06a8e67e4602a0551837e60.png\\",\\"https://b.bdstatic.com/comment/Y_bZHaS27NSYIAE9PqRzMw11167e156cb341ff4f514b73cc7b1c88.png\\"],\\"datePublished\\":\\"2023-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeChuangJun\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"数据一致性算法？分类？","slug":"数据一致性算法-分类","link":"#数据一致性算法-分类","children":[]},{"level":2,"title":"Paxos算法角色？工作流程？缺点？优化？","slug":"paxos算法角色-工作流程-缺点-优化","link":"#paxos算法角色-工作流程-缺点-优化","children":[]},{"level":2,"title":"Raft算法角色？工作流程？","slug":"raft算法角色-工作流程","link":"#raft算法角色-工作流程","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":4.48,"words":1343},"filePathRelative":"interview/distributed/dataconsistencyalgorithm.md","localizedDate":"2023年1月1日","excerpt":"<h2>数据一致性算法？分类？</h2>\\n<p>确保多个节点之间的数据一致的机制或协议。</p>\\n<p>ZAB协议：Zookeeper中使用，通过选举一个leader来协调多个follower之间的数据更新。<br>\\n2PC协议：通过预提交和提交两个阶段来保证一致性<br>\\n3PC协议：在2PC协议的基础上增加超时机制和准备阶段的“可以提交”状态<br>\\nGossip协议：基于随机化，通过节点之间的随机通讯来传播数据和状态信息<br>\\n<img src=\\"https://b.bdstatic.com/comment/I4MgmLj55Sgosm2EdtLMDQcb84de943d8003674ea1176bfa23e30c.png\\" alt=\\"type.png\\"></p>","autoDesc":true}');export{m as comp,b as data};
