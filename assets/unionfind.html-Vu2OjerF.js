import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as s,c as a,e as t}from"./app-7KT7HDzT.js";const e={},p=t(`<h2 id="并查集理论基础" tabindex="-1"><a class="header-anchor" href="#并查集理论基础"><span>并查集理论基础</span></a></h2><ul><li><p>并查集主要有两个功能：将两个元素添加到一个集合中。判断两个元素在不在同一个集合</p></li><li><p>思想：用一个一维数组表示三个元素A，B，C （分别是数字）在同一个集合，即father[A]=B，father[B]=C 表示A与B与C连通了（有向连通图）。但无法也无需知道B连通A，类似树的结构，把root当成分类的标准，当root都相等的时候，说明在同一个集合</p></li><li><p>怎么判断元素联通/元素在同一个集合，只需要递归求得元素的根是否是同一个，</p></li><li><p>怎么表示C也在同一个元素集合里呢？ 只需 father[C] = C，即C的根也为C，所以father数组初始化的时候要 father[i] = i，默认自己指向自己。</p></li><li><p>路径压缩：为了避免在多叉树情况下寻根递归次数过多，将非根节点的所有节点直接指向根节点。只需要在递归的过程中，让 father[u] 接住 递归函数 find(father[u]) 的返回结果。</p></li></ul><p>并查集的模板</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnionFind</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> father<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>

    <span class="token comment">// 构造函数初始化并查集</span>
    <span class="token keyword">public</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>
        father <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 并查集初始化</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            father<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 并查集里寻根的过程</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">!=</span> parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 路径压缩，将当前节点指向根节点</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 判断 u 和 v 是否属于同一个集合</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSame</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 将 v -&gt; u 这条边加入并查集</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        u <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 寻找 u 的根</span>
        v <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 寻找 v 的根</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">!=</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 如果不在同一个根，将 v 的根设置为u</span>
            father<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 测试方法</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1005</span><span class="token punctuation">;</span> <span class="token comment">// 假设有 1005 个节点</span>
        <span class="token class-name">UnionFind</span> uf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnionFind</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 示例操作</span>
        uf<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        uf<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>uf<span class="token punctuation">.</span><span class="token function">isSame</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 true</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>uf<span class="token punctuation">.</span><span class="token function">isSame</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 false</span>

        uf<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>uf<span class="token punctuation">.</span><span class="token function">isSame</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过模板，我们可以知道，并查集主要有三个功能。</p><p>寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个<br> 将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上<br> 判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点</p><ul><li>常见误区<br> 模板中的 join 函数里的这段代码：</li></ul><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>u = find(u); // 寻找u的根
v = find(v); // 寻找v的根
if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>与 isSame 函数的实现是不是重复了？ 如果抽象一下呢，代码如下：</p><div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v-&gt;u 这条边加入并查集
void join(int u, int v) {
    if (isSame(u, v)) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/953ebc346de365dff82ea.png" alt="并查集误区.png" tabindex="0"><figcaption>并查集误区.png</figcaption></figure><figure><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/971ce42dd9541db0703a7.png" alt="并查集模拟.png" tabindex="0"><figcaption>并查集模拟.png</figcaption></figure><figure><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/af4735f3484bd995c42be.png" alt="拓展.png" tabindex="0"><figcaption>拓展.png</figcaption></figure><p>空间复杂度： O(n) ，申请一个father数组。<br> 时间复杂度在O(logn)与O(1)之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)。<br> 在第一次查询的时候，相当于是n叉树上从叶子节点到根节点的查询过程，时间复杂度是logn，<br> 路径压缩后，后面的查询操作都是O(1)，而 join 函数 和 isSame函数 里涉及的查询操作也是一样的过程。</p><h1 id="使用场景" tabindex="-1"><a class="header-anchor" href="#使用场景"><span>使用场景</span></a></h1><ul><li>Kruskal 最小生成树算法</li><li>网格渗透</li><li>网络连通性</li><li>树中的东方共同祖先</li><li>图像处理</li></ul><h1 id="复杂度" tabindex="-1"><a class="header-anchor" href="#复杂度"><span>复杂度</span></a></h1><p>Construction O(n)<br> Union α(n)<br> Find α(n)<br> Get component size α(n)<br> Check if connected α(n)<br> Count components O(1)<br> α摊销固定时间</p>`,18),i=[p];function o(c,l){return s(),a("div",null,i)}const d=n(e,[["render",o],["__file","unionfind.html.vue"]]),k=JSON.parse('{"path":"/interview/datastructure/graph/unionfind.html","title":"并查集","lang":"zh-CN","frontmatter":{"title":"并查集","icon":"circle-info","date":"2023-01-01T00:00:00.000Z","tags":"并查集","categories":"面试","description":"并查集理论基础 并查集主要有两个功能：将两个元素添加到一个集合中。判断两个元素在不在同一个集合 思想：用一个一维数组表示三个元素A，B，C （分别是数字）在同一个集合，即father[A]=B，father[B]=C 表示A与B与C连通了（有向连通图）。但无法也无需知道B连通A，类似树的结构，把root当成分类的标准，当root都相等的时候，说明在同一...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/interview/datastructure/graph/unionfind.html"}],["meta",{"property":"og:site_name","content":"JavaGuide"}],["meta",{"property":"og:title","content":"并查集"}],["meta",{"property":"og:description","content":"并查集理论基础 并查集主要有两个功能：将两个元素添加到一个集合中。判断两个元素在不在同一个集合 思想：用一个一维数组表示三个元素A，B，C （分别是数字）在同一个集合，即father[A]=B，father[B]=C 表示A与B与C连通了（有向连通图）。但无法也无需知道B连通A，类似树的结构，把root当成分类的标准，当root都相等的时候，说明在同一..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://290ff162.telegraph-image-eg9.pages.dev/file/953ebc346de365dff82ea.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"HeChuangJun"}],["meta",{"property":"article:published_time","content":"2023-01-01T00:00:00.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并查集\\",\\"image\\":[\\"https://290ff162.telegraph-image-eg9.pages.dev/file/953ebc346de365dff82ea.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/971ce42dd9541db0703a7.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/af4735f3484bd995c42be.png\\"],\\"datePublished\\":\\"2023-01-01T00:00:00.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeChuangJun\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"并查集理论基础","slug":"并查集理论基础","link":"#并查集理论基础","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":3.59,"words":1078},"filePathRelative":"interview/datastructure/graph/unionfind.md","localizedDate":"2023年1月1日","excerpt":"<h2>并查集理论基础</h2>\\n<ul>\\n<li>\\n<p>并查集主要有两个功能：将两个元素添加到一个集合中。判断两个元素在不在同一个集合</p>\\n</li>\\n<li>\\n<p>思想：用一个一维数组表示三个元素A，B，C （分别是数字）在同一个集合，即father[A]=B，father[B]=C 表示A与B与C连通了（有向连通图）。但无法也无需知道B连通A，类似树的结构，把root当成分类的标准，当root都相等的时候，说明在同一个集合</p>\\n</li>\\n<li>\\n<p>怎么判断元素联通/元素在同一个集合，只需要递归求得元素的根是否是同一个，</p>\\n</li>\\n<li>\\n<p>怎么表示C也在同一个元素集合里呢？ 只需 father[C] = C，即C的根也为C，所以father数组初始化的时候要 father[i] = i，默认自己指向自己。</p>\\n</li>\\n<li>\\n<p>路径压缩：为了避免在多叉树情况下寻根递归次数过多，将非根节点的所有节点直接指向根节点。只需要在递归的过程中，让 father[u] 接住 递归函数 find(father[u]) 的返回结果。</p>\\n</li>\\n</ul>","autoDesc":true}');export{d as comp,k as data};
