import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as i,c as e,e as a}from"./app-7KT7HDzT.js";const E={},n=a(`<p>计算机组成原理</p><ul><li><a href="#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA">1. 计算机系统概论</a><ul><li><a href="#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9A%84%E5%A5%BD%E5%9D%8F%E5%8F%96%E5%86%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E5%8A%9F%E8%83%BD%E7%9A%84%E6%80%BB%E5%92%8C">1.1. 计算机系统组成-&gt;计算机性能的好坏取决于软硬件功能的总和</a></li><li><a href="#12-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B">1.2. 现代计算机的解题过程</a></li><li><a href="#13-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">1.3. 计算机系统的层次结构</a></li><li><a href="#14-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90">1.4. 计算机基本组成</a></li></ul></li><li><a href="#2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2">2. 计算机发展简史</a></li><li><a href="#3-%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF">3. 系统总线</a><ul><li><a href="#31-%E6%80%BB%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">3.1. 总线的基本概念</a></li><li><a href="#32-%E6%80%BB%E7%BA%BF%E5%88%86%E7%B1%BB">3.2. 总线分类</a></li><li><a href="#33-%E6%80%BB%E7%BA%BF%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87">3.3. 总线性能指标</a></li><li><a href="#34-%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86">3.4. 总线标准</a></li><li><a href="#35-%E6%80%BB%E7%BA%BF%E6%8E%A7%E5%88%B6">3.5. 总线控制</a></li></ul></li><li><a href="#4-%E5%AD%98%E5%82%A8%E5%99%A8">4. 存储器</a><ul><li><a href="#41-%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8">4.1. 存储介质</a></li><li><a href="#42-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB">4.2. 存储器的分类</a></li><li><a href="#43-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">4.3. 存储器的层次结构</a></li><li><a href="#44-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">4.4. 存储系统层次结构</a></li><li><a href="#45-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8">4.5. 主存储器</a></li><li><a href="#46-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%A0%A1%E9%AA%8C%E6%B1%89%E6%98%8E%E7%A0%81">4.6. 存储器的校验(汉明码)</a></li><li><a href="#47-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8">4.7. 高速缓冲存储器</a></li><li><a href="#48-%E7%BC%93%E5%AD%98-%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%88%B0cache%E5%9C%B0%E5%9D%80%E7%A7%B0%E4%B8%BA%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84">4.8. ？？？？缓存-主存地址映射方式（主存地址映射到Cache地址称为地址映射）</a></li><li><a href="#49-%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5">4.9. 替换策略</a></li><li><a href="#410-%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8">4.10. 辅助存储器</a></li></ul></li><li><a href="#5-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F">5. 输入输出系统</a><ul><li><a href="#51-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E6%A6%82%E5%86%B5">5.1. 输入输出系统发展概况</a></li><li><a href="#52-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90">5.2. 输入输出系统的组成</a></li><li><a href="#53-io%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%B8%BB%E6%9C%BA%E7%9A%84%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F">5.3. I/O设备与主机的联系方式</a></li><li><a href="#54-io%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%81%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F">5.4. I/O设备与主机信息传送的控制方式</a></li><li><a href="#55-io%E6%8E%A5%E5%8F%A3">5.5. I/O接口</a></li><li><a href="#56-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%BB%84%E6%88%90">5.6. 接口的功能和组成</a></li><li><a href="#57-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F">5.7. 程序中断方式</a></li><li><a href="#58-%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%81%E7%A8%8B">5.8. 中断服务程序的流程</a></li><li><a href="#59-dma%E6%96%B9%E5%BC%8F">5.9. DMA方式</a></li></ul></li><li><a href="#6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95">6. 计算机的运算方法</a><ul><li><a href="#61-%E8%BF%9B%E5%88%B6%E7%9A%84%E6%A6%82%E8%BF%B0">6.1. 进制的概述</a></li><li><a href="#62-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0">6.2. 计算机中的数</a></li><li><a href="#63-%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA">6.3. 数的定点表示和浮点表示</a></li><li><a href="#64-%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95">6.4. 定点数的加减法</a></li><li><a href="#65-%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97">6.5. 定点数乘法运算</a></li><li><a href="#66-%E5%AE%9A%E7%82%B9%E6%95%B0%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97">6.6. 定点数除法运算</a></li><li><a href="#67-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95">6.7. 浮点数的加减法</a></li></ul></li><li><a href="#7-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F">7. 指令系统</a><ul><li><a href="#71-%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4">7.1. 机器指令</a></li><li><a href="#72-%E6%93%8D%E4%BD%9C%E6%95%B0%E7%B1%BB%E5%9E%8B">7.2. 操作数类型</a></li><li><a href="#73-%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B">7.3. 操作类型</a></li><li><a href="#74-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F">7.4. 寻址方式</a></li></ul></li><li><a href="#8-cpu%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD">8. CPU的结构和功能</a><ul><li><a href="#81-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD">8.1. 控制器的基本功能</a></li><li><a href="#82-cpu%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE">8.2. CPU结构框图</a></li></ul></li><li><a href="#9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8">9. 计算机的控制器</a></li><li><a href="#10-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E5%99%A8">10. 计算机的运算器</a><ul><li><a href="#101-cpu%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8">10.1. CPU的寄存器</a></li><li><a href="#102-%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E5%92%8C%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F">10.2. 控制单元和中断系统</a></li><li><a href="#103-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F">10.3. 指令周期</a></li></ul></li><li><a href="#11-%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F">11. 中断系统</a><ul><li><a href="#111-%E6%A6%82%E8%BF%B0">11.1. 概述</a></li><li><a href="#112-%E4%B8%AD%E6%96%AD%E5%88%A4%E4%BC%98%E9%80%BB%E8%BE%91">11.2. 中断判优逻辑</a></li><li><a href="#113-%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%E7%9A%84%E5%AF%BB%E6%89%BE">11.3. 中断服务程序入口地址的寻找</a></li><li><a href="#114-%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94">11.4. 中断响应</a></li><li><a href="#115-%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%8A%80%E6%9C%AF%E7%94%A8%E4%BA%8E%E5%A4%9A%E9%87%8D%E4%B8%AD%E6%96%AD">11.5. 中断屏蔽技术(用于多重中断)</a></li></ul></li><li><a href="#12-%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E5%8A%9F%E8%83%BD">12. 控制单元的功能</a><ul><li><a href="#121-%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E7%9A%84%E5%88%86%E6%9E%90">12.1. 微操作命令的分析</a></li><li><a href="#122-%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F">12.2. 中断周期</a></li></ul></li><li><a href="#13-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">13. 计算机指令的执行过程</a></li><li><a href="#cpu%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%80%A7">CPU实现原子性</a></li></ul><h1 id="_1-计算机系统概论" tabindex="-1"><a class="header-anchor" href="#_1-计算机系统概论"><span>1. 计算机系统概论</span></a></h1><h2 id="_1-1-计算机系统组成-计算机性能的好坏取决于软硬件功能的总和" tabindex="-1"><a class="header-anchor" href="#_1-1-计算机系统组成-计算机性能的好坏取决于软硬件功能的总和"><span>1.1. 计算机系统组成-&gt;计算机性能的好坏取决于软硬件功能的总和</span></a></h2><ul><li>硬件：计算机实体部分，由各种电子元器件，各类光、电、机设备的实物组成</li><li>软件：由人们事先编制的具有各类特殊功能的程序组成，常存放在计算机的主存或辅存内，分为系统软件和应用软件 <ul><li>系统软件/程序：管理整个计算机系统，监视服务，使系统资源得到合理调度，高效运行，包括标准程序库、语言处理程序（如将汇编语言翻译成机器语言的汇编程序或者将高级语言翻译成机器语言的编译程序）、操作系统（如批处理系统、分时系统、实时系统）、服务程序（如诊断程序、调试程序、连接程序等）数据库管理系统、网络软件等</li><li>应用软件/程序：根据任务需要编制的各种程序，如科学计算程序，数据处理程序，过程控制程序，事务管理程序等</li></ul></li></ul><h2 id="_1-2-现代计算机的解题过程" tabindex="-1"><a class="header-anchor" href="#_1-2-现代计算机的解题过程"><span>1.2. 现代计算机的解题过程</span></a></h2><ul><li>由用户用高级语言编写程序（源程序），然后将它和数据一起送入计算机内，再由计算机将其翻译成机器能识别的机器语言程序（目标程序），机器自动运行该机器语言程序，并将结果输出</li></ul><h2 id="_1-3-计算机系统的层次结构" tabindex="-1"><a class="header-anchor" href="#_1-3-计算机系统的层次结构"><span>1.3. 计算机系统的层次结构</span></a></h2><ul><li><p>机器语言机器：用户必须用二进制代码来编写程序（机器语言程序），可以直接在机器上执行，直接执行机器语言的机器称为实际机器M1</p></li><li><p>汇编语言机器：汇编语言使用符号表示指令或数据所在存储单元的地址，使程序员可以不再使用繁杂而又易错的二进制代码编写程序；汇编程序将汇编语言程序翻译成机器语言程序</p></li><li><p>高级语言机器：程序员不必了解、掌握实际机器M1的机型、内部的具体组成及其指令系统，只需掌握高级语言的语法和语义，便可直接编程。在进入机器语言机器运行前，由翻译程序将高级语言程序翻译成机器语言程序。翻译程序分为编译程序和解释程序</p><ul><li>编译程序：将高级语言程序的全部语句一次全部翻译成机器语言程序，而后再执行机器语言程序。只要源程序不变，无需再次进行翻译。产生新的程序（C\\C++\\Golang）</li><li>解析程序：逐条翻译源程序的语句并执行，直至完成源程序的全部翻译任务，翻译一次执行一次，即使下一次重复执行该语句时，也必须重新翻译。不产生新的程序（Python\\Php\\Javascript）</li></ul></li><li><p>微程序机器：将机器语言机器中的每一条机器指令翻译成一组微指令，构成一个微程序。机器语言机器每执行完对应于一条机器指令的微程序后，便由机器语言机器中的下一条指令使微程序机器自动进入与其相对应的另一个微程序的执行。微程序机器可以看做是对机器语言机器的分解，即用微程序机器的微程序解释并执行每一条机器指令</p></li><li><p>操作系统机器：由操作系统软件构成。提供汇编语言和高级语言在使用和实现过程中所需的某些基本操作，还起到控制并管理计算机系统全部硬件和软件资源的作用，为用户使用计算机系统提供极为方便的条件，操作系统的功能是通过其控制语言来实现的</p></li><li><p>硬件研究的主要对象归结为传统机器M1和微程序机器M0，软件的研究对象主要是操作系统及以上的各级虚拟机<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/2b1b1bc7cd4defb97dd4a.png" alt="9.PNG"></p></li><li><p>计算机系统的属性：程序员看到的传统机器的属性：包括指令集、数据类型、存储器寻址技术、i/o机理等大多数是抽象属性</p></li><li><p>计算机体系结构：指那些能够被程序员所见到的计算机系统的属性，即概念性的结构与功能特性</p></li><li><p>计算机组成：指如何实现计算机体系结构所体现的属性（指令系统属于计算机结构问题，而指令的实现、如何取指令、分析指令、取操作数、运算、送结果等属于计算机组成问题，结构相同的计算机，组成（结构实现）不一定相同）</p></li></ul><h2 id="_1-4-计算机基本组成" tabindex="-1"><a class="header-anchor" href="#_1-4-计算机基本组成"><span>1.4. 计算机基本组成</span></a></h2><ul><li>冯诺依曼计算机:1945年，数学家冯诺依曼提出存储程序的概念，以此概念为基础的计算机都称为冯诺依曼机。特点如下 <ul><li>计算机是由运算器、存储器、控制器、输入设备和输出设备五大部件组成</li><li>指令和数据均以二进制表示，存放在存储器内，并可按地址寻访</li><li>指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置</li><li>指令在存储器内按顺序存放。通常指令是顺序执行的，在特性条件下，可根据运算结果或根据设定条件改变执行顺序</li><li>机器以运算器为中心，输入输出设备与存储器间的数据传送通过运算器完成</li><li>冯诺依曼瓶颈-&gt;运算器运算速度比存储器访问速度快（CPU经常空转等待数据传输）</li></ul></li><li>计算机的硬件框图 <ul><li>经典的冯诺依曼计算机以运算器为中心</li><li>现代的计算机以存储器为中心</li><li>运算器：完成算术运算和逻辑运算，并将运算的中间结果暂存在运算器内</li><li>存储器：存放数据和程序</li><li>控制器：控制、指挥程序和数据的输入、运行以及处理运算结果，解释存储器中的指令，并发出各种操作命令来执行指令</li><li>输入设备：将人们熟悉的信息形式转换为机器能识别的信息形式</li><li>输出设备：将机器运算结果转换为人么熟悉的信息形式</li></ul></li><li>现代计算机组成 <ul><li>主机 <ul><li>中央处理器CPU(Central Processing Unit)=运算器（算术逻辑单元Arithmetic Logic Unit,ALU）+控制器（控制单元Control Unit,CU）</li><li>主存储器(Main Memory,MM)</li></ul></li><li>I/O设备(外部设备) = 输入设备 + 输出设备</li></ul></li></ul><p><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/f1eaf30bbe80adb74a1a8.png" alt="1.png"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/ffd9f676eecdaf2d46b96.png" alt="2.png"></p><ul><li>计算机的工作步骤（待补充）</li><li>计算机硬件的主要技术指标 <ul><li>机器字长：CPU一次能处理数据的位数，与CPU寄存器位数有关，字长越长，数的表示范围越大，精度越高</li><li>存储容量：包括了主存容量和辅存容量，主存容量指主存中存放二进制代码的总位数 <ul><li>存储容量 = 存储单元个数 x 存储字长（存储单元个数 = 2^MAR的位数，存储字长 = MDR的位数）</li><li>计算机存储设备的最小信息单元叫“位（bit）”或“比特位”，用b表示。</li><li>计算机最小的存储单元叫“字节（byte）”，用B表示，字节是由连续的8个位组成</li><li>当程序需要使用存储空间时，操作系统最小会分派给程序1个字节，而不是1个位</li><li>1个字节（8位）存储的最大数据是11111111的二进制数</li><li>1B（字节） = 8bit、1KB = 1024B(寄存器)、1MB = 1024KB(高速缓存)、1GB = 1024MB(内存/硬盘) 1TB = 1024GB(硬盘)、1PB = 1024TB(云硬盘)，1EB=1024PB(数据仓库)</li></ul></li><li>运算速度 <ul><li>MIPS（Million Instruction Per Second 百万条指令每秒）：单位时间内执行指令的平均条数</li><li>CPI（Cycle Per Instruction）：执行一条指令所需的时钟周期（机器主频的倒数）</li><li>FLOPS（Floating Point Operation Per Second 浮点数运算次数每秒）</li></ul></li><li>CPU速度： <ul><li>CPU的时钟频率。单位赫兹Hz：秒分之一。每秒中的周期性变动重复次数的计量。高低电平每秒钟变动的频率</li><li>1Hz = 1/s，即在单位时间内完成振动的次数，单位为赫兹（1赫兹=1次/秒）。2GHz=2*1000^3Hz=每秒20亿次变动高低电平</li></ul></li></ul></li></ul><h1 id="_2-计算机发展简史" tabindex="-1"><a class="header-anchor" href="#_2-计算机发展简史"><span>2. 计算机发展简史</span></a></h1><ul><li>第一代电子管计算机（1946-1957）:第二次世界大战中由电子管组成的电子数字积分机和计算机（Electronic Numerical Integerator And Computer,ENIAC），采用十进制运算，电路结构复杂，耗电量大，体积大，操作复杂</li><li>第二代晶体管计算机（1957-1964）：贝尔实验室发明用半导体组成的晶体管。集成度相对较高，空间占用相对小，功耗相对较低，运行速度较快，操作相对简单。交互更加方便</li><li>第三代集成电路计算机（1964-1980）：（德州仪器发明了集成电路IC）计算机变得更小，功耗变得更低，计算速度变得更快</li><li>超大规模集成电路计算机（1980-现在）： 一个芯片集成了上百万的晶体管，速度更快，体积更小，价格更低，更能被大众接受，用途丰富：文本处理、表格处理、高交互的游戏与应用</li></ul><h1 id="_3-系统总线" tabindex="-1"><a class="header-anchor" href="#_3-系统总线"><span>3. 系统总线</span></a></h1><h2 id="_3-1-总线的基本概念" tabindex="-1"><a class="header-anchor" href="#_3-1-总线的基本概念"><span>3.1. 总线的基本概念</span></a></h2><ul><li>总线连接：计算机将各部件连到一组公共信息传输线上</li><li>总线: 多个部件的信息传输线，各部件共享的传输介质。由许多传输线和通路组成，每条线可一位一位地传输二进制代码，16条传输线组成的总线可以同时传输16位二进制代码</li><li>当多个部件同时向总线发送信息，势必导致信号冲突，传输无效。因此在某一个时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收相同的信息</li><li>各类总线结构</li></ul><p><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/89cf6bfb02d7fb5b3fd3d.png" alt="10.png"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/e8201c19b05063373ad5f.png" alt="11.png"></p><h2 id="_3-2-总线分类" tabindex="-1"><a class="header-anchor" href="#_3-2-总线分类"><span>3.2. 总线分类</span></a></h2><ul><li>按数据传输方式分：并行传输总线(8位、16位、32位、64位传输总线)、串行传输总线</li><li>按使用范围分：外设总线、测控总线、网络通信总线等</li><li>按连接部件不同 <ul><li>片内总线：芯片内部的总线，寄存器与寄存器之间、寄存器与控制器、运算器之间都由片内总线连接</li><li>系统总线：CPU、主存、I/O设备（通过I/O接口）各大部件之间的信息传输线，按传输信息不同分 <ul><li>数据总线（双向传输总线）：传输各功能部件之间的数据信息。数据总线的位数称为数据总线宽度，与机器字长，存储字长有关</li><li>地址总线（单向输出总线）：用来指出数据总线上源数据或目的数据在内存中的地址或I/O设备的地址，地址总线的位数和存储单元个数有关，地址线20根，则对应的存储单元个数为2^20</li><li>控制总线：发出各种控制信号的传输线，任一控制线的传输都是单向的，可以监视不同组件之间的状态（就绪、未就绪）。控制信号经由控制总线从一个组件发送给另外一个组件，常见控制信号如下： <ul><li>时钟：同步各种操作</li><li>复位：初始化所有部件</li><li>总线请求：表示某部件需要获得总线使用权</li><li>总线允许：表示需要获得总线使用权的部件已获得了控制权</li><li>中断请求：表示某部件提出中断请求</li><li>存储器写：将数据总线上的数据写至存储器的指定地址单元内</li><li>存储器读：将指定存储单元中的数据读到数据总线上</li><li>I/O读：从指定的I/O端口将数据读到数据总线上</li><li>I/O写：将数据总线上的数据输出到指定的I/O端口内</li><li>传输响应：表示数据已被接收，或已将数据传送至数据总线上</li></ul></li></ul></li><li>通信总线：用于计算机系统之间或计算机系统与其他系统之间（控制仪表、移动通信等）的通信。按传输方式分 <ul><li>串行通信：数据在单条1位宽的传输线上，一位一位地按顺序分时传送，如1字节的数据，在串行传送中，需要通过一条传输线分8次由地位到高位按顺序逐位传送，适宜于远距离传送，从几米到达数千公里</li><li>并行通信：数据在多条一位宽的传输线上，同时有源传送到目的地，如1字节的数据，在并行传送中，要通过8条并行传输线同时由源传送到目的地。适宜近距离数据传输，小于30m</li><li>都与距离成反比，串行通信费用低</li></ul></li></ul></li></ul><h2 id="_3-3-总线性能指标" tabindex="-1"><a class="header-anchor" href="#_3-3-总线性能指标"><span>3.3. 总线性能指标</span></a></h2><ul><li>总线宽度：总线的根数，用bit（位）表示，8、16、32、64位（即8、16、32、64根）</li><li>总线带宽：总线的传输速率，单位时间内总线上传输数据的位数，通常用每秒传输的字节数MBps（兆字节每秒）表示，例如，总线工作频率为33MHz，总线宽度为32位（4B），则总线带宽为33 x （32）÷ 8 = 132MBps</li><li>时钟同步/异步：总线上的数据与时钟同步工作的总线称为同步总线，与时钟不同步工作的总线称为异步总线</li><li>总线复用：一条信号线上分时传送两种信号，物理上将地址总线和数据总线共用一组物理线路。分时传输地址信号和数据信号</li><li>信号线数：地址、数据、控制总线三种总线数总和</li><li>总线控制方式:包括突发工作，自动配置，仲裁方式，逻辑方式，计数方式等</li><li>负载能力：当总线接上负载后，总线输入输出的逻辑电平是否能保持在正常的额定范围内，通常用可连接扩增电路板数反应总线的负载能力</li><li>其他指标：电源电压、总线宽度是否能扩展等<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/60609ac2bc8b113115b76.png" alt="13.png"></li></ul><h2 id="_3-4-总线标准" tabindex="-1"><a class="header-anchor" href="#_3-4-总线标准"><span>3.4. 总线标准</span></a></h2><ul><li>系统与各模块、模块与模块之间的一个互连的标准界面。界面对它两端的模块都是透明的，界面的任一方只需根据总线标准的要求完成自身一方的功能要求， 无需了解对方接口与总线的连接要求，按总线设计的接口可视为通用接口</li><li>流行的总线标准：ISA总线、EISA总线、VESA总线、PCI总线常用、AGP总线（显卡）、RS-232C总线、USB总线(Universal Serial Bus)</li></ul><h2 id="_3-5-总线控制" tabindex="-1"><a class="header-anchor" href="#_3-5-总线控制"><span>3.5. 总线控制</span></a></h2><ul><li><p>总线判优控制：</p><ul><li>总线上所连接的设备，按其对总线有无控制能力可分为主设备（模块）和从设备（设备）</li><li>主设备对总线有控制权，从设备只能响应从主设备发过来的总线命令，对总线无控制权</li><li>总线上的信息传送是由主设备启动的，由主设备发送总线请求信号</li><li>若多个主设备同时使用总线，则由总线控制器的判优、仲裁逻辑按一定的优先等级顺序确定哪个设备能使用总线，只有获得总线使用权的主设备才能开始传送数据</li></ul></li><li><p>总线判优控制分类</p><ul><li>集中控制优先权仲裁方式：将控制逻辑集中在一处（如CPU） <ul><li>链式查询： <ul><li>用三根线总线控制（BS总线忙、BR总线请求、BG总线同意），其中总线同意信号BG是串行地从一个I/O接口送到下一个I/接口。如果BG到达的接口有总线请求，BG信号就不再往下传，该接口获得总线使用权，并建立总线忙BS信号，表示它占用了总线。离总线控制部件最近的设备具有最高的优先级。</li><li>电路复杂度低，控制线少，仲裁方式简单，容易扩充设备。</li><li>优先级低的设备难以获得总线使用权，对电路故障敏感</li><li>仅用2根线确定总线使用权属于哪个设备(n为允许接纳的最大设备数)</li></ul></li><li>计时器定时查询 <ul><li>相比链式查询多了设备地址线，少了总线同意线BG</li><li>总线控制器接收到BR送来的总线请求信号后，在总线未被使用（BS=0）的情况下，总线控制部件中的计数器开始计数，并通过设备地址总线，向各设备发出一组地址信号。当某个请求的占用的设备地址与计数值一致时，便获得总线使用权，此时终止计数查询</li><li>计数可以从0开始，此时一旦设备的优先次序被固定，设备的优先级就按0-n顺序排序，固定不变；计数可以从上一次计数的终止点开始，是一种循环的方法，此时设备使用总线的优先级相等；计数的初始值可以由程序设置，故优先次序可以改变</li><li>设备的优先级可以改变。电路故障敏感性降低</li><li>控制复杂，增加了控制线数</li><li>使用log2n根线确定总线使用权属于哪个设备(n为允许接纳的最大设备数)</li></ul></li><li>独立请求 <ul><li>每台设备均有一对总线请求线BR和总线同意线BG。总线控制部件中有一排队电路，可根据优先次序确定响应那一台设备的请求。</li><li>好处：响应速度快，优先顺序控制灵活、</li><li>坏处：控制线数量多，总线控制复杂</li><li>使用2n根线确定总线使用权属于哪个设备(n为允许接纳的最大设备数)</li></ul></li></ul></li><li>分布式：将控制逻辑分散在与总线连接的各个部件或设备上<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/1bb119fee9de6648cc32e.png" alt="22.png"></li></ul></li><li><p>总线通信控制</p><ul><li>总线通信控制解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调配合</li><li>总线周期:完成一次总线操作的时间 <ul><li>申请分配阶段：由需要使用总线的主设备发出申请，经总线仲裁记过决定下一传输周期的总线使用权授予某一申请者</li><li>寻址阶段：取得了使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，启动参与本次传输的从模块</li><li>传数阶段：主模块和从模块进行数据交换，数据有源模块发出，经数据总线流入目的模块</li><li>结束阶段：主模块的有关信息从系统总线上撤除，让出总线使用权</li></ul></li><li>通信方式 <ul><li>同步通信：通信双方由统一时标控制数据传送，时标通常由CPU的总线控制部件发出，送到总线上的所有部件，也可以由每个部件各自的时序发送器发出，但必须由总线控制部件发出的时钟信号对他们进行同步 <ul><li>优缺点：规定明确、统一，各模块的配合简单一一致；对不同速度的部件而言，必须按最慢的速度的部件设计公共时钟，严重影响总线工作效率，缺乏灵活性</li><li>适用于总线长度短、各部件存取时间比较一致的场合</li></ul></li><li>异步通信 <ul><li>允许各模块速度不一致，没有公共的时钟标准，不要求所有部件严格的同一操作时间</li><li>采用应答（握手）的方式，当主模块发出请求信号时，一直等待从模块反馈回来的响应信号后才开始通信，要求主从模块之间增加两条应答线（握手交互信号线）</li><li>异步通信应答方式(并行或串行传送) <ul><li>不互锁（CPU向主存写信息）：主模块发出信号后，不必等待接到从模块的回答信号，而是经过一段时间，确认从模块已收到请求信号后，便撤销其请求信号，从模块接收到请求信号后，在条件允许时发出回答信号，并且经过一段时间确认主模块收到回答信号后，自动撤销回答信号</li><li>半互锁（多机系统中CPU访问共享存储器）：主模块发出请求信号后必须接到从模块的回答信号才撤销其请求信号。从模块接收到请求信号后，不必确认主模块收到回答信号后，经过一段时间后自动撤销回答信号</li><li>全互锁（网络通信）：主模块发出请求信号后必须接到从模块的回答信号才撤销其请求信号。从模块发出应答信号待主模块请求信号撤销后，再撤销请求信号<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/25a073dfb1519b145a517.png" alt="23.png"></li></ul></li></ul></li><li>半同步通信 <ul><li>保留了同步通信的基本特点，如所有的地址、命令、数据信号的发出时间，都严格参照系统时钟的某个前沿开始。而接收方都采用系统时间后沿时刻来进行判断识别，同时像异步通信，允许不同速度的模块和谐工作、增设一条WAIT响应信号线，采用插入时钟（等待）周期的措施来协调通信双方的配合问题</li><li>优缺点：比异步通信简单。全系统内各模块在统一系统时钟控制下同步工作，可靠性高，同步结构方便</li><li>缺点：对系统时钟频率不能要求太高，系统工作速度不高</li></ul></li><li>分离式通信（大型计算机） <ul><li>将一个传输周期/总线周期分解为两个子周期；第一个子周期，主模块A申请并获得总线使用权后，将数据传输到总线上，并放弃总线使用权；第二个子周期，从模块B接收到主模块发来的信号后，准备好传输数据后才申请并获得总线使用权，将数据传输给主模块A，并放弃总线使用权</li><li>特点 <ul><li>各模块都变成主模块都要提出申请占用总线使用权</li><li>在得到总线使用权后，主模块在限定的时间内想对方传送信息，采用同步方式传送，不再等待对方的应答信号</li><li>各模块在准备数据的过程中不占用总线，使总线可接受其他模块的请求</li><li>总线被占用时不存在空闲等待时间，充分利用了总线的有效占用，实现了总线在多个主、从模块之间信息交叉重叠并行式传送<br> -缺点：控制复杂，普通微型计算机系统很少采用</li></ul></li></ul></li></ul></li></ul></li></ul><h1 id="_4-存储器" tabindex="-1"><a class="header-anchor" href="#_4-存储器"><span>4. 存储器</span></a></h1><h2 id="_4-1-存储介质" tabindex="-1"><a class="header-anchor" href="#_4-1-存储介质"><span>4.1. 存储介质</span></a></h2><ul><li>能寄存&quot;0&quot;、&quot;1&quot;两种代码并能区别两种状态的物质或元器件，存储介质主要有半导体器件、磁性材料和光盘等</li></ul><h2 id="_4-2-存储器的分类" tabindex="-1"><a class="header-anchor" href="#_4-2-存储器的分类"><span>4.2. 存储器的分类</span></a></h2><ul><li>按存储介质分类 <ul><li>半导体存储器：存储元件由半导体器件组成的存储器，优点：体积小、功耗低、存取时间短；缺点：易失性存储器（电源消失时，所存信息随即丢失）内存、U盘、固态硬盘</li><li>磁表面存储器：在金属或塑料表面上涂一层磁性材料作为记录介质，工作时磁层随载磁体高速运转，用磁头在磁层上进行读/写操作。按载磁体形状不同分：磁盘、磁带、磁鼓（少用），具有矩形磁滞回线特性的材料作表面物质，它们按其剩磁的状态不同区分0或者1，而且剩磁状态不会轻易丢失，属于非易失性存储器</li><li>磁芯存储器：由硬磁材料做成的环状元件，在磁芯中穿有驱动线和读出线，便可以进行读/写操作(永久记忆存储器)，因为体积太大，工艺复杂、功耗太大不用了</li><li>光盘存储器：应用激光在记录介质（磁光材料上）进行读/写的存储器，非易失性存储器；耐用性好、记录密度高、可互换性强特点，常用</li></ul></li><li>按存储方式分类 <ul><li>随机存储器（RAM Random Access Memory主存）:可读写，任何一个存储单元的内容都可随机存取，存取时间与存储单元的物理位置无关，分为静态RAM（以触发器原理寄存信息）和动态RAM(以电容放电原理寄存信息，每隔一段时间刷新一次)</li><li>只读存储器（ROM Read Only Memory）：只能对存储的内容读出，不能对其重新写入的存储器。通常存放固定不变的程序、常数和汉字字库，甚至用于操作系统的固化。与随机存储器可共同作为主存一部分，统一构成主存的地址域</li><li>串行访问存储器（顺序存储器-磁带存储器）：对存储器读写时，只能按物理位置先后顺序寻址；信息位置不同，读写时间不同，如磁带、磁盘</li><li>直接存储器：部分串行访问的存储器（磁盘）：在对磁盘读/写时，首先直接指出该存储器中的某个小区域（磁道），然后再顺序寻访，直至找到位置。故前段是直接访问，后端是串行访问</li></ul></li><li>按在计算机中的作用分类 <ul><li>主存储器（主存）：和CPU直接交换信息，速度快，容量小，每位价格高</li><li>辅助存储器（磁盘、U盘、光盘、磁带等）：存放当前暂时不用的程序和数据，不能和CPU直接交换信息，速度慢，容量大，每位价格低</li><li>缓冲存储器（L1、L2、L3缓存，CPU寄存器等）：用在速度不同的部件之中，如CPU与主存之间可设置一个快速缓存<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/bc75707d79485b2dbb8b4.png" alt="24.png"></li></ul></li></ul><h2 id="_4-3-存储器的层次结构" tabindex="-1"><a class="header-anchor" href="#_4-3-存储器的层次结构"><span>4.3. 存储器的层次结构</span></a></h2><ul><li>存储器的性能指标：速度、容量和每位价格（位价）</li><li>存储器速度、容量和位价的关系 <ul><li>位价和速度:辅存（磁盘、磁带）&lt;主存&lt;缓存&lt;寄存器</li><li>容量:辅存（磁盘、磁带）&gt;主存&gt;缓存&gt;寄存器</li></ul></li><li>寄存器和缓存Cache通常放在CPU中，寄存器中的数直接在CPU内部参与运算，主存存放将要参与运行的程序和数据</li><li>CPU，缓存，主存能直接交信息，CPU不能直接访问辅存</li></ul><h2 id="_4-4-存储系统层次结构" tabindex="-1"><a class="header-anchor" href="#_4-4-存储系统层次结构"><span>4.4. 存储系统层次结构</span></a></h2><ul><li>缓存-主存层次：利用局部性原理解决CPU和主存速度不匹配问题，速度接近于缓存，容量和位价接近主存 <ul><li>在CPU与主存之间增加一层速度快（容量小）的Cache</li><li>由于缓存的速度比主存的速度高，只要将CPU近期要用的信息调入缓存，CPU便可以直接从缓存中获取信息，从而提高访存速度，但由于缓存容量小，因此需不断地将主存的内容调入缓存，使缓存中原来的信息被替换；主存和缓存之间数据调动是由硬件自动完成的，对程序员透明</li></ul></li><li>主存-辅存层次（虚拟存储系统）利用局部性原理解决存储系统的容量问题，速度接近主存，容量和位价接近辅存 <ul><li>主存之外增加辅助存储器（磁盘、sd卡、U盘等）</li><li>辅存的速度比主存低，但是容量比主存大，可以暂时存放大量未用到的信息。当CPU需要用到这些信息时，将辅存的内容调入主存，供CPI直接访问。主存和辅存之间的数据调动是由硬件和操作系统共同完成的<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/345cff6c6aca5673b559d.png" alt="25.png"></li></ul></li></ul><h2 id="_4-5-主存储器" tabindex="-1"><a class="header-anchor" href="#_4-5-主存储器"><span>4.5. 主存储器</span></a></h2><figure><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/487b251954b6e04569b6e.png" alt="36.PNG" tabindex="0"><figcaption>36.PNG</figcaption></figure><ul><li>主存由半导体集成电路构成，驱动器、译码器和读写电路均制作于存储芯片中，而MAR和MDR制作在CPU芯片内。存储芯片和COU芯片可通过总线连接</li><li>根据MAR中的地址访问某个存储单元时，还需经过地址译码、驱动等电路，才能找到所需访问的单元。读出时需要经过读出放大器，才能将被选中的单元的存储字送到MDR。写入时，MDR中的数据也必须经过写入电路才囊真正写入到被选中的单元中</li><li>读写过程 <ul><li>当要从存储器读出某一信息字时，首先由CPU将该字的地址送到MAR。经地址总线送至主存，然后发出读命令。主存接到读命令后，得知需将该地址单元的内容读出，便完成读操作，将该单元的内容读至数据总线上，由CPU决定由MDR送到什么地方</li><li>当要向主存中存入一个信息字时，首先CPU将该字所在存储单元的地址经MAR送到地址总线，并将信息字送入MDR，然后向主存发出写命令，主存接到写命令后，便将数据线上的信息写入到对应地址先指出的主存单元中</li></ul></li><li>主存中存储单元地址的分配 <ul><li>主存各存储单元的空间位置是由单元地址号来表示的，而地址总线是用来指出存储单元地址号的，根据该地址可读出或写入一个存储字。计算机系统可以按字寻址，也可以按字节寻址</li></ul></li><li>存储体：由许多存储单元组成</li><li>存储单元：由许多存储元件组成,以8位二进制作为一个存储单元，也就是一个字节。存储单元有编号，这些编号称为存储单元的地址号。存储单元按地址寻访。这些地址都是二进制的形式。</li><li>存储元件：可以寄存一位二进制代码0/1</li><li>字/存储字/存储字长：一个存储单元存储的二进制代码组合/位数（8、16、32位），8位2进制数表示一个字节，因此存储字长取8的倍数，主要看计算机位数</li><li>字块：存储在连续的存储单元中而被看作是一个单元的一组字（包含多个字）</li><li>大小关系：存储体包括多个存储单元，一个存储单元包括多个存储元件，一个存储元件能寄存一位二进制码</li><li>字节地址：每个存储单元的地址。</li><li>字地址：一个存储字长的存储单元地址，可以是高位字节地址或者地位字节地址。一个字有n位（8、16、32位），一个字块共B个字，主存共M个字块，主存总字数 = B<em>M，主存总容量 = B</em>M*32（bits），字的地址：前m位指定字块的地址，后b位指定字在字块中的地址，则 2^m = M 、2^b=B</li><li>主存的技术指标 <ul><li>存储容量：主存能存放二进制代码的总位数/字节总数 <ul><li>存储容量 = 存储单元个数 x 存储字长 = 存储单元个数 x 存储字长 /8</li><li>地址线为n根，那么存储单元个数为2^n根</li></ul></li><li>存储速度：用存取时间和存取周期表示 <ul><li>存取时间(Memory Access Time)：启动一次存储器读/写操作到完成该操作所需的全部时间 <ul><li>读出时间：从存储器收到有效地址开始，到产生有效输出所需的全部时间</li><li>写入时间：从存储器收到有效地址开始，到数据写入被选中单元为止所需的全部时间</li></ul></li><li>存取周期(Memory Cycle Time)：存储器进行连续两次独立的存储器操作所需的最小时间间隔，通常存取周期大于存取时间</li></ul></li><li>存储器带宽：单位时间内存储器存取的信息量，单位用字/秒或字节/秒或单位/秒表示.提高存储带宽措施：缩短存取周期、增加存储字长、增加存储体</li></ul></li></ul><figure><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/6a4bdf735fe6b9defaff1.png" alt="46.PNG" tabindex="0"><figcaption>46.PNG</figcaption></figure><h2 id="_4-6-存储器的校验-汉明码" tabindex="-1"><a class="header-anchor" href="#_4-6-存储器的校验-汉明码"><span>4.6. 存储器的校验(汉明码)</span></a></h2><ul><li>汉明码：使用偶校验、分组校验，只有一位纠错能力 <ul><li>奇校验：这串序列1的个数如果为偶数则在前面加个1，使1的个数变成奇数，否则加0。</li><li>偶校验：这串序列1的个数如果为奇数则在前面加个1，使1的个数变成偶数，否则加0。</li><li>设需要检测的二进制代码为n位，添加K位检测位，组成n+k位的代码，</li><li>其中k满足：2^k &gt;= n+k+1</li><li>n+k位代码从左到右依次为1,2,3,4,5...,n+k位</li><li>校验位安插位置编号：1,2,4,8,...,2^(k-1)</li><li>分组依据：p1 xxx1 p2 xx1x p3 x1xx p4 1xxx，同一样格式的位数的数分成一组</li><li>检错依据：每组里面“1”的个数为偶数</li><li>出错位置: 分组从大到小从左到右排序，失败的组为1，成功的组为0，则组成的二进制数即为出错的位置</li></ul></li><li>举例：序列为1100 <ol><li>二进制代码为n=4位,根据2^k &gt;= n+k+1算出k=3</li><li>校验位安插位置为1,2,4三个位置</li><li>4+3位代码第1-7位从左到右依次为 x1,x2,1,x3,1,0,0 其中x1,x2,x3为需要添加的检测位，暂时没算出来是多少</li><li>将同样格式的第几位放一起分成三组：<br> 4.1 第一组(<strong>1)=&gt;第1,3,5,7(x1,1,1,0)位 1的个数为奇数，因此x1=0<br> 4.2 第二组(<em>1</em>)=&gt;第2,3,6,7(x2,1,0,0)位,1的个数为偶数，因此x2=1<br> 4.3 第三组(1</strong>)=&gt;第4,5,6,7(x3,1,0,0)位,1的个数为偶数，因此x3=1</li><li>得出最终数据0,1,1,1,0,0</li><li>出错位置:假如2和3组出错,将分组从大到小排列，则出错位数为第6位(二进制为110)</li></ol></li></ul><h2 id="_4-7-高速缓冲存储器" tabindex="-1"><a class="header-anchor" href="#_4-7-高速缓冲存储器"><span>4.7. 高速缓冲存储器</span></a></h2><ul><li>产生原因 <ul><li>由于I/O设备向主存请求的级别高于CPU访存，这就出现了CPU等待I/O设备访存的现象，致使CPU空等一段时间，甚至可能等待几个主存周期，从而降低了CPU的工作效率。为了避免CPU与I/O设备争抢访存，可在CPU与主存加一级缓存，主存可以将CPU要取的信息提前送至缓存。一旦主存在与I/O设备交换时，CPU可直接从缓存中读取所需信息，不必空等而影响效率。</li><li>为了解决主存与CPU速度不匹配的问题</li></ul></li><li>局部性原理：指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中</li><li>工作原理：任何时刻都有一些主存块在缓存块中，CPU读取主存某字时，若所需的字已在缓存中，即可直接访问Cache(CPU与Cache之间通常一次传送一个字) 缓存命中；若所需的字不在缓存中，需将该字所在的主存的整个字块一次调入缓存中（缓存与主存之间是字块传送）缓存不命中；如果主存块已调入缓存块，则称该主存块与缓存块建立了对应关系。</li><li>由于缓存的块数远小于主存的块数。因此，缓存块不能唯一地、永久地只对应一个主存块，故每个缓存快需设一个标记，用来表示当前存放的是哪一个主存块，该标记的内容相当于主存块的编号。CPU读信息时，要将主存地址的高m位（或m位中的一部分）与缓存块比较，判断所读信息是否已在缓存中</li><li>在一个程序执行期间，设Ne为访问Cache的总命中次数，Nm为访问主存的总次数，则命中率h=Ne/(Ne+Nm)</li><li>设tc为命中时Cache访问时间，tm为未命中时的主存访问时间，1-h表示未命中率，则Cache-主存系统的平均时间ta=htc+(1-h)tm，访问效率e = tc/ta x 100% = tc/(htc+(1-h)tm)x100%</li><li>Cache容量越大，其CPU命中率越高，当Cache到达一定值时，命中率已不因容量的增大而有明显的提高</li><li>块长与命中率关系：取决于各程序的局部特性，当块由小到大增长时，起初会因局部性原理使命中率有所提高，由局部性原理指出，在已被访问字的附近，近期也可能被访问，因此，增大块长，可将更多有用字存入缓存，提高命中率；当块继续增大时，命中率可能下降，因为装入缓存的有用数据反而少于被替换掉的有用数据。由于块长的增大，导致缓存中块数的减少，而新装入的块要覆盖旧块，很可能出现少数块刚刚装入就被覆盖，因此命中率反而下降。再者，块增大后，追加上的字距离已被访问的字更远，故近期被访问的可能性会更少</li></ul><h2 id="_4-8-缓存-主存地址映射方式-主存地址映射到cache地址称为地址映射" tabindex="-1"><a class="header-anchor" href="#_4-8-缓存-主存地址映射方式-主存地址映射到cache地址称为地址映射"><span>4.8. ？？？？缓存-主存地址映射方式（主存地址映射到Cache地址称为地址映射）</span></a></h2><pre><code>- 直接映射（固定的映射关系）
    - 设C为缓存块数，m为主存块数，i为缓存块号，j为主存块号，标记t = m-c C = 2^c
    - 映射关系 i = j mod C 或 i = j mod 2^c 即 缓存快C对应主存块C,2C,...,2^m
    - 每个缓存块 i 可以和若干个主存块对应，主存块号mod结果相同的都对应同一个缓存块号。每个主存块 j 只能和一个缓冲块对应
    - 先根据中间C位字段找到Cache字块号对应的字块，根据字块的“标记”是否与主存地址的高t位相符判断。若符合且有效位为“1”，表示该Cache块与主存模块建立了对应关系（命中）可根据b位地址从Cache中获得信息；若不符合或有效位为“0”(不命中)，则从主存读入新的字块来替代旧的字块，同时将信息送往CPU，并修改Cache“标记”。如果原来有效位为“0”，则改为“1”
    - 优点：实现简单，只需利用主存地址的某些位置直接判断，即可确定所需字块是否在缓存中
    - 缺点：不够灵活，每个主存块只能对应米一个缓存块，即使缓存内还空着许多位置也不能占用，缓存空间利用率低。如果程序恰好重复访问对应同一缓存位置的不同主存块，就要不停地替换，从而降低命中率
- 全相联映射（灵活性大的映射关系）
    - 将主存标记从t位增加到t+c位，访问Cache时主存字块标记需要和Cache全部标记进行比较，才能判断出所访问的主存地址是否存在
    - 允许主存中每一字块映射到Cache的任何一块位置上，可以从已被占满的Cache中替换出任一旧字块，
    - 灵活，命中率高，缩小了块冲突率;逻辑电路多，成本高，实际的Cache还要采用各种措施减少地址的比较次数
- 组相联映射（上述两种映射的折中）
    - 把Cache分为Q组，每组R块 主存块号mod结果相同的都对应同一组
    - 设i为缓存组号，j为主存块号 i = j mod Q
    - 当r = 0时是直接映射方式，当r = c时是全相联映射方式
</code></pre><p><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/82f12111d9760fa948119.png" alt="30.PNG"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/44ea13005fa8dace3b384.png" alt="31.PNG"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/5915ee0d665aa75dca8e8.png" alt="32.PNG"></p><h2 id="_4-9-替换策略" tabindex="-1"><a class="header-anchor" href="#_4-9-替换策略"><span>4.9. 替换策略</span></a></h2><ul><li>替换时机：当新的主存块需要调入Cache并且可用空闲位置又被占满，需要替换数据</li><li>随机算法：可采用一个随机数产生器产生一个随机被替换的块，没有局部性原理，不能提高缓存命中率</li><li>先进先出算法（FIFO）优先替换最先进入队列的字块，淘汰最先进入队列的字块；容易实现，开销小，没有使用访存的局部性原理，不能提高缓存命中率</li><li>最近最少使用算法（Least Recently Used,LRU）：优先淘汰一段时间内没有使用的字块。一般只记录每个块最近一次使用的时间。利用访存局部性原理，平均命中率比FIFO高。一般使用双向链表实现。把当前访问节点置于链表前面（保证链表头部节点是最近使用的）</li></ul><h2 id="_4-10-辅助存储器" tabindex="-1"><a class="header-anchor" href="#_4-10-辅助存储器"><span>4.10. 辅助存储器</span></a></h2><ul><li>辅存具有容量大、速度慢、价格低、可脱机保存信息等特点，属&quot;非易失性&quot;存储器</li><li>主存具有速度快、成本高、容量小等特点，而大多数由半导体芯片构成，所存信息无法永久保存，属&quot;易失性&quot;存储器</li><li>辅存存储器有硬磁盘、软磁盘、磁带、光盘等，前三种属于磁表面存储器</li><li>磁表面存储器的主要技术指标 <ul><li>记录密度：单位长度内所存储的二进制信息量</li><li>存储容量：外存所能存储的二进制信息总数量，一般以位或字节为单位</li><li>平均寻址时间</li><li>数据传输率：单位时间内磁存储器向主机传送数据的位数或字节数</li><li>误码率：衡量磁表面存储器出错概率的参数，等于从辅存读出时，出错信息位数和读出信息的总位数之比。为了纠正出错率，通常采用循环冗余码发现并纠正错误</li></ul></li><li>辅助存储器-磁盘（硬盘） <ul><li>表面是可磁化的硬磁性特性材料。- 移动磁头径向运动读取磁道信息</li><li>磁盘寻道算法： <ul><li>先来先服务算法：按顺序访问进程的磁道读写需求</li><li>最短寻道时间优先：与磁头当前位置有关、优先访问离磁头最近的磁道</li><li>扫描算法（电梯算法）：每次只往一个方向移动、到达一个方向需要服务的尽头再反方向移动</li><li>循环扫描算法：只往一个方向移动，由内往外或由外往内读取<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/af1be3f8a5a19f9738e5b.png" alt="43.PNG"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/8fd497485ec44bca2765a.png" alt="42.PNG"></li></ul></li></ul></li></ul><h1 id="_5-输入输出系统" tabindex="-1"><a class="header-anchor" href="#_5-输入输出系统"><span>5. 输入输出系统</span></a></h1><h2 id="_5-1-输入输出系统发展概况" tabindex="-1"><a class="header-anchor" href="#_5-1-输入输出系统发展概况"><span>5.1. 输入输出系统发展概况</span></a></h2><ul><li>早期阶段：I/O设备与主存交换信息都必须通过CPU</li><li>接口模块和DMA阶段： <ul><li>I/O设备通过接口模块与主机连接，计算机系统采用了总线结构，接口中通常设有数据通路和控制通路，数据经过接口既起到缓冲作用，又可完成串-并变换</li><li>控制通路用以传送CPU向I/O设备发出的各种控制命令，或使CPU接受来自I/O设备的反馈信号</li><li>为了进一步提高CPU工作效率，出现了直接存储器存取（Direct Memory Access,DMA）技术，I/O设备与主存之间有一条直接数据通路，I/O设备可以与主存直接交换信息，使CPU在I/O设备与主存交换信息时能继续完成自身的工作，资源利用率得到了进一步提高</li></ul></li><li>通道结构的阶段 <ul><li>对于大型计算机，DMA方式随着I/O设备增加而增加了硬件成本，还导致访问主存的冲突问题</li><li>CPU还需要对众多DMA接口管理，占用CPU时间，频繁进入周期挪用周期，影响CPU工作效率</li><li>在大中型计算机系统中，采用I/O通道的方式进行数据交换</li><li>通道是用来负责管理I/O设备以及实现主存与I/O设备之间交换信息的部件，可以视为一种具有特殊功能的处理器，具有专用的通道指令，能独立执行通道指令所编写的输入输出程序，但不是一个完全独立的处理器</li></ul></li><li>I/O处理机阶段 <ul><li>I/O处理机独立于主机工作，可完成I/O控制、码制转换、格式处理、数据块检错、纠错等操作，并行性更高</li></ul></li></ul><h2 id="_5-2-输入输出系统的组成" tabindex="-1"><a class="header-anchor" href="#_5-2-输入输出系统的组成"><span>5.2. 输入输出系统的组成</span></a></h2><ul><li>I/O软件 <ul><li>将用户编制的程序（或数据）输入主机内</li><li>将运算结果输送给用户</li><li>实现输入输出系统与主机工作的协调等</li></ul></li><li>I/O指令 <ul><li>操作码：与其他指令的判别代码</li><li>命令码：体现I/O设备的具体操作 <ul><li>将数据从I/O设备输入主机</li><li>将数据从主机输出到I/O设备</li><li>状态测试</li><li>形成某些操作指令，与不同I/O设备交换信息要完成不同的操作</li><li>设备码：多台I/O设备的选择码</li></ul></li></ul></li><li>通道指令：对具有I/O通道的系统专门设置的指令 <ul><li>指明参与传送（写入或读取）的数据组在主存中的首地址</li><li>指明需要传送的字节数或所传送数据组的末地址</li><li>指明所选设备的设备码及完成某种操作的命令码</li></ul></li><li>I/O硬件</li></ul><h2 id="_5-3-i-o设备与主机的联系方式" tabindex="-1"><a class="header-anchor" href="#_5-3-i-o设备与主机的联系方式"><span>5.3. I/O设备与主机的联系方式</span></a></h2><ul><li>I/O设备编址方式(I/O设备码看作地址码) <ul><li>统一编址：将I/O地址看作存储器地址的一部分。占用主存容量，但无需专用的I/O指令</li><li>不统一编址：将I/O地址和存储器地址分开，对I/O设备的访问必须有专用的I/O指令。不占用主存容量，但需设I/O专用指令</li><li>当设备通过接口和主机相连时，CPU可以通过接口地址来访问I/O设备</li></ul></li><li>设备编址：每台设备赋予一个设备号，当需要启动设备时，可由I/O指令的设备码字段直接指出该设备的设备号。通过接口电路中的设备选择电路，便可选中要交换信息的设备</li><li>传送方式（需配置不同的接口电路） <ul><li>并行传送：在同一瞬间，n位信息同时从CPU输出值I/O设备，或由I/O设备输入到CPU，传送速度较快，要求数据线多</li><li>串行传送（远距离通信）：在同一瞬间只传送一位信息，在不同时刻连续逐为传送一串信息。传送速度慢，只需一根数据线和一根地线</li></ul></li><li>联络方式：I/O设备与主机之间相互了解彼此所处的状态 <ul><li>立即响应方式：工作速度十分缓慢的I/O设备</li><li>异步工作采用应答信号联络：当I/O设备与主机工作速度不匹配，一方数据准备好了才通知另外一方取数据</li><li>同步工作采用同步时标联络：需要配置专用电路，用以产生同步时标来控制同步工作</li></ul></li><li>连接方式 <ul><li>辐射式：每台I/O设备都有一套控制线路和一组信号线，所用器件和连线较多，对I/O设备的增删都比较困难</li><li>总线式（现代计算机）：通过一组总线（地址先、数据线、控制线等），将所有的I/O设备和主机连接</li></ul></li></ul><h2 id="_5-4-i-o设备与主机信息传送的控制方式" tabindex="-1"><a class="header-anchor" href="#_5-4-i-o设备与主机信息传送的控制方式"><span>5.4. I/O设备与主机信息传送的控制方式</span></a></h2><ul><li>程序查询方式(轮询) <ul><li>由CPU不断查询I/O设备是否已做好准备，从而控制I/O设备与主机交换信息</li><li>要求I/O接口内设置一个能反映I/O设备是否准备就绪的状态标记，CPU通过对此标记的检测，可得知I/O设备的准备情况</li><li>使CPU和I/O设备处于串行工作状态，CPU工作效率不高</li></ul></li><li>程序中断方式 <ul><li>当I/O设备准备就绪并向CPU发出中断请求后才予以响应，大大提高CPU的工作效率</li><li>CPU和I/O接口不仅在硬件方面需增加相应的电路，而在软件方面还必须编制中断服务程序</li><li>CPU有专门的电路响应中断信号，将当前工作暂停， 做IO设备的工作，做完再继续做当前工作</li><li>提供低速设备通知CPU的一种异步的方式，CPU可以高速运转的同时兼顾低速设备的响应</li></ul></li><li>DMA方式（I/O设备直接与主存交换信息）（硬盘和外置显卡） <ul><li>DMA方式中，主存与I/O设备之间有一条数据通路，主存与I/O设备交换信息时，无须调用中断服务程序，可以提高CPU效率。若出现DMA和CPU同时访问主存，CPU总线总是将占有权让给DMA，通常把DMA这种占有称为窃取或挪用。窃取的时间一般为一个存取周期，故又把DMA占用存取周期称为窃取周期/挪用周期。而且在DMA窃取存取周期时，CPU能继续作内部操作（如乘法运算）</li><li>需要增加必要的接口电路</li><li>程序中断和DMA都是计算机IO和低速设备的交互方式，程序中断方式实现简单，DMA方式效率更高</li></ul></li><li>I/O通道方式</li><li>I/O处理机方式</li></ul><h2 id="_5-5-i-o接口" tabindex="-1"><a class="header-anchor" href="#_5-5-i-o接口"><span>5.5. I/O接口</span></a></h2><ul><li>I/O接口：主机与I/O设备之间设置的一个硬件电路机器相应的软件控制</li><li>设置原因 <ul><li>一台机器通常配有多台I/O设备，各自有设备号，通过接口可实现I/O设备的选择</li><li>I/O设备种类繁多，速度不一，与CPU速度相差可能很大，通过接口可实现数据缓冲，达到速度匹配</li><li>有些设备可能串行、可能并行传送，通过接口可实现</li><li>可实现电平转换</li><li>可传送控制命令</li><li>可通过接口监视设备的工作状态，供CPU查询</li></ul></li><li>端口：指接口电路中的一些寄存器，分别用来存放数据信息，控制信息和状态信息，相应的端口分别称为数据端口、控制端口、和状态端口。若干个端口加上相应的控制逻辑才能组成接口。</li></ul><h2 id="_5-6-接口的功能和组成" tabindex="-1"><a class="header-anchor" href="#_5-6-接口的功能和组成"><span>5.6. 接口的功能和组成</span></a></h2><ul><li>总线连接方式的I/O接口电路：其中I/O总线包括 <ul><li>数据线：I/O设备与主机之间数据代码的传送线，其根数一般等于存储字长的位数或字符的位数</li><li>设备选择线：主机选择IO设备进行操作的信号线，对连在总线上的设备进行选择。传送设备码，根数取决于I/O指令中设备码的位数</li><li>命令线：传输CPU向I/O设备发出的各种命令信号，如启动、清除、屏蔽、读、写等，一组单向总线，根数与命令信号多少有关</li><li>状态线：将I/O设备的状态向主机报告的信号线，一组单向总线。查询设备是否已经正常连接并就绪，查询设备是否已经被占用</li></ul></li><li>接口的功能和组成 <ul><li>选址功能</li><li>传送命令的功能：设有命令寄存器（存放I/O指令中的命令码。受设选中信号控制）和命令译码器</li><li>传送数据的功能（缓冲能力）设有数据缓冲寄存器，暂存I/O设备与主机准备交换的信息</li><li>反映I/O设备工作状态的功能（中断请求触发器，屏蔽触发器MASK）</li></ul></li><li>接口类型 <ul><li>按数据传送方式：并行接口。串行接口</li><li>按功能选择的灵活性分类：可编程接口，不可编程接口</li><li>按通用性分类：通用接口，专用接口</li><li>按数据传送的控制方式：程序型接口(连接速度较慢的设备)，DMA型接口</li></ul></li></ul><h2 id="_5-7-程序中断方式" tabindex="-1"><a class="header-anchor" href="#_5-7-程序中断方式"><span>5.7. 程序中断方式</span></a></h2><ul><li>中断：计算机在执行程序的过程中，当出现异常情况或特殊请求时，计算机停止现行程序的运行、转向对这些异常情况或特殊请求的处理，处理结束后在返回到现行程序的间断处，继续执行原程序</li><li>中断技术引入原因：适应I/O设备工作速度低的问题，提高计算机整机效率。实时控制的需要</li></ul><h2 id="_5-8-中断服务程序的流程" tabindex="-1"><a class="header-anchor" href="#_5-8-中断服务程序的流程"><span>5.8. 中断服务程序的流程</span></a></h2><ul><li>中断服务程序的流程 <ul><li>保护现场 <ul><li>保存程序断点，由中断隐指令完成</li><li>保存状态寄存器的内容，由中断服务程序完成</li></ul></li><li>中断服务（设备服务）</li><li>恢复现场：要求在退出中断服务程序之前，将程序中断时的“现场”恢复到原来的寄存器中</li><li>中断返回：中断服务程序的最后一条指令，使其返回到原程序的断点处，以便继续执行原程序</li></ul></li><li>多重中断：计算机在处理中断的过程中，有可能出现新的中断请求，如果CPU暂停现行的中断服务程序，转去处理新的中断请求，这种现象称为中断嵌套</li><li>单重中断：CPU在执行中断服务程序时，对新的中断请求不予理睬</li><li>两者区别：开中断在保护现场后面<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/c2fcdb7566ae66cd532a2.png" alt="37.PNG"></li></ul><h2 id="_5-9-dma方式" tabindex="-1"><a class="header-anchor" href="#_5-9-dma方式"><span>5.9. DMA方式</span></a></h2><ul><li>DMA与主存交换数据使采用的方法 <ul><li>停止CPU访问主存 <ul><li>当外设要传送一批数据时，由DMA接口向CPU发一个停止信号，要求CPU放弃地址线、数据线和有关控制线的使用权</li><li>控制简单，适用于数据传输率很高的I/O设备实现成组数据的传送</li><li>缺点是DMA接口在访问主存时，CPU基本上处于不工作状态或保持原状态</li><li>而且即使I/O设备高速运行，两个数据之间的准备间隔时间也总大于一个存取周期</li><li>因此，CPU对主存的利用率并没得到充分的发挥</li></ul></li><li>周期挪用（广泛使用） <ul><li>每当I/O设备发出DMA请求时，I/O设备便挪用或窃取总线占用全一个或几个主存周期</li><li>I/O设备每挪用一个主存周期都要申请总线控制权，建立总线控制权和归还总线控制权</li><li>尽管传输一个字对主存而言只占用一个主存周期，但对DMA接口而言，实质上要占2-5个主存周期（由逻辑线路的延迟特性而定），适用于I/O设备读写周期大于主存周期的情况</li></ul></li><li>DMA与CPU交替访问 <ul><li>适合CPU工作周期比主存存取周期长的情况</li><li>不需要总线使用权的申请、建立和归还过程</li><li>CPU不停止主程序运行，不等待，也完成了DMA数据传送</li><li>硬件逻辑复杂</li></ul></li></ul></li><li>DMA接口的功能和组成 <ul><li>向CPU申请DMA传送</li><li>在CPU允许DMA工作时，处理总线控制权的转交</li><li>在DMA期间管理系统总线，控制数据传送</li><li>确定和修成数据传送的起始地址和数据长度，修正数据传送过程中的数据地址和数据长度</li><li>在数据块传送结束时，给出DMA操作完成的信号</li></ul></li><li>DMA特点 <ul><li>从数据传送看，程序中断方式靠程序传送，DMA方式靠硬件传送</li><li>从CPU响应时间看，程序中断在一条指令执行结束时响应，而DMA方式可在指令周期内任意存取周期结束时响应</li><li>程序中断方式有处理异常时间能力，DMA没有，主要用于大批数据的传送</li><li>程序中断方式需要中断现行程序，故需保护现场，DMA不需要</li><li>DMA优先级比程序中断高</li></ul></li></ul><h1 id="_6-计算机的运算方法" tabindex="-1"><a class="header-anchor" href="#_6-计算机的运算方法"><span>6. 计算机的运算方法</span></a></h1><h2 id="_6-1-进制的概述" tabindex="-1"><a class="header-anchor" href="#_6-1-进制的概述"><span>6.1. 进制的概述</span></a></h2><ul><li>常见进制：二进制、十进制、八进制、十六进制（网卡mac地址）、六十进制（时钟）</li><li>二进制运算基础 <ul><li>任何进制表示 N = dn * r^n-1 +...+ d1 * r^1 + d0</li><li>二进制整数转十进制（按权展开法）N = (01100101) = 1 * 2^6 + 1 * 2^5 + 1*2^2 + 1 = 101</li><li>十进制整数转二进制（重复相除法）N = (01100101) = 1 * 2^6 + 1 * 2^5 + 1*2^2 + 1 = 101<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/90a2e411c0c74485b9e47.png" alt="38.PNG"></li><li>二进制小数转十进制（按权展开法）N = （0.11001） = 1 * 2^-1 + 1 *2 ^-2 + 1 * 2^-5 - 0.78125 = 25/32</li><li>十进制小数转二进制（重复相乘法）N = （0.11001） = 1 * 2^-1 + 1 *2 ^-2 + 1 * 2^-5 - 0.78125 = 25/32<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/33fabec9c0a874b4f5b92.png" alt="39.PNG"></li></ul></li></ul><h2 id="_6-2-计算机中的数" tabindex="-1"><a class="header-anchor" href="#_6-2-计算机中的数"><span>6.2. 计算机中的数</span></a></h2><ul><li>计算机中的数均放在寄存器中，通常寄存器的位数为机器字长。</li><li>参与运算的数 <ul><li>无符号数：没有符号的数，在寄存器中的每一位都可用来存放数值</li><li>有符号数：需流出位置存放符号</li></ul></li><li>原码表示法 <ul><li>最左边符号位使用0表示正数、1表示负数,用逗号将符号位和数值隔开，用小数点将小数的符号位和数值隔开</li><li>0有两种表示方法：00、10</li></ul></li><li>补码表示法 <ul><li>原码进行运算非常复杂，特别是两个操作数符号不同的时候，需要判断两个操作数绝对值大小，使用绝对值大的数减去绝对值小的数，对于符号值、以绝对值大的为准；希望找到不同符号操作数更加简单的运算方法；希望找到使用正数代替负数的方法；使用加法操作代替减法操作，从而消除减法</li><li>正数的补码是本身，负数的补码是原码基础上符号位不变，其余各位取反后加1（反码+1）</li></ul></li><li>反码表示法 <ul><li>反码的目的是找出源码和补码之间的规律、消除转换过程中的减法</li><li>反码中的0也有2种表达方式</li><li>正数的反码是本身，负数的反码是原码基础上符号位不变，其余各位取反</li></ul></li></ul><h2 id="_6-3-数的定点表示和浮点表示" tabindex="-1"><a class="header-anchor" href="#_6-3-数的定点表示和浮点表示"><span>6.3. 数的定点表示和浮点表示</span></a></h2><ul><li>小数点的表示方法 <ul><li>定点表示（纯小数、纯整数）：定点表示数称为定点数。小数点固定在某个位置的数称为定点数</li><li>浮点表示，浮点表示的数称为浮点数：计算机处理的很大程度上不是纯小数或纯整数。数据范围很大，定点数难以表达。</li></ul></li><li>浮点数的表示形式（科学计数法） <ul><li>123450000000 = 1.2345x10^11（尾数：1.2345、基数：10、阶码：11）</li><li>N = S * r^j （尾数：s（规定使用纯小数） 基数：r （2,4,8,16）阶码：j）</li><li>阶码符号位、阶码数值位、尾数符号位、尾数数值位</li><li>尾数位数n反应浮点数精度，阶符和阶码位数m合起来反应浮点数的表示范围和实际位置</li><li>尾数规定使用纯小数，将尾数最高位为1的浮点数称为规格化数 ，其精度最高，为了提高精度必须规格化</li><li>基数r越大，可表示的浮点数范围越大，表示的数的个数越多，但精度反而下降</li></ul></li><li>浮点数的表示范围 <ul><li>假设阶码数值取m位，尾数数值取n位</li><li>阶码范围：[-(2^m - 1),2^m - 1]</li><li>尾数范围：[-(1-2^-n),-(2^-n)] [2^-n,1-2^-n]</li><li>当浮点数阶码大于最大阶码称为上溢，小于最小阶码是称为下溢<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/c3af2d2b57a8f8b280ff6.png" alt="40.PNG"><br> 单精度浮点数：使用4字节、32位来表达浮点数<br> 双精度浮点数：使用8字节、64位来表达浮点数</li></ul></li><li>定点数和浮点数的对比 <ul><li>当定点数与浮点数位数相同时，浮点数表示的范围更大</li><li>当浮点数位数为规格化数时，浮点数的相对精度更高</li><li>浮点数运算包含阶码和尾数，运算结果要求规格化，故浮点数运算步骤多，浮点数的运算更为复杂</li><li>在溢出的判断方法上，浮点数是对规格化数的阶码进行判断，定点数是对数值本身进行判断</li><li>浮点数在数的表示范围、精度、溢出处理、编程等当面均优于定点数</li><li>浮点数在数的运算规则、运算速度、硬件成本方面不如定点数</li></ul></li></ul><h2 id="_6-4-定点数的加减法" tabindex="-1"><a class="header-anchor" href="#_6-4-定点数的加减法"><span>6.4. 定点数的加减法</span></a></h2><ul><li>整数加法：[A]补 + [B]补 = [A+B]补（mod2^n+1）</li><li>小数加法：[A]补 + [B]补 = [A+B]补（mod2）</li><li>整数减法：[A-B]补 = [A]补 + [-B]补（mod2^n+1）-&gt;[-B]补 = [B]补 连同符号位按位取反,末位+1</li><li>小数减法：[A-B]补 = [A]补 + [-B]补（mod2）-&gt;[-B]补 = [B]补 连同符号位按位取反,末位+1</li><li>数值位与符号位一同运算，并将符号位产生的进位自然丢掉</li><li>判断溢出： <ul><li>一位符号判断溢出：无论加法还是减法，只要实际参加操作的两个数符号相同，结果又与原操作数不同，即为溢出，为了节省时间，通常用符号位产生的进位与最高有效位产生的进位亦或操作后，结果为1表示溢出，否则无溢出</li><li>双符号位判断法：单符号为表示变成双符号位：0=&gt;00,i=&gt;11，双符号位产生的进位丢弃，结果的双符号为不同则表示溢出。01正溢出，10负溢出</li></ul></li></ul><h2 id="_6-5-定点数乘法运算" tabindex="-1"><a class="header-anchor" href="#_6-5-定点数乘法运算"><span>6.5. 定点数乘法运算</span></a></h2><ul><li>乘法运算可用移位和加法实现</li><li>由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积；同时，乘数也右移一位，由次低位作新的末位，空出最高位放部分积的最低位。</li><li>每次做加法时，被乘数仅仅与原部分积的高位相加，其低位被移至乘数所空出的高位位置。<br> 例2.X=0.0010，Y=-0.1101，XY=？<br> 被乘数A=|X|=00.0010,乘数B=|Y|=0.1101<br> 1.B的末位是1,A需要加B,得到00.0000+00.0010=00.0010,右移一位得到00.0001(部分积),B右移一位得到10.110<br> 2.B的末位是0,A需要加B,得到00.0001+00.0000=00.0001,右移一位得到00.0000(部分积),B右移一位得到110.11<br> 3.B的末位是1,A需要加B,得到00.0000+00.0010=00.0010,右移一位得到00.0001(部分积),B右移一位得到1110.1<br> 4.B的末位是1,A需要加B,得到00.0001+00.0010=00.0011,右移一位得到00.0001(部分积),B右移一位得到11110<br> 5.最后结果1.00011010。（对于结果正负，只需将X,Y两个数符号位做异或。同号为正，异号为负）</li></ul><h2 id="_6-6-定点数除法运算" tabindex="-1"><a class="header-anchor" href="#_6-6-定点数除法运算"><span>6.6. 定点数除法运算</span></a></h2><h2 id="_6-7-浮点数的加减法" tabindex="-1"><a class="header-anchor" href="#_6-7-浮点数的加减法"><span>6.7. 浮点数的加减法</span></a></h2><pre><code>    对阶-&gt;尾数求和-&gt;尾数规格化-&gt;舍入-&gt;溢出判断
        x = 0.1101 x 2^01 ,y = -0.1010 x 2^11 计算x+y
    对阶：
        阶码按小阶对齐大阶的原则
        对阶的目的是使得两个浮点数阶码一致，使得尾数可以进行运算
        对阶后 0.1101 x 2^01 -&gt; 0.001101 x 2^11
    尾数求和
        使用补码进行小数的加减法，使用双符号位
        [x]原 = 00.0011 [x]补 = 00.0011
        [y]原 = 11.1010 [y]补 = 11,0110
        S = [x+y]补 = 11.1001（进位mod2消掉）
    尾数规格化
        [S]补 = 00.1xxxxxx（S&gt;0）
        [S]补 = 11.0xxxxxx（S&lt;0）
        左规：00.0xxxxx 或11.1xxx尾数左移，阶码加 即:若符号位与最高位不一致,需要进行左规，
        右规：01.0xxxxx 或10.xxx尾数右移，阶码减 即:符号位不一致则右规
        11.1001不满足-&gt;(1)11.001(0)左移-&gt;11.0010
    舍入
        当右规时，才需要舍入，因为右规尾数低位丢失，引起误差，丢失精度，使用舍入提高精度
        0舍1入：被移去的最高位为1则末位+1，否则不变
</code></pre><p><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/c1bdf6abd172a57c4efc4.png" alt="40.PNG"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/323d182b0822f749168e4.png" alt="41.PNG"><br> 溢出：<br> 定点运算符号位不一致为溢出<br> 浮点运算尾数双符号位不一致不算溢出，因为尾数双符号可以进行右规<br> 浮点运算主要通过阶码的双符号位判断是否溢出<br> 如果规格化后，阶码双符号位不一致，则认为是溢出<br> [x]补 = 01,xxxx上溢<br> [x]补 = 10,xxxx下溢,按机器零处理</p><p><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/5bdcb2ff68d462511f3f0.png" alt="42.PNG"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/568bc0addc5c68dec5d3d.png" alt="43.PNG"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/ad871a13df917034af41e.png" alt="44.PNG"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/dfc2d9cbbb8d81d234162.png" alt="45.PNG"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/d3ed7d3f2499664d185bc.png" alt="46.PNG"><br> 浮点数的乘除法运算<br> 乘法：阶码相加，尾数求积<br> 除法：阶码相减，尾数求商<br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/c23719ed84b26b05301b9.png" alt="49.PNG"><br><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/99223cfe689840a5b62dc.png" alt="50.PNG"></p><h1 id="_7-指令系统" tabindex="-1"><a class="header-anchor" href="#_7-指令系统"><span>7. 指令系统</span></a></h1><h2 id="_7-1-机器指令" tabindex="-1"><a class="header-anchor" href="#_7-1-机器指令"><span>7.1. 机器指令</span></a></h2><ul><li>机器指令:每一条机器语言称为机器指令</li><li>指令系统:全部机器指令的集合、机器的指令系统集中反映了机器的功能</li><li>指令是由操作码和地址码组成 <ul><li>操作码：指明指令要完成的操作，位数反映了机器的操作种类（机器允许的指令条数）。如操作码占7位，则该机器最多包含2^7=128条指令</li><li>地址码：指出该指令的源操作数的地址（一个或两个）、结果的地址以及下一条指令的地址、地址包括主存、寄存器、I/O设备的地址</li></ul></li><li>四地址指令：包括OP操作码，A1第一操作数地址、A2第二操作数地址、A3结果地址、A4下一条指令地址。完成(A1)OP(A2)-&gt;A3操作</li><li>三地址指令：包括OP操作码，A1第一操作数地址、A2第二操作数地址、A3结果地址，完成(A1)OP(A2)-&gt;A3操作，后续指令的地址隐含在程序计数器PC中</li><li>二地址指令：包括OP操作码，完成(A1)OP(A2)-&gt;A1操作，此时A1字段既代表操作数的地址，又代表存放本次结果的地址.或者完成(A1)OP(A2)-&gt;A1操作，此时A2除了代表源操作数的地址外，还代表中间结果的存放地址</li><li>一地址指令：包括OP操作码，ACC既存放参与运算的操作数，又存放运算的中间结果。完成(ACC)OP(A1)-&gt;ACC操作、完成一条一地址指令只需两次访存</li><li>零地址指令：包括无地址码，如空操作（NOP）、停机（HLT）这类指令只有操作码。子程序返回（RET）、中断返回（IRET）这类指令没有地址码</li><li>指令字长：指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数</li></ul><h2 id="_7-2-操作数类型" tabindex="-1"><a class="header-anchor" href="#_7-2-操作数类型"><span>7.2. 操作数类型</span></a></h2><ul><li>地址：地址可被认为是一个无符号的整数</li><li>数字：计算机常见的数字有定点数、浮点数和十进制数</li><li>字符：ASCII码，重要的字符编码</li><li>逻辑数据：逻辑运算时，n个0和1的组合不是被看做算术数字而是被看做逻辑数</li></ul><h2 id="_7-3-操作类型" tabindex="-1"><a class="header-anchor" href="#_7-3-操作类型"><span>7.3. 操作类型</span></a></h2><ul><li>数据传送：包括寄存器与寄存器、寄存器与算术单元、存储单元与存储单元之间的传送。数据对接、交换地址数据、清零置一等操作</li><li>算术逻辑操作：算术运算（操作数之间的加减乘除运算）和逻辑运算（与，非，或，异或）</li><li>移位：算术移位、逻辑移位和循环移位。移位操作时间比乘除操作执行时间短，移位操作经常被用来代替简单的乘法和除法运算。数据左移（乘2）、数据右移（除2）</li><li>转移：改变计算机程序执行指令顺序 <ul><li>无条件转移</li><li>条件转移：根据当前指令的执行结果决定是否需要转移</li><li>调用与返回 <ul><li>调用指令包括过程调用、系统调用和子程序调用。实现一个程序转移到另一个程序的操作</li><li>调用指令（CALL）一般与返回（RETURN）指令配合使用.call 用于当前的程序位置转至子程序的入口，return用于子程序执行完后重新回到原程序的断点</li></ul></li></ul></li><li>陷阱与陷阱指令：陷阱其实是一种意外事故的中断，一旦出现意外故障，计算机发出陷阱信号，暂停当前程序的执行，转入故障处理程序进行相应故障处理</li><li>输入输出：对于I/O单独编址的计算机，设有输入输出指令</li><li>其他：等待指令、停机指令、空操作指令、开中断指令、关中断指令、置条件码指令等</li><li>数据在存储器中的存放方式：计算机中的数据存放在存储器或寄存器中，而寄存器的位数便可反应机器字长</li></ul><h2 id="_7-4-寻址方式" tabindex="-1"><a class="header-anchor" href="#_7-4-寻址方式"><span>7.4. 寻址方式</span></a></h2><ul><li>寻址方式是指定本指令的数据地址以及下一条将要执行的指令地址的方法</li><li>指令寻址 <ul><li>顺序寻址（通过程序计数器PC加1自动形成下一条指令的地址实现）</li><li>跳跃寻址（通过转移类指令实现）</li></ul></li><li>数据寻址：地址指令包括操作码、寻址特征、形式地址A。操作数的真实地址称为有效地址记为EA <ul><li>立即寻址：操作数本身在指令字内，数据采用补码形式存放。形式地址A是操作数本身。执行阶段无需访存（速度快，地址码位数限制操作数表示范围）</li><li>直接寻址：指令字中的形式地址A就是操作数的真实地址EA。执行阶段访存一次（寻找操作数简单，地址码位数限制操作数表示范围）</li><li>隐含寻址：指令中操作数的地址，隐含在操作码或某个寄存器中</li><li>间接寻址：形式地址指出操作数有效地址所在的存储单元地址。便于编址程序，扩大了操作数的寻址范围，需要访存多次，使指令执行时间延长（操作数寻址范围大，速度慢）</li><li>寄存器寻址：地址码字段直接指出寄存器的编号，无需访存，减少执行寻址</li><li>寄存器间接寻址：地址码字段直接指出操作数所在主存的地址号，指令执行阶段需要访问主存</li><li>基址寻址：设有基址寄存器BR，操作数的有效地址EA等于指令字中的形式地址和基址寄存器中的内容相加。扩大操作数的寻址范围</li><li>变址寻址：设有变址寄存器IX，操作数的有效地址EA等于指令字中的形式地址和变址寄存器中的内容相加</li><li>相对寻址：有效地址将程序计数器PC与指令字中的形式地址A相加而成，常用于转移类指令</li><li>堆栈寻址：用寄存器组实现或主存一部分空间作堆栈</li></ul></li></ul><h1 id="_8-cpu的结构和功能" tabindex="-1"><a class="header-anchor" href="#_8-cpu的结构和功能"><span>8. CPU的结构和功能</span></a></h1><h2 id="_8-1-控制器的基本功能" tabindex="-1"><a class="header-anchor" href="#_8-1-控制器的基本功能"><span>8.1. 控制器的基本功能</span></a></h2><ul><li>取指令:控制器能自动形成指令的地址，并能发出取指令的命令，将对应的指令取到控制器中</li><li>分析指令:分析指令要完成什么操作，分析参与这次操作的操作数地址</li><li>执行指令:根据分析指令产生的操作命令和操作地址的要求，形成操作控制信号序列，通过对运算器、存储器以及I/O设备的操作，执行每条指令</li><li>控制程序的输入和运算结果的输出以及对总线的管理</li><li>中断处理：处理机器运行过程中出现的异常情况和特殊请求</li></ul><h2 id="_8-2-cpu结构框图" tabindex="-1"><a class="header-anchor" href="#_8-2-cpu结构框图"><span>8.2. CPU结构框图</span></a></h2><figure><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/aa2e9cd7508dd7187ca80.png" alt="41.PNG" tabindex="0"><figcaption>41.PNG</figcaption></figure><h1 id="_9-计算机的控制器" tabindex="-1"><a class="header-anchor" href="#_9-计算机的控制器"><span>9. 计算机的控制器</span></a></h1><figure><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/955a2f2ec34e75b115ff2.png" alt="44.PNG" tabindex="0"><figcaption>44.PNG</figcaption></figure><ul><li>程序计数器： <ul><li>用来存储下一条指令的地址</li><li>循环从程序计数器中拿出指令</li><li>当指令被拿出时，指向下一条指令</li></ul></li><li>时序发生器 <ul><li>电气工程领域，用于发送时序脉冲</li><li>CPU根据不同的时序脉冲有节奏的进行工作（节拍器）</li></ul></li><li>指令译码器 <ul><li>指令译码器是控制器的主要部件之一</li><li>计算机指令由操作码和地址码组成</li><li>翻译操作码对应的操作以及控制传输地址码对应的数据</li></ul></li><li>指令寄存器 <ul><li>指令寄存器也是控制器的主要部件之一</li><li>从主存或高速缓存取计算机指令</li></ul></li><li>主存地址寄存器 <ul><li>保存当前CPU正要访问的内存单元的地址</li></ul></li><li>主存数据寄存器 <ul><li>保存当前CPU正要读或写的主存数据</li></ul></li><li>通用寄存器 <ul><li>用于暂时存放或传送数据或指令</li><li>可保存ALU的运算中间结果</li><li>容量比一般专用寄存器大</li></ul></li></ul><h1 id="_10-计算机的运算器" tabindex="-1"><a class="header-anchor" href="#_10-计算机的运算器"><span>10. 计算机的运算器</span></a></h1><figure><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/c4f2c2c4bf4893ccfc6e9.png" alt="45.PNG" tabindex="0"><figcaption>45.PNG</figcaption></figure><ul><li>数据缓存器 <ul><li>分为输入缓冲和输出缓冲</li><li>输入缓冲暂时存放外设送过来的数据</li><li>输出缓存暂时存放送往外设的数据</li></ul></li><li>ALU <ul><li>ALU 算术逻辑单元、运算器的主要组成</li><li>常见的位运算（左右移、与或非等）</li><li>算术运算（加减乘除）</li></ul></li><li>状态字寄存器 <ul><li>存放运算状态（条件码、进位、溢出、结果正负等）</li><li>存放运算控制信息（调试跟踪标记位、允许中断位等）</li></ul></li><li>通用寄存器 <ul><li>用于暂时存放或传送数据或指令</li><li>可保存ALU的运算中间结果</li><li>容量比一般专用寄存器大</li></ul></li></ul><h2 id="_10-1-cpu的寄存器" tabindex="-1"><a class="header-anchor" href="#_10-1-cpu的寄存器"><span>10.1. CPU的寄存器</span></a></h2><ul><li>用户可见寄存器：CPU执行机器语言访问的寄存器 <ul><li>通用寄存器：可由程序设计者指定许多功能，可用于存放操作数，也可用为满足某种寻址方式所需的寄存器</li><li>数据寄存器：存放操作数</li><li>地址寄存器：存放地址，可用于特殊的寻址方式</li><li>条件码寄存器：存放条件码，对用户部分透明，条件码是CPU根据运算结果由硬件设置的位</li><li>控制和状态寄存器 <ul><li>MAR：存储器地址寄存器、存放将被访问的存储单元的地址</li><li>MDR：存储器数据寄存器、存放欲存入存储器中的数据或最近从存储器中读出的数据</li><li>PC：程序计数器：存放现行指令的地址，可计数</li><li>IR：指令寄存器：存放当前欲执行的指令</li></ul></li></ul></li></ul><h2 id="_10-2-控制单元和中断系统" tabindex="-1"><a class="header-anchor" href="#_10-2-控制单元和中断系统"><span>10.2. 控制单元和中断系统</span></a></h2><ul><li>控制单元CU是提供完成计算机全部指令操作的微操作命令序列部件</li><li>微操作序列形成方法 <ul><li>组合逻辑设计方法，为硬连线逻辑</li><li>微程序设计方法，为存储逻辑</li></ul></li><li>中断系统 <ul><li>处理计算机的各种中断</li></ul></li></ul><h2 id="_10-3-指令周期" tabindex="-1"><a class="header-anchor" href="#_10-3-指令周期"><span>10.3. 指令周期</span></a></h2><ul><li>指令周期:CPU每取出并执行一条指令所需的全部时间，也是CPU完成一条指令的时间 <ul><li>取指周期:完成取指令和分析指令的操作</li><li>执行周期:完成执行指令的操作</li><li>间址周期:间接寻址指令取操作数有效地址</li><li>中断周期:保存程序断点</li></ul></li></ul><h1 id="_11-中断系统" tabindex="-1"><a class="header-anchor" href="#_11-中断系统"><span>11. 中断系统</span></a></h1><h2 id="_11-1-概述" tabindex="-1"><a class="header-anchor" href="#_11-1-概述"><span>11.1. 概述</span></a></h2><ul><li>中断产生原因：为了提高计算机效率。为了处理一些异常情况以及实时控制、多道程序和多处理机的需要</li><li>引起中断的各种因素 <ul><li>人为设置的中断</li><li>程序性事故：如定点溢出</li><li>硬件故障：如插件接触不良</li><li>I/O设备：I/O设备被启动后，一旦准备就绪，便向CPU发出中断请求</li><li>外部事件：用户通过键盘来中断现行程序</li></ul></li><li>中断系统需解决的问题 <ul><li>各中断源如何向CPU提出中断请求</li><li>当多个中断源同时提出中断请求时，中断系统如何确定优先响应那个中断源的请求</li><li>CPU在什么条件、什么时候、以什么方式来响应中断</li><li>CPU响应中断后如何保护现场</li><li>CPU响应中断后，如何停止原程序的执行而转入中断服务程序的入口地址</li><li>中断处理结束后，CPU如何恢复现场，如何回到原程序的间断处</li><li>在中断处理过程中又出现了新的中断请求，CPU该如何处理</li></ul></li><li>中断请求标记：为了判断是哪个中断源提出请求，在中断系统中必须设置中断请求标记触发器INTR，当状态为1，表示中断源有请求，这种触发器可集中设在CPU内，组成一个中断请求标记寄存器</li></ul><h2 id="_11-2-中断判优逻辑" tabindex="-1"><a class="header-anchor" href="#_11-2-中断判优逻辑"><span>11.2. 中断判优逻辑</span></a></h2><ul><li>任何一个中断系统，在任意一个时刻，只能响应一个中断源的请求、各中断源的优先顺序是根据该中断源若得不到及时响应，致使机器工作出错的严重程度而定的。实现方法如下 <ul><li>硬件排队：1.链式排队器，对应中断请求触发器分散在各个接口电路中的情况。2.CPU内的排队器</li><li>软件排队：通过编写查询程序实现，程序按中断源的优先等级，从高至低逐级查询各中断源是否有中断请求</li></ul></li></ul><h2 id="_11-3-中断服务程序入口地址的寻找" tabindex="-1"><a class="header-anchor" href="#_11-3-中断服务程序入口地址的寻找"><span>11.3. 中断服务程序入口地址的寻找</span></a></h2><ul><li>硬件向量法:利用硬件产生向量地址，再由向量地址找到中断服务程序的入口地址.向量地址由中断向量地址部件产生，这个电路课分散设置在各个接口电路中，也可设置在CPU内</li><li>软件查询法:用软件寻找中断服务程序入口地址的方法</li></ul><h2 id="_11-4-中断响应" tabindex="-1"><a class="header-anchor" href="#_11-4-中断响应"><span>11.4. 中断响应</span></a></h2><ul><li>响应中断的条件:CPU响应I/O中断的条件时允许中断触发器必须为“1”</li><li>响应中断的时间:在指令执行周期结束后，响应任何中断源的请求，因为在执行周期结束时刻统一向所有中断源发中断查询信号，只有此时，CPU才能获知哪个中断源有请求</li><li>中断指令操作 <ul><li>保护程序断点：将当前程序计数器PC的内容保存到存储器中。它可以存在存储器的特定单元内，也可以存入堆栈</li><li>寻找中断服务程序的入口地址 <ul><li>第一种，在中断周期内，将向量地址送至PC，使CPU执行下一条无条件转移指令，转至中断服务程序的入口地址</li><li>第二种，在中断周期内，将软件查询入口地址的程序首地址送至PC，使CPU执行中断识别程序，找到入口地址</li></ul></li><li>关中断：中断周期内必须自动关中断，以禁止CPU再次响应新的中断请求</li></ul></li><li>保护现场 <ul><li>保存程序断点：由中断隐指令完成</li><li>CPU内部各寄存器内容的现场：在中断服务程序中由客户或系统用机器指令编程实现</li></ul></li><li>恢复现场<br> 在中断返回前，必须将寄存器的内容恢复到中断处理前的状态，由中断服务程序完成</li></ul><h2 id="_11-5-中断屏蔽技术-用于多重中断" tabindex="-1"><a class="header-anchor" href="#_11-5-中断屏蔽技术-用于多重中断"><span>11.5. 中断屏蔽技术(用于多重中断)</span></a></h2><ul><li>多重中断:当CPU正在执行某个中断服务程序是，另一个中断源又提出了新的中断请求，而CPU又响应了这个新的请求，暂时停止正在运行的服务程序，转去执行新的中断服务程序<br> 实现多重中断条件 <ul><li>提前设置“开中断”指令：多重中断的开中断指令的位置前于单重中断，从而保证多重中断允许出现中断嵌套</li><li>优先级别高的中断源有权中断优先级别低的中断源：在满足上面的条件才行</li></ul></li></ul><h1 id="_12-控制单元的功能" tabindex="-1"><a class="header-anchor" href="#_12-控制单元的功能"><span>12. 控制单元的功能</span></a></h1><h2 id="_12-1-微操作命令的分析" tabindex="-1"><a class="header-anchor" href="#_12-1-微操作命令的分析"><span>12.1. 微操作命令的分析</span></a></h2><ul><li>控制单元具有发出各种微操作命令（控制信号）序列的功能</li><li>取指周期 <ul><li>现行指令地址送至存储器地址寄存器 PC-&gt;MAR</li><li>向主存发送读命令，启动主存读操作 1-&gt;R</li><li>将MAR通过地址总线所指的主存单元中的指令经数据线读至MDR内M(MAR)-&gt;MDR</li><li>将MDR的内容送至IR MDR-&gt;IR</li><li>指令的操作码送至CU译码 OP(PC)-&gt;CU</li><li>形成下一条指令的地址 (PC)+1-&gt;PC</li></ul></li><li>间址周期 <ul><li>将指令的地址码部分送至存储器地址寄存器 Ad(IR)-&gt;MAR</li><li>向主存发送读命令，启动主存作读操作 1-&gt;R</li><li>将MAR通过地址总线所指的主存单元的有效地址经数据总线读至MDR内 M(MAR)-MDR</li><li>将有效地址送至指令寄存器的地址字段MDR-&gt;Ad(IR)</li></ul></li><li>执行周期 <ul><li>非访存指令 <ul><li>清除累加器指令CLA</li><li>累加器取反指令COM</li><li>算术右移一位指令SHR</li><li>循环左移一位指令CSL</li><li>停机指令STP</li></ul></li><li>访存指令 <ul><li>加法指令ADD X</li><li>存数指令STA X</li><li>取数指令LDA X</li></ul></li><li>转移类指令 <ul><li>无条件转移指令 JMP X</li><li>条件转移（负则转）指令BAN</li></ul></li></ul></li></ul><h2 id="_12-2-中断周期" tabindex="-1"><a class="header-anchor" href="#_12-2-中断周期"><span>12.2. 中断周期</span></a></h2><ul><li>将特定地址0送至存储器地址寄存器</li><li>向主存发写命令，启动存储器写操作</li><li>将PC的程序断点送至MDR</li><li>将MDR的程序断点通过数据总线写入到MAR通过地址总线所指示的主存单元0地址单元中</li><li>将向量地址形成部件的输出送至PC，为下一条指令的取指周期做准备</li><li>关中断，将允许中断触发指令清0</li></ul><h1 id="_13-计算机指令的执行过程" tabindex="-1"><a class="header-anchor" href="#_13-计算机指令的执行过程"><span>13. 计算机指令的执行过程</span></a></h1><figure><img src="https://290ff162.telegraph-image-eg9.pages.dev/file/087360e79d3aefd3cb4b5.png" alt="47.PNG" tabindex="0"><figcaption>47.PNG</figcaption></figure><ul><li>CPU的流水线设计</li><li>类似工厂的装配线</li><li>工厂的装配线使得多个产品可以同时被加工</li><li>在同一个时刻，不同产品位于不同的加工阶段</li><li>串行执行m条指令：T1 = 3t x m</li><li>流水线执行m条指令：T2 = t x （m+2）</li><li>H = T2/T1 = t x (m+2) / 3t x m = 1/3 + 1/3m提高了3倍</li></ul><h1 id="cpu实现原子性" tabindex="-1"><a class="header-anchor" href="#cpu实现原子性"><span>CPU实现原子性</span></a></h1><ul><li><p>1.总线锁：指将CPU跟内存之间的通信锁住，其他CPU不能操作共享内存中的数据。即当一个CPU访问数据进行操作时，会先向总线发送一个LOCK#信号，如果成功，该CPU会独享这个共享内存直至操作完成或者超时，而此时其他CPU对内存的操作请求会被阻塞。使用LOCK#信号会把CPU与内存之间的通信锁住，使得锁定期间其他CPU无法操作其他内存地址的数据，因此总线锁开销比较大。</p></li><li><p>2.缓存锁: 指将原子操作放在CPU缓存中进行（L1、L2、L3高速缓存）。“缓存锁定”指当发生共享内存的锁定，CPU不会在总线上声明LOCK#信号，而是对CPU的缓存中的缓存行进行锁定，在锁定期间其他CPU不能同时缓存该数据，在修改后，通过缓存一致性保证原子性。</p></li><li><p>3.只能使用总线锁的情况</p><ul><li>操作的数据不能被缓存在CPU上或操作的数据跨多个缓存行时</li><li>处理器不支持</li></ul></li><li><p>4.MESI</p><ul><li>1.MESI协议是实现缓存一致性的在Intel上使用比较广泛的一种协议，缓存行的状态有四种.该协议要求在每个缓存行中维护两个状态位，使得每个数据单元可能处在这四种状态中的一种。 <ul><li>Modified(修改)表示缓存行的数据被修改了，但是还没有更新到主内存。处于这一状态的数据，只在本CPU中有缓存数据，其他CPU没有。</li><li>Exclusive(独享)表示缓存行中的数据是独有的。处于这一状态的数据，只在本CPU中有缓存，其他CPU没有，且数据与主内存中保持一致。</li><li>Share(共享)表示缓存行中的数据是共享的。处于这一状态的数据在多个CPU中都有缓存，且与主内存保持一致。</li><li>Invalid(无效)表示缓存行中的数据是无效的。</li></ul></li><li>MESI协议通过对不同的状态增添不同的监听任务保证缓存一致性 <ul><li>Modified:处于M状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主内存地址的动作，如果监听到，则必须在此操作将其缓存行中的数据写回主内存，其缓存行状态设置为S。|</li><li>Exclusive:处于E状态的缓存行，必须时刻监听所有试图读取该缓存行对应的主内存地址的动作，如果监听到，则必须将其缓存行状态设置为S|</li><li>Share:处于S状态的缓存行，必须时刻监听所有试图使该缓存行无效或者独享动作，如果监听到，则必须将其缓存行状态设置为I|</li></ul></li></ul></li><li><p>2.MESI消息<br> |消息名|消息类型|描述|<br> |:-😐:-😐:-😐<br> |Read|请求|通知其他处理器，当前处理器准备主内存某个数据。该消息包含待读取数据的内存地址<br> |Read|Respond|响应|该消息包含被请求的读取消息的数据，可能是主内存提供的，也可能是嗅探到Read消息的其他处Cache提供，主要看嗅探到Read消息的Cache中缓存行的状态<br> |Invalidate|请求|通知其他处理器将其高速缓存中指定内存地址对应的缓存行状态置为I<br> |Invalidate|Acknowledge响应 接收到Invalidate消息的处理器必须回复此响应，以表示删除了其高速缓存上的响应副本（置为I）<br> |Read|Invalidate|请求|由Read消息和Invalidate消息组合形成。它的作用是通知其它处理，发送该消息的处理器准备更新一个数据，请求其它处理器删除其高速缓存中相应的副本数据。接收到该消息的处理器必须回复Invalidate Acknowledge消息，主内存回复Read Response消息，发送该消息的处理器期望收到一个Read Response以及多个Invalidate Acknowledge|<br> |Writeback|请求|该消息包含需要写入主内存的数据及其对应的内存地址|</p></li><li><p>3.MESI处理流程</p></li><li><p>MESI协议在数据的读写时，是通过往总线中发送消息请求以及接收响应来保证数据的一致性，以下以两个CPU为例子（CPUA、CPUB）</p></li><li><p>1.数据读流程</p><ul><li>CPUA需要读取数据X,CPUA首先根据数据的地址在自己的缓存中查找</li><li>1.1 如果能找到，并且缓存行状态时M、E、S，说明缓存行的数据对于当前读请求是可用的，直接从缓存行获取地址A对应的数据</li><li>1.2 如果找不到或者缓存行的状态是I，CPUA会先总线发送Read消息，其他处理器（CPUB）会监听总线上的消息，收到消息后，从消息中解析出需要读取的地址，然后在自己的缓存中查找缓存行，根据缓存行的状态会出现不同情况 <ul><li>1.2.1 状态为S/E , CPUB会构造Read Response消息，将缓存行中的数据放到消息中，发送到总线同时更新自己缓存行的状态为S，CPUA收到响应消息后，会将消息中的数据存入相应的缓存行中，同时更新缓存行的状态为S</li><li>1.2.2 状态为M，会先将自己缓存行中的数据写入主内存，并响应Read Response消息同时将缓存行状态更新为S</li><li>1.2.3 状态为I或者在自己的缓存中不存在地址A的数据，那么主内存会构造Read Response消息，从主内存读取包含指定地址的块号数据放入消息（缓存行大小和内存块大小一致所以可以存放的下），并将消息发送到总线（⭐怎么判断消息由CPUB发送还是主内存发送）</li></ul></li><li>CPUA获接收到总线消息之后，解析出数据保存在自己的缓存中。</li></ul></li><li><p>2.数据写流程(一个处理器的缓存回写到内存会导致其他处理器的缓存无效)</p><ul><li>CPUA需要对地址A的X数据进行写操作（⭐任何一个处理器执行内存操作时，必须拥有相应数据的所有权）</li><li>2.1CPUA首先根据内存地址在自己缓存中查找，根据不同的状态有不同处理 <ul><li>2.1.1为E/M时，说明当前CPUA已经拥有了相应数据的所有权，此时CPUA会直接将数据写入缓存行中，并更新缓存行状态为M，此时不需要向总线发送任何消息</li><li>2.1.2为S时，说明数据被共享，其它CPU中有可能存有该数据的副本，则CPUA向总线发送Invalidate 消息以获取数据的所有权，其它处理器（CPUB)收到Invalidate消息后,会将其高速缓存中相应的缓存行状态更新为I，表示已经逻辑删除相应的副本数据，并回复Invalidate Acknowledge消息，CPUA收到所有处理器的响应消息后，会将数据更新到相应的缓存行之中，同时修改缓存行状态为E，此时拥有数据的所有权，会对缓存行数据进行更新，最终该缓存行状态为M</li><li>2.1.3为I时或者找不到时，则CPUA向总线发送Read Invalidate消息 <ul><li>2.1.3.1其它处理器（CPUB）收到Invalidate 消息后，如果缓存行不为I的话，会将其高速缓存中相应的缓存行状态更新为I，表示已经逻辑删除相应的副本数据，并回复\`\`Invalidate Acknowledge\`消息</li><li>2.1.3.2主内存收到Read消息后，会响应Read Response消息将需要读取的数据告诉CPUA</li><li>2.1.3.3CPUA收到所有处理器的Invalidate Acknowledge消息和主内存的Read Response消息后，会将数据更新到相应的缓存行之中，同时修改缓存行状态为E，此时拥有数据的所有权，会对缓存行数据进行更新，最终该缓存行状态为M</li></ul></li></ul></li></ul></li><li><p>MESI 协议更复杂，但我们没必要记得这么细。我们只需要记住最关键的 2 点：</p><ul><li>关键 1 - 阻止同时有多个核心修改的共享数据： 当一个 CPU 核心要求修改数据时，会先广播 RFO 请求获得 Cache 块的所有权，并将其它 CPU 核心中对应的 Cache 块置为已失效状态；</li><li>关键 2 - 延迟回写： 只有在需要的时候才将数据写回内存，当一个 CPU 核心要求访问已失效状态的 Cache 块时，会先要求其它核心先将数据写回内存，再从内存读取。</li></ul></li></ul>`,133),A=[n];function B(h,t){return i(),e("div",null,A)}const s=l(E,[["render",B],["__file","计算机组成原理.html.vue"]]),f=JSON.parse('{"path":"/backend/cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html","title":"计算机组成原理","lang":"zh-CN","frontmatter":{"title":"计算机组成原理","date":"2023-01-01T00:00:00.000Z","tags":"计算机","categories":"理论","description":"计算机组成原理 1. 计算机系统概论 1.1. 计算机系统组成->计算机性能的好坏取决于软硬件功能的总和 1.2. 现代计算机的解题过程 1.3. 计算机系统的层次结构 1.4. 计算机基本组成 2. 计算机发展简史 3. 系统总线 3.1. 总线的基本概念 3.2. 总线分类 3.3. 总线性能指标 3.4. 总线标准 3.5. 总线控制 4. 存储...","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/backend/cs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"JavaGuide"}],["meta",{"property":"og:title","content":"计算机组成原理"}],["meta",{"property":"og:description","content":"计算机组成原理 1. 计算机系统概论 1.1. 计算机系统组成->计算机性能的好坏取决于软硬件功能的总和 1.2. 现代计算机的解题过程 1.3. 计算机系统的层次结构 1.4. 计算机基本组成 2. 计算机发展简史 3. 系统总线 3.1. 总线的基本概念 3.2. 总线分类 3.3. 总线性能指标 3.4. 总线标准 3.5. 总线控制 4. 存储..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://290ff162.telegraph-image-eg9.pages.dev/file/2b1b1bc7cd4defb97dd4a.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-12-07T01:56:33.000Z"}],["meta",{"property":"article:author","content":"HeChuangJun"}],["meta",{"property":"article:published_time","content":"2023-01-01T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-12-07T01:56:33.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"计算机组成原理\\",\\"image\\":[\\"https://290ff162.telegraph-image-eg9.pages.dev/file/2b1b1bc7cd4defb97dd4a.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/f1eaf30bbe80adb74a1a8.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/ffd9f676eecdaf2d46b96.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/89cf6bfb02d7fb5b3fd3d.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/e8201c19b05063373ad5f.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/60609ac2bc8b113115b76.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/1bb119fee9de6648cc32e.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/25a073dfb1519b145a517.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/bc75707d79485b2dbb8b4.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/345cff6c6aca5673b559d.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/487b251954b6e04569b6e.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/6a4bdf735fe6b9defaff1.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/82f12111d9760fa948119.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/44ea13005fa8dace3b384.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/5915ee0d665aa75dca8e8.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/af1be3f8a5a19f9738e5b.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/8fd497485ec44bca2765a.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/c2fcdb7566ae66cd532a2.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/90a2e411c0c74485b9e47.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/33fabec9c0a874b4f5b92.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/c3af2d2b57a8f8b280ff6.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/c1bdf6abd172a57c4efc4.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/323d182b0822f749168e4.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/5bdcb2ff68d462511f3f0.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/568bc0addc5c68dec5d3d.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/ad871a13df917034af41e.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/dfc2d9cbbb8d81d234162.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/d3ed7d3f2499664d185bc.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/c23719ed84b26b05301b9.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/99223cfe689840a5b62dc.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/aa2e9cd7508dd7187ca80.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/955a2f2ec34e75b115ff2.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/c4f2c2c4bf4893ccfc6e9.png\\",\\"https://290ff162.telegraph-image-eg9.pages.dev/file/087360e79d3aefd3cb4b5.png\\"],\\"datePublished\\":\\"2023-01-01T00:00:00.000Z\\",\\"dateModified\\":\\"2024-12-07T01:56:33.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"HeChuangJun\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"1.1. 计算机系统组成->计算机性能的好坏取决于软硬件功能的总和","slug":"_1-1-计算机系统组成-计算机性能的好坏取决于软硬件功能的总和","link":"#_1-1-计算机系统组成-计算机性能的好坏取决于软硬件功能的总和","children":[]},{"level":2,"title":"1.2. 现代计算机的解题过程","slug":"_1-2-现代计算机的解题过程","link":"#_1-2-现代计算机的解题过程","children":[]},{"level":2,"title":"1.3. 计算机系统的层次结构","slug":"_1-3-计算机系统的层次结构","link":"#_1-3-计算机系统的层次结构","children":[]},{"level":2,"title":"1.4. 计算机基本组成","slug":"_1-4-计算机基本组成","link":"#_1-4-计算机基本组成","children":[]},{"level":2,"title":"3.1. 总线的基本概念","slug":"_3-1-总线的基本概念","link":"#_3-1-总线的基本概念","children":[]},{"level":2,"title":"3.2. 总线分类","slug":"_3-2-总线分类","link":"#_3-2-总线分类","children":[]},{"level":2,"title":"3.3. 总线性能指标","slug":"_3-3-总线性能指标","link":"#_3-3-总线性能指标","children":[]},{"level":2,"title":"3.4. 总线标准","slug":"_3-4-总线标准","link":"#_3-4-总线标准","children":[]},{"level":2,"title":"3.5. 总线控制","slug":"_3-5-总线控制","link":"#_3-5-总线控制","children":[]},{"level":2,"title":"4.1. 存储介质","slug":"_4-1-存储介质","link":"#_4-1-存储介质","children":[]},{"level":2,"title":"4.2. 存储器的分类","slug":"_4-2-存储器的分类","link":"#_4-2-存储器的分类","children":[]},{"level":2,"title":"4.3. 存储器的层次结构","slug":"_4-3-存储器的层次结构","link":"#_4-3-存储器的层次结构","children":[]},{"level":2,"title":"4.4. 存储系统层次结构","slug":"_4-4-存储系统层次结构","link":"#_4-4-存储系统层次结构","children":[]},{"level":2,"title":"4.5. 主存储器","slug":"_4-5-主存储器","link":"#_4-5-主存储器","children":[]},{"level":2,"title":"4.6. 存储器的校验(汉明码)","slug":"_4-6-存储器的校验-汉明码","link":"#_4-6-存储器的校验-汉明码","children":[]},{"level":2,"title":"4.7. 高速缓冲存储器","slug":"_4-7-高速缓冲存储器","link":"#_4-7-高速缓冲存储器","children":[]},{"level":2,"title":"4.8. ？？？？缓存-主存地址映射方式（主存地址映射到Cache地址称为地址映射）","slug":"_4-8-缓存-主存地址映射方式-主存地址映射到cache地址称为地址映射","link":"#_4-8-缓存-主存地址映射方式-主存地址映射到cache地址称为地址映射","children":[]},{"level":2,"title":"4.9. 替换策略","slug":"_4-9-替换策略","link":"#_4-9-替换策略","children":[]},{"level":2,"title":"4.10. 辅助存储器","slug":"_4-10-辅助存储器","link":"#_4-10-辅助存储器","children":[]},{"level":2,"title":"5.1. 输入输出系统发展概况","slug":"_5-1-输入输出系统发展概况","link":"#_5-1-输入输出系统发展概况","children":[]},{"level":2,"title":"5.2. 输入输出系统的组成","slug":"_5-2-输入输出系统的组成","link":"#_5-2-输入输出系统的组成","children":[]},{"level":2,"title":"5.3. I/O设备与主机的联系方式","slug":"_5-3-i-o设备与主机的联系方式","link":"#_5-3-i-o设备与主机的联系方式","children":[]},{"level":2,"title":"5.4. I/O设备与主机信息传送的控制方式","slug":"_5-4-i-o设备与主机信息传送的控制方式","link":"#_5-4-i-o设备与主机信息传送的控制方式","children":[]},{"level":2,"title":"5.5. I/O接口","slug":"_5-5-i-o接口","link":"#_5-5-i-o接口","children":[]},{"level":2,"title":"5.6. 接口的功能和组成","slug":"_5-6-接口的功能和组成","link":"#_5-6-接口的功能和组成","children":[]},{"level":2,"title":"5.7. 程序中断方式","slug":"_5-7-程序中断方式","link":"#_5-7-程序中断方式","children":[]},{"level":2,"title":"5.8. 中断服务程序的流程","slug":"_5-8-中断服务程序的流程","link":"#_5-8-中断服务程序的流程","children":[]},{"level":2,"title":"5.9. DMA方式","slug":"_5-9-dma方式","link":"#_5-9-dma方式","children":[]},{"level":2,"title":"6.1. 进制的概述","slug":"_6-1-进制的概述","link":"#_6-1-进制的概述","children":[]},{"level":2,"title":"6.2. 计算机中的数","slug":"_6-2-计算机中的数","link":"#_6-2-计算机中的数","children":[]},{"level":2,"title":"6.3. 数的定点表示和浮点表示","slug":"_6-3-数的定点表示和浮点表示","link":"#_6-3-数的定点表示和浮点表示","children":[]},{"level":2,"title":"6.4. 定点数的加减法","slug":"_6-4-定点数的加减法","link":"#_6-4-定点数的加减法","children":[]},{"level":2,"title":"6.5. 定点数乘法运算","slug":"_6-5-定点数乘法运算","link":"#_6-5-定点数乘法运算","children":[]},{"level":2,"title":"6.6. 定点数除法运算","slug":"_6-6-定点数除法运算","link":"#_6-6-定点数除法运算","children":[]},{"level":2,"title":"6.7. 浮点数的加减法","slug":"_6-7-浮点数的加减法","link":"#_6-7-浮点数的加减法","children":[]},{"level":2,"title":"7.1. 机器指令","slug":"_7-1-机器指令","link":"#_7-1-机器指令","children":[]},{"level":2,"title":"7.2. 操作数类型","slug":"_7-2-操作数类型","link":"#_7-2-操作数类型","children":[]},{"level":2,"title":"7.3. 操作类型","slug":"_7-3-操作类型","link":"#_7-3-操作类型","children":[]},{"level":2,"title":"7.4. 寻址方式","slug":"_7-4-寻址方式","link":"#_7-4-寻址方式","children":[]},{"level":2,"title":"8.1. 控制器的基本功能","slug":"_8-1-控制器的基本功能","link":"#_8-1-控制器的基本功能","children":[]},{"level":2,"title":"8.2. CPU结构框图","slug":"_8-2-cpu结构框图","link":"#_8-2-cpu结构框图","children":[]},{"level":2,"title":"10.1. CPU的寄存器","slug":"_10-1-cpu的寄存器","link":"#_10-1-cpu的寄存器","children":[]},{"level":2,"title":"10.2. 控制单元和中断系统","slug":"_10-2-控制单元和中断系统","link":"#_10-2-控制单元和中断系统","children":[]},{"level":2,"title":"10.3. 指令周期","slug":"_10-3-指令周期","link":"#_10-3-指令周期","children":[]},{"level":2,"title":"11.1. 概述","slug":"_11-1-概述","link":"#_11-1-概述","children":[]},{"level":2,"title":"11.2. 中断判优逻辑","slug":"_11-2-中断判优逻辑","link":"#_11-2-中断判优逻辑","children":[]},{"level":2,"title":"11.3. 中断服务程序入口地址的寻找","slug":"_11-3-中断服务程序入口地址的寻找","link":"#_11-3-中断服务程序入口地址的寻找","children":[]},{"level":2,"title":"11.4. 中断响应","slug":"_11-4-中断响应","link":"#_11-4-中断响应","children":[]},{"level":2,"title":"11.5. 中断屏蔽技术(用于多重中断)","slug":"_11-5-中断屏蔽技术-用于多重中断","link":"#_11-5-中断屏蔽技术-用于多重中断","children":[]},{"level":2,"title":"12.1. 微操作命令的分析","slug":"_12-1-微操作命令的分析","link":"#_12-1-微操作命令的分析","children":[]},{"level":2,"title":"12.2. 中断周期","slug":"_12-2-中断周期","link":"#_12-2-中断周期","children":[]}],"git":{"createdTime":1733536593000,"updatedTime":1733536593000,"contributors":[{"name":"HeChuangJun","email":"1105128664@qq.com","commits":1}]},"readingTime":{"minutes":81.34,"words":24403},"filePathRelative":"backend/cs/计算机组成原理.md","localizedDate":"2023年1月1日","excerpt":"<p>计算机组成原理</p>\\n<!--more-->\\n<!-- TOC -->\\n<ul>\\n<li><a href=\\"#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA\\">1. 计算机系统概论</a>\\n<ul>\\n<li><a href=\\"#11-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9A%84%E5%A5%BD%E5%9D%8F%E5%8F%96%E5%86%B3%E4%BA%8E%E8%BD%AF%E7%A1%AC%E4%BB%B6%E5%8A%9F%E8%83%BD%E7%9A%84%E6%80%BB%E5%92%8C\\">1.1. 计算机系统组成-&gt;计算机性能的好坏取决于软硬件功能的总和</a></li>\\n<li><a href=\\"#12-%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%A7%A3%E9%A2%98%E8%BF%87%E7%A8%8B\\">1.2. 现代计算机的解题过程</a></li>\\n<li><a href=\\"#13-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\\">1.3. 计算机系统的层次结构</a></li>\\n<li><a href=\\"#14-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90\\">1.4. 计算机基本组成</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2\\">2. 计算机发展简史</a></li>\\n<li><a href=\\"#3-%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF\\">3. 系统总线</a>\\n<ul>\\n<li><a href=\\"#31-%E6%80%BB%E7%BA%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\\">3.1. 总线的基本概念</a></li>\\n<li><a href=\\"#32-%E6%80%BB%E7%BA%BF%E5%88%86%E7%B1%BB\\">3.2. 总线分类</a></li>\\n<li><a href=\\"#33-%E6%80%BB%E7%BA%BF%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87\\">3.3. 总线性能指标</a></li>\\n<li><a href=\\"#34-%E6%80%BB%E7%BA%BF%E6%A0%87%E5%87%86\\">3.4. 总线标准</a></li>\\n<li><a href=\\"#35-%E6%80%BB%E7%BA%BF%E6%8E%A7%E5%88%B6\\">3.5. 总线控制</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#4-%E5%AD%98%E5%82%A8%E5%99%A8\\">4. 存储器</a>\\n<ul>\\n<li><a href=\\"#41-%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8\\">4.1. 存储介质</a></li>\\n<li><a href=\\"#42-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB\\">4.2. 存储器的分类</a></li>\\n<li><a href=\\"#43-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\\">4.3. 存储器的层次结构</a></li>\\n<li><a href=\\"#44-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\\">4.4. 存储系统层次结构</a></li>\\n<li><a href=\\"#45-%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8\\">4.5. 主存储器</a></li>\\n<li><a href=\\"#46-%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%A0%A1%E9%AA%8C%E6%B1%89%E6%98%8E%E7%A0%81\\">4.6. 存储器的校验(汉明码)</a></li>\\n<li><a href=\\"#47-%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8\\">4.7. 高速缓冲存储器</a></li>\\n<li><a href=\\"#48-%E7%BC%93%E5%AD%98-%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84%E5%88%B0cache%E5%9C%B0%E5%9D%80%E7%A7%B0%E4%B8%BA%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84\\">4.8. ？？？？缓存-主存地址映射方式（主存地址映射到Cache地址称为地址映射）</a></li>\\n<li><a href=\\"#49-%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5\\">4.9. 替换策略</a></li>\\n<li><a href=\\"#410-%E8%BE%85%E5%8A%A9%E5%AD%98%E5%82%A8%E5%99%A8\\">4.10. 辅助存储器</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#5-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F\\">5. 输入输出系统</a>\\n<ul>\\n<li><a href=\\"#51-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%E5%8F%91%E5%B1%95%E6%A6%82%E5%86%B5\\">5.1. 输入输出系统发展概况</a></li>\\n<li><a href=\\"#52-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90\\">5.2. 输入输出系统的组成</a></li>\\n<li><a href=\\"#53-io%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%B8%BB%E6%9C%BA%E7%9A%84%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F\\">5.3. I/O设备与主机的联系方式</a></li>\\n<li><a href=\\"#54-io%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%B8%BB%E6%9C%BA%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%81%E7%9A%84%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F\\">5.4. I/O设备与主机信息传送的控制方式</a></li>\\n<li><a href=\\"#55-io%E6%8E%A5%E5%8F%A3\\">5.5. I/O接口</a></li>\\n<li><a href=\\"#56-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%BB%84%E6%88%90\\">5.6. 接口的功能和组成</a></li>\\n<li><a href=\\"#57-%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F\\">5.7. 程序中断方式</a></li>\\n<li><a href=\\"#58-%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%B5%81%E7%A8%8B\\">5.8. 中断服务程序的流程</a></li>\\n<li><a href=\\"#59-dma%E6%96%B9%E5%BC%8F\\">5.9. DMA方式</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#6-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95\\">6. 计算机的运算方法</a>\\n<ul>\\n<li><a href=\\"#61-%E8%BF%9B%E5%88%B6%E7%9A%84%E6%A6%82%E8%BF%B0\\">6.1. 进制的概述</a></li>\\n<li><a href=\\"#62-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%95%B0\\">6.2. 计算机中的数</a></li>\\n<li><a href=\\"#63-%E6%95%B0%E7%9A%84%E5%AE%9A%E7%82%B9%E8%A1%A8%E7%A4%BA%E5%92%8C%E6%B5%AE%E7%82%B9%E8%A1%A8%E7%A4%BA\\">6.3. 数的定点表示和浮点表示</a></li>\\n<li><a href=\\"#64-%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95\\">6.4. 定点数的加减法</a></li>\\n<li><a href=\\"#65-%E5%AE%9A%E7%82%B9%E6%95%B0%E4%B9%98%E6%B3%95%E8%BF%90%E7%AE%97\\">6.5. 定点数乘法运算</a></li>\\n<li><a href=\\"#66-%E5%AE%9A%E7%82%B9%E6%95%B0%E9%99%A4%E6%B3%95%E8%BF%90%E7%AE%97\\">6.6. 定点数除法运算</a></li>\\n<li><a href=\\"#67-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95\\">6.7. 浮点数的加减法</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#7-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F\\">7. 指令系统</a>\\n<ul>\\n<li><a href=\\"#71-%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4\\">7.1. 机器指令</a></li>\\n<li><a href=\\"#72-%E6%93%8D%E4%BD%9C%E6%95%B0%E7%B1%BB%E5%9E%8B\\">7.2. 操作数类型</a></li>\\n<li><a href=\\"#73-%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B\\">7.3. 操作类型</a></li>\\n<li><a href=\\"#74-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F\\">7.4. 寻址方式</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#8-cpu%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD\\">8. CPU的结构和功能</a>\\n<ul>\\n<li><a href=\\"#81-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD\\">8.1. 控制器的基本功能</a></li>\\n<li><a href=\\"#82-cpu%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE\\">8.2. CPU结构框图</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8\\">9. 计算机的控制器</a></li>\\n<li><a href=\\"#10-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E5%99%A8\\">10. 计算机的运算器</a>\\n<ul>\\n<li><a href=\\"#101-cpu%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8\\">10.1. CPU的寄存器</a></li>\\n<li><a href=\\"#102-%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E5%92%8C%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F\\">10.2. 控制单元和中断系统</a></li>\\n<li><a href=\\"#103-%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F\\">10.3. 指令周期</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#11-%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F\\">11. 中断系统</a>\\n<ul>\\n<li><a href=\\"#111-%E6%A6%82%E8%BF%B0\\">11.1. 概述</a></li>\\n<li><a href=\\"#112-%E4%B8%AD%E6%96%AD%E5%88%A4%E4%BC%98%E9%80%BB%E8%BE%91\\">11.2. 中断判优逻辑</a></li>\\n<li><a href=\\"#113-%E4%B8%AD%E6%96%AD%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%E7%9A%84%E5%AF%BB%E6%89%BE\\">11.3. 中断服务程序入口地址的寻找</a></li>\\n<li><a href=\\"#114-%E4%B8%AD%E6%96%AD%E5%93%8D%E5%BA%94\\">11.4. 中断响应</a></li>\\n<li><a href=\\"#115-%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%8A%80%E6%9C%AF%E7%94%A8%E4%BA%8E%E5%A4%9A%E9%87%8D%E4%B8%AD%E6%96%AD\\">11.5. 中断屏蔽技术(用于多重中断)</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#12-%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E7%9A%84%E5%8A%9F%E8%83%BD\\">12. 控制单元的功能</a>\\n<ul>\\n<li><a href=\\"#121-%E5%BE%AE%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E7%9A%84%E5%88%86%E6%9E%90\\">12.1. 微操作命令的分析</a></li>\\n<li><a href=\\"#122-%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F\\">12.2. 中断周期</a></li>\\n</ul>\\n</li>\\n<li><a href=\\"#13-%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B\\">13. 计算机指令的执行过程</a></li>\\n<li><a href=\\"#cpu%E5%AE%9E%E7%8E%B0%E5%8E%9F%E5%AD%90%E6%80%A7\\">CPU实现原子性</a></li>\\n</ul>","autoDesc":true}');export{s as comp,f as data};
